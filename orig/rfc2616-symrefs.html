<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en">
   <head profile="http://www.w3.org/2006/03/hcard">
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>Hypertext Transfer Protocol -- HTTP/1.1</title><style type="text/css" title="Xml2Rfc (sans serif)">
a {
  text-decoration: none;
}
a.smpl {
  color: black;
}
a:hover {
  text-decoration: underline;
}
a:active {
  text-decoration: underline;
}
address {
  margin-top: 1em;
  margin-left: 2em;
  font-style: normal;
}
body {
  color: black;
  font-family: verdana, helvetica, arial, sans-serif;
  font-size: 10pt;
}
cite {
  font-style: normal;
}
dd {
  margin-right: 2em;
}
dl {
  margin-left: 2em;
}

dl.empty dd {
  margin-top: .5em;
}
dl p {
  margin-left: 0em;
}
dt {
  margin-top: .5em;
}
h1 {
  font-size: 14pt;
  line-height: 21pt;
  page-break-after: avoid;
}
h1.np {
  page-break-before: always;
}
h1 a {
  color: #333333;
}
h2 {
  font-size: 12pt;
  line-height: 15pt;
  page-break-after: avoid;
}
h2 a {
  color: black;
}
h3 {
  font-size: 10pt;
  page-break-after: avoid;
}
h3 a {
  color: black;
}
h4 {
  font-size: 10pt;
  page-break-after: avoid;
}
h4 a {
  color: black;
}
h5 {
  font-size: 10pt;
  page-break-after: avoid;
}
h5 a {
  color: black;
}
img {
  margin-left: 3em;
}
li {
  margin-left: 2em;
  margin-right: 2em;
}
ol {
  margin-left: 2em;
  margin-right: 2em;
}
ol p {
  margin-left: 0em;
}
p {
  margin-left: 2em;
  margin-right: 2em;
}
pre {
  margin-left: 3em;
  background-color: lightyellow;
  padding: .25em;
}
pre.text2 {
  border-style: dotted;
  border-width: 1px;
  background-color: #f0f0f0;
  width: 69em;
}
pre.inline {
  background-color: white;
  padding: 0em;
}
pre.text {
  border-style: dotted;
  border-width: 1px;
  background-color: #f8f8f8;
  width: 69em;
}
pre.drawing {
  border-style: solid;
  border-width: 1px;
  background-color: #f8f8f8;
  padding: 2em;
}
table {
  margin-left: 2em;
}
table.header {
  width: 95%;
  font-size: 10pt;
  color: white;
}
td.top {
  vertical-align: top;
}
td.topnowrap {
  vertical-align: top;
  white-space: nowrap; 
}
td.header {
  background-color: gray;
  width: 50%;
}
td.reference {
  vertical-align: top;
  white-space: nowrap;
  padding-right: 1em;
}
thead {
  display:table-header-group;
}
ul.toc {
  list-style: none;
  margin-left: 1.5em;
  margin-right: 0em;
  padding-left: 0em;
}
li.tocline0 {
  line-height: 150%;
  font-weight: bold;
  font-size: 10pt;
  margin-left: 0em;
  margin-right: 0em;
}
li.tocline1 {
  line-height: normal;
  font-weight: normal;
  font-size: 9pt;
  margin-left: 0em;
  margin-right: 0em;
}
li.tocline2 {
  font-size: 0pt;
}
ul p {
  margin-left: 0em;
}
ul.ind {
  list-style: none;
  margin-left: 1.5em;
  margin-right: 0em;
  padding-left: 0em;
}
li.indline0 {
  font-weight: bold;
  line-height: 200%;
  margin-left: 0em;
  margin-right: 0em;
}
li.indline1 {
  font-weight: normal;
  line-height: 150%;
  margin-left: 0em;
  margin-right: 0em;
}
.bcp14 {
  font-style: normal;
  text-transform: lowercase;
  font-variant: small-caps;
}
.comment {
  background-color: yellow;
}
.center {
  text-align: center;
}
.error {
  color: red;
  font-style: italic;
  font-weight: bold;
}
.figure {
  font-weight: bold;
  text-align: center;
  font-size: 9pt;
}
.filename {
  color: #333333;
  font-weight: bold;
  font-size: 12pt;
  line-height: 21pt;
  text-align: center;
}
.fn {
  font-weight: bold;
}
.hidden {
  display: none;
}
.left {
  text-align: left;
}
.right {
  text-align: right;
}
.title {
  color: #990000;
  font-size: 18pt;
  line-height: 18pt;
  font-weight: bold;
  text-align: center;
  margin-top: 36pt;
}
.vcardline {
  display: block;
}
.warning {
  font-size: 14pt;
  background-color: yellow;
}


@media print {
  .noprint {
    display: none;
  }
  
  a {
    color: black;
    text-decoration: none;
  }

  table.header {
    width: 90%;
  }

  td.header {
    width: 50%;
    color: black;
    background-color: white;
    vertical-align: top;
    font-size: 12pt;
  }

  ul.toc a::after {
    content: leader('.') target-counter(attr(href), page);
  }
  
  a.iref {
    content: target-counter(attr(href), page);
  }
  
  .print2col {
    column-count: 2;
    -moz-column-count: 2;
    column-fill: auto;
  }
}

@page {
  @top-left {
       content: "INTERNET DRAFT"; 
  } 
  @top-right {
       content: "June 1999"; 
  } 
  @top-center {
       content: "HTTP/1.1"; 
  } 
  @bottom-left {
       content: "Fielding, et al."; 
  } 
  @bottom-center {
       content: "Standards Track"; 
  } 
  @bottom-right {
       content: "[Page " counter(page) "]"; 
  } 
}

@page:first { 
    @top-left {
      content: normal;
    }
    @top-right {
      content: normal;
    }
    @top-center {
      content: normal;
    }
}
</style><link rel="Contents" href="#rfc.toc">
      <link rel="Author" href="#rfc.authors">
      <link rel="Copyright" href="#rfc.copyright">
      <link rel="Index" href="#rfc.index">
      <link rel="Chapter" title="1 Introduction" href="#rfc.section.1">
      <link rel="Chapter" title="2 Notational Conventions and Generic Grammar" href="#rfc.section.2">
      <link rel="Chapter" title="3 Protocol Parameters" href="#rfc.section.3">
      <link rel="Chapter" title="4 HTTP Message" href="#rfc.section.4">
      <link rel="Chapter" title="5 Request" href="#rfc.section.5">
      <link rel="Chapter" title="6 Response" href="#rfc.section.6">
      <link rel="Chapter" title="7 Entity" href="#rfc.section.7">
      <link rel="Chapter" title="8 Connections" href="#rfc.section.8">
      <link rel="Chapter" title="9 Method Definitions" href="#rfc.section.9">
      <link rel="Chapter" title="10 Status Code Definitions" href="#rfc.section.10">
      <link rel="Chapter" title="11 Access Authentication" href="#rfc.section.11">
      <link rel="Chapter" title="12 Content Negotiation" href="#rfc.section.12">
      <link rel="Chapter" title="13 Caching in HTTP" href="#rfc.section.13">
      <link rel="Chapter" title="14 Header Field Definitions" href="#rfc.section.14">
      <link rel="Chapter" title="15 Security Considerations" href="#rfc.section.15">
      <link rel="Chapter" title="16 Acknowledgments" href="#rfc.section.16">
      <link rel="Chapter" href="#rfc.section.17" title="17 References">
      <link rel="Appendix" title="19 Appendices" href="#rfc.section.19">
      <link rel="Appendix" title="20 Index" href="#rfc.section.20">
      <meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.353, 2007/12/11 23:20:44, XSLT vendor: SAXON 8.9 from Saxonica http://www.saxonica.com/">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.Creator" content="Fielding, R.">
      <meta name="DC.Creator" content="Gettys, J.">
      <meta name="DC.Creator" content="Mogul, J.">
      <meta name="DC.Creator" content="Frystyk, H.">
      <meta name="DC.Creator" content="Masinter, L.">
      <meta name="DC.Creator" content="Leach, P.">
      <meta name="DC.Creator" content="Berners-Lee, T.">
      <meta name="DC.Identifier" content="urn:ietf:id:rfc2616-symrefs">
      <meta name="DC.Date.Issued" scheme="ISO8601" content="1999-06">
      <meta name="DC.Relation.Replaces" content="urn:ietf:rfc:2068">
      <meta name="DC.Description.Abstract" content="The Hypertext Transfer Protocol (HTTP) is an application-level protocol for distributed, collaborative, hypermedia information systems. It is a generic, stateless, protocol which can be used for many tasks beyond its use for hypertext, such as name servers and distributed object management systems, through extension of its request methods, error codes and headers . A feature of HTTP is the typing and negotiation of data representation, allowing systems to be built independently of the data being transferred. HTTP has been in use by the World-Wide Web global information initiative since 1990. This specification defines the protocol referred to as &#34;HTTP/1.1&#34;, and is an update to RFC 2068 .">
   </head>
   <body>
      <table summary="header information" class="header" border="0" cellpadding="1" cellspacing="1">
         <tr>
            <td class="header left">Network Working Group</td>
            <td class="header right">R. Fielding</td>
         </tr>
         <tr>
            <td class="header left">Internet Draft</td>
            <td class="header right">UC Irvine</td>
         </tr>
         <tr>
            <td class="header left">
               &lt;rfc2616-symrefs&gt;
               
            </td>
            <td class="header right">J. Gettys</td>
         </tr>
         <tr>
            <td class="header left">Obsoletes: <a href="http://tools.ietf.org/html/rfc2068">2068</a> (if approved)
            </td>
            <td class="header right">Compaq/W3C</td>
         </tr>
         <tr>
            <td class="header left">Intended status: Standards Track</td>
            <td class="header right">J. Mogul</td>
         </tr>
         <tr>
            <td class="header left">Expires: December 1999</td>
            <td class="header right">Compaq</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">H. Frystyk</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">W3C/MIT</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">L. Masinter</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">Xerox</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">P. Leach</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">Microsoft</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">T. Berners-Lee</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">W3C/MIT</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">June 1999</td>
         </tr>
      </table>
      <p class="title">Hypertext Transfer Protocol -- HTTP/1.1<br><span class="filename">rfc2616-symrefs</span></p>
      <h1><a id="rfc.status" href="#rfc.status">Status of this Memo</a></h1>
      <p>By submitting this Internet-Draft, each author represents that any applicable patent or other IPR claims of which he or she
         is aware have been or will be disclosed, and any of which he or she becomes aware will be disclosed, in accordance with Section
         6 of BCP 79.
      </p>
      <p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF), its areas, and its working groups. Note
         that other groups may also distribute working documents as Internet-Drafts.
      </p>
      <p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other
         documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work
         in progress”.
      </p>
      <p>The list of current Internet-Drafts can be accessed at &lt;<a href="http://www.ietf.org/ietf/1id-abstracts.txt">http://www.ietf.org/ietf/1id-abstracts.txt</a>&gt;.
      </p>
      <p>The list of Internet-Draft Shadow Directories can be accessed at &lt;<a href="http://www.ietf.org/shadow.html">http://www.ietf.org/shadow.html</a>&gt;.
      </p>
      <p>This Internet-Draft will expire in December 1999.</p>
      <h1><a id="rfc.copyrightnotice" href="#rfc.copyrightnotice">Copyright Notice</a></h1>
      <p>Copyright © The Internet Society (1999). All Rights Reserved.</p>
      <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1> 
      <p>The Hypertext Transfer Protocol (HTTP) is an application-level protocol for distributed, collaborative, hypermedia information
         systems. It is a generic, stateless, protocol which can be used for many tasks beyond its use for hypertext, such as name
         servers and distributed object management systems, through extension of its request methods, error codes and headers <a href="#RFC2324" id="rfc.xref.RFC2324.1"><cite title="Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)">[RFC2324]</cite></a>. A feature of HTTP is the typing and negotiation of data representation, allowing systems to be built independently of the
         data being transferred.
      </p>  
      <p>HTTP has been in use by the World-Wide Web global information initiative since 1990. This specification defines the protocol
         referred to as "HTTP/1.1", and is an update to RFC 2068 <a href="#RFC2068" id="rfc.xref.RFC2068.1"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[RFC2068]</cite></a>.
      </p> 
      <h1 id="rfc.note.1"><a href="#rfc.note.1">Editorial Note (To be removed by RFC Editor)</a></h1> 
      <p>This version of the HTTP specification contains only XML processing changes from [RFC2616] in internet-draft form for use
         in creating diffs.
      </p> 
      <hr class="noprint">
      <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
      <ul class="toc">
         <li class="tocline0">1.&nbsp;&nbsp;&nbsp;<a href="#introduction">Introduction</a><ul class="toc">
               <li class="tocline1">1.1&nbsp;&nbsp;&nbsp;<a href="#intro.purpose">Purpose</a></li>
               <li class="tocline1">1.2&nbsp;&nbsp;&nbsp;<a href="#intro.requirements">Requirements</a></li>
               <li class="tocline1">1.3&nbsp;&nbsp;&nbsp;<a href="#intro.terminology">Terminology</a></li>
               <li class="tocline1">1.4&nbsp;&nbsp;&nbsp;<a href="#intro.overall.operation">Overall Operation</a></li>
            </ul>
         </li>
         <li class="tocline0">2.&nbsp;&nbsp;&nbsp;<a href="#notation">Notational Conventions and Generic Grammar</a><ul class="toc">
               <li class="tocline1">2.1&nbsp;&nbsp;&nbsp;<a href="#notation.abnf">Augmented BNF</a></li>
               <li class="tocline1">2.2&nbsp;&nbsp;&nbsp;<a href="#basic.rules">Basic Rules</a></li>
            </ul>
         </li>
         <li class="tocline0">3.&nbsp;&nbsp;&nbsp;<a href="#protocol.parameters">Protocol Parameters</a><ul class="toc">
               <li class="tocline1">3.1&nbsp;&nbsp;&nbsp;<a href="#http.version">HTTP Version</a></li>
               <li class="tocline1">3.2&nbsp;&nbsp;&nbsp;<a href="#uri">Uniform Resource Identifiers</a><ul class="toc">
                     <li class="tocline1">3.2.1&nbsp;&nbsp;&nbsp;<a href="#general.syntax">General Syntax</a></li>
                     <li class="tocline1">3.2.2&nbsp;&nbsp;&nbsp;<a href="#http.url">http URL</a></li>
                     <li class="tocline1">3.2.3&nbsp;&nbsp;&nbsp;<a href="#uri.comparison">URI Comparison</a></li>
                  </ul>
               </li>
               <li class="tocline1">3.3&nbsp;&nbsp;&nbsp;<a href="#date.time.formats">Date/Time Formats</a><ul class="toc">
                     <li class="tocline1">3.3.1&nbsp;&nbsp;&nbsp;<a href="#full.date">Full Date</a></li>
                     <li class="tocline1">3.3.2&nbsp;&nbsp;&nbsp;<a href="#delta.seconds">Delta Seconds</a></li>
                  </ul>
               </li>
               <li class="tocline1">3.4&nbsp;&nbsp;&nbsp;<a href="#character.sets">Character Sets</a><ul class="toc">
                     <li class="tocline1">3.4.1&nbsp;&nbsp;&nbsp;<a href="#missing.charset">Missing Charset</a></li>
                  </ul>
               </li>
               <li class="tocline1">3.5&nbsp;&nbsp;&nbsp;<a href="#content.codings">Content Codings</a></li>
               <li class="tocline1">3.6&nbsp;&nbsp;&nbsp;<a href="#transfer.codings">Transfer Codings</a><ul class="toc">
                     <li class="tocline1">3.6.1&nbsp;&nbsp;&nbsp;<a href="#chunked.transfer.encoding">Chunked Transfer Coding</a></li>
                  </ul>
               </li>
               <li class="tocline1">3.7&nbsp;&nbsp;&nbsp;<a href="#media.types">Media Types</a><ul class="toc">
                     <li class="tocline1">3.7.1&nbsp;&nbsp;&nbsp;<a href="#canonicalization.and.text.defaults">Canonicalization and Text Defaults</a></li>
                     <li class="tocline1">3.7.2&nbsp;&nbsp;&nbsp;<a href="#multipart.types">Multipart Types</a></li>
                  </ul>
               </li>
               <li class="tocline1">3.8&nbsp;&nbsp;&nbsp;<a href="#product.tokens">Product Tokens</a></li>
               <li class="tocline1">3.9&nbsp;&nbsp;&nbsp;<a href="#quality.values">Quality Values</a></li>
               <li class="tocline1">3.10&nbsp;&nbsp;&nbsp;<a href="#language.tags">Language Tags</a></li>
               <li class="tocline1">3.11&nbsp;&nbsp;&nbsp;<a href="#entity.tags">Entity Tags</a></li>
               <li class="tocline1">3.12&nbsp;&nbsp;&nbsp;<a href="#range.units">Range Units</a></li>
            </ul>
         </li>
         <li class="tocline0">4.&nbsp;&nbsp;&nbsp;<a href="#http.message">HTTP Message</a><ul class="toc">
               <li class="tocline1">4.1&nbsp;&nbsp;&nbsp;<a href="#message.types">Message Types</a></li>
               <li class="tocline1">4.2&nbsp;&nbsp;&nbsp;<a href="#message.headers">Message Headers</a></li>
               <li class="tocline1">4.3&nbsp;&nbsp;&nbsp;<a href="#message.body">Message Body</a></li>
               <li class="tocline1">4.4&nbsp;&nbsp;&nbsp;<a href="#message.length">Message Length</a></li>
               <li class="tocline1">4.5&nbsp;&nbsp;&nbsp;<a href="#general.header.fields">General Header Fields</a></li>
            </ul>
         </li>
         <li class="tocline0">5.&nbsp;&nbsp;&nbsp;<a href="#request">Request</a><ul class="toc">
               <li class="tocline1">5.1&nbsp;&nbsp;&nbsp;<a href="#request-line">Request-Line</a><ul class="toc">
                     <li class="tocline1">5.1.1&nbsp;&nbsp;&nbsp;<a href="#method">Method</a></li>
                     <li class="tocline1">5.1.2&nbsp;&nbsp;&nbsp;<a href="#request-uri">Request-URI</a></li>
                  </ul>
               </li>
               <li class="tocline1">5.2&nbsp;&nbsp;&nbsp;<a href="#the.resource.identified.by.a.request">The Resource Identified by a Request</a></li>
               <li class="tocline1">5.3&nbsp;&nbsp;&nbsp;<a href="#request.header.fields">Request Header Fields</a></li>
            </ul>
         </li>
         <li class="tocline0">6.&nbsp;&nbsp;&nbsp;<a href="#response">Response</a><ul class="toc">
               <li class="tocline1">6.1&nbsp;&nbsp;&nbsp;<a href="#status-line">Status-Line</a><ul class="toc">
                     <li class="tocline1">6.1.1&nbsp;&nbsp;&nbsp;<a href="#status.code.and.reason.phrase">Status Code and Reason Phrase</a></li>
                  </ul>
               </li>
               <li class="tocline1">6.2&nbsp;&nbsp;&nbsp;<a href="#response.header.fields">Response Header Fields</a></li>
            </ul>
         </li>
         <li class="tocline0">7.&nbsp;&nbsp;&nbsp;<a href="#entity">Entity</a><ul class="toc">
               <li class="tocline1">7.1&nbsp;&nbsp;&nbsp;<a href="#entity.header.fields">Entity Header Fields</a></li>
               <li class="tocline1">7.2&nbsp;&nbsp;&nbsp;<a href="#entity.body">Entity Body</a><ul class="toc">
                     <li class="tocline1">7.2.1&nbsp;&nbsp;&nbsp;<a href="#type">Type</a></li>
                     <li class="tocline1">7.2.2&nbsp;&nbsp;&nbsp;<a href="#entity.length">Entity Length</a></li>
                  </ul>
               </li>
            </ul>
         </li>
         <li class="tocline0">8.&nbsp;&nbsp;&nbsp;<a href="#connections">Connections</a><ul class="toc">
               <li class="tocline1">8.1&nbsp;&nbsp;&nbsp;<a href="#persistent.connections">Persistent Connections</a><ul class="toc">
                     <li class="tocline1">8.1.1&nbsp;&nbsp;&nbsp;<a href="#persistent.purpose">Purpose</a></li>
                     <li class="tocline1">8.1.2&nbsp;&nbsp;&nbsp;<a href="#persistent.overall">Overall Operation</a><ul class="toc">
                           <li class="tocline1">8.1.2.1&nbsp;&nbsp;&nbsp;<a href="#persistent.negotiation">Negotiation</a></li>
                           <li class="tocline1">8.1.2.2&nbsp;&nbsp;&nbsp;<a href="#pipelining">Pipelining</a></li>
                        </ul>
                     </li>
                     <li class="tocline1">8.1.3&nbsp;&nbsp;&nbsp;<a href="#persistent.proxy">Proxy Servers</a></li>
                     <li class="tocline1">8.1.4&nbsp;&nbsp;&nbsp;<a href="#persistent.practical">Practical Considerations</a></li>
                  </ul>
               </li>
               <li class="tocline1">8.2&nbsp;&nbsp;&nbsp;<a href="#message.transmission.requirements">Message Transmission Requirements</a><ul class="toc">
                     <li class="tocline1">8.2.1&nbsp;&nbsp;&nbsp;<a href="#persistent.flow">Persistent Connections and Flow Control</a></li>
                     <li class="tocline1">8.2.2&nbsp;&nbsp;&nbsp;<a href="#persistent.monitor">Monitoring Connections for Error Status Messages</a></li>
                     <li class="tocline1">8.2.3&nbsp;&nbsp;&nbsp;<a href="#use.of.the.100.status">Use of the 100 (Continue) Status</a></li>
                     <li class="tocline1">8.2.4&nbsp;&nbsp;&nbsp;<a href="#connection.premature">Client Behavior if Server Prematurely Closes Connection</a></li>
                  </ul>
               </li>
            </ul>
         </li>
         <li class="tocline0">9.&nbsp;&nbsp;&nbsp;<a href="#method.definitions">Method Definitions</a><ul class="toc">
               <li class="tocline1">9.1&nbsp;&nbsp;&nbsp;<a href="#safe.and.idempotent">Safe and Idempotent Methods</a><ul class="toc">
                     <li class="tocline1">9.1.1&nbsp;&nbsp;&nbsp;<a href="#safe.methods">Safe Methods</a></li>
                     <li class="tocline1">9.1.2&nbsp;&nbsp;&nbsp;<a href="#idempotent.methods">Idempotent Methods</a></li>
                  </ul>
               </li>
               <li class="tocline1">9.2&nbsp;&nbsp;&nbsp;<a href="#OPTIONS">OPTIONS</a></li>
               <li class="tocline1">9.3&nbsp;&nbsp;&nbsp;<a href="#GET">GET</a></li>
               <li class="tocline1">9.4&nbsp;&nbsp;&nbsp;<a href="#HEAD">HEAD</a></li>
               <li class="tocline1">9.5&nbsp;&nbsp;&nbsp;<a href="#POST">POST</a></li>
               <li class="tocline1">9.6&nbsp;&nbsp;&nbsp;<a href="#PUT">PUT</a></li>
               <li class="tocline1">9.7&nbsp;&nbsp;&nbsp;<a href="#DELETE">DELETE</a></li>
               <li class="tocline1">9.8&nbsp;&nbsp;&nbsp;<a href="#TRACE">TRACE</a></li>
               <li class="tocline1">9.9&nbsp;&nbsp;&nbsp;<a href="#CONNECT">CONNECT</a></li>
            </ul>
         </li>
         <li class="tocline0">10.&nbsp;&nbsp;&nbsp;<a href="#status.codes">Status Code Definitions</a><ul class="toc">
               <li class="tocline1">10.1&nbsp;&nbsp;&nbsp;<a href="#status.1xx">Informational 1xx</a><ul class="toc">
                     <li class="tocline1">10.1.1&nbsp;&nbsp;&nbsp;<a href="#status.100">100 Continue</a></li>
                     <li class="tocline1">10.1.2&nbsp;&nbsp;&nbsp;<a href="#status.101">101 Switching Protocols</a></li>
                  </ul>
               </li>
               <li class="tocline1">10.2&nbsp;&nbsp;&nbsp;<a href="#status.2xx">Successful 2xx</a><ul class="toc">
                     <li class="tocline1">10.2.1&nbsp;&nbsp;&nbsp;<a href="#status.200">200 OK</a></li>
                     <li class="tocline1">10.2.2&nbsp;&nbsp;&nbsp;<a href="#status.201">201 Created</a></li>
                     <li class="tocline1">10.2.3&nbsp;&nbsp;&nbsp;<a href="#status.202">202 Accepted</a></li>
                     <li class="tocline1">10.2.4&nbsp;&nbsp;&nbsp;<a href="#status.203">203 Non-Authoritative Information</a></li>
                     <li class="tocline1">10.2.5&nbsp;&nbsp;&nbsp;<a href="#status.204">204 No Content</a></li>
                     <li class="tocline1">10.2.6&nbsp;&nbsp;&nbsp;<a href="#status.205">205 Reset Content</a></li>
                     <li class="tocline1">10.2.7&nbsp;&nbsp;&nbsp;<a href="#status.206">206 Partial Content</a></li>
                  </ul>
               </li>
               <li class="tocline1">10.3&nbsp;&nbsp;&nbsp;<a href="#status.3xx">Redirection 3xx</a><ul class="toc">
                     <li class="tocline1">10.3.1&nbsp;&nbsp;&nbsp;<a href="#status.300">300 Multiple Choices</a></li>
                     <li class="tocline1">10.3.2&nbsp;&nbsp;&nbsp;<a href="#status.301">301 Moved Permanently</a></li>
                     <li class="tocline1">10.3.3&nbsp;&nbsp;&nbsp;<a href="#status.302">302 Found</a></li>
                     <li class="tocline1">10.3.4&nbsp;&nbsp;&nbsp;<a href="#status.303">303 See Other</a></li>
                     <li class="tocline1">10.3.5&nbsp;&nbsp;&nbsp;<a href="#status.304">304 Not Modified</a></li>
                     <li class="tocline1">10.3.6&nbsp;&nbsp;&nbsp;<a href="#status.305">305 Use Proxy</a></li>
                     <li class="tocline1">10.3.7&nbsp;&nbsp;&nbsp;<a href="#status.306">306 (Unused)</a></li>
                     <li class="tocline1">10.3.8&nbsp;&nbsp;&nbsp;<a href="#status.307">307 Temporary Redirect</a></li>
                  </ul>
               </li>
               <li class="tocline1">10.4&nbsp;&nbsp;&nbsp;<a href="#status.4xx">Client Error 4xx</a><ul class="toc">
                     <li class="tocline1">10.4.1&nbsp;&nbsp;&nbsp;<a href="#status.400">400 Bad Request</a></li>
                     <li class="tocline1">10.4.2&nbsp;&nbsp;&nbsp;<a href="#status.401">401 Unauthorized</a></li>
                     <li class="tocline1">10.4.3&nbsp;&nbsp;&nbsp;<a href="#status.402">402 Payment Required</a></li>
                     <li class="tocline1">10.4.4&nbsp;&nbsp;&nbsp;<a href="#status.403">403 Forbidden</a></li>
                     <li class="tocline1">10.4.5&nbsp;&nbsp;&nbsp;<a href="#status.404">404 Not Found</a></li>
                     <li class="tocline1">10.4.6&nbsp;&nbsp;&nbsp;<a href="#status.405">405 Method Not Allowed</a></li>
                     <li class="tocline1">10.4.7&nbsp;&nbsp;&nbsp;<a href="#status.406">406 Not Acceptable</a></li>
                     <li class="tocline1">10.4.8&nbsp;&nbsp;&nbsp;<a href="#status.407">407 Proxy Authentication Required</a></li>
                     <li class="tocline1">10.4.9&nbsp;&nbsp;&nbsp;<a href="#status.408">408 Request Timeout</a></li>
                     <li class="tocline1">10.4.10&nbsp;&nbsp;&nbsp;<a href="#status.409">409 Conflict</a></li>
                     <li class="tocline1">10.4.11&nbsp;&nbsp;&nbsp;<a href="#status.410">410 Gone</a></li>
                     <li class="tocline1">10.4.12&nbsp;&nbsp;&nbsp;<a href="#status.411">411 Length Required</a></li>
                     <li class="tocline1">10.4.13&nbsp;&nbsp;&nbsp;<a href="#status.412">412 Precondition Failed</a></li>
                     <li class="tocline1">10.4.14&nbsp;&nbsp;&nbsp;<a href="#status.413">413 Request Entity Too Large</a></li>
                     <li class="tocline1">10.4.15&nbsp;&nbsp;&nbsp;<a href="#status.414">414 Request-URI Too Long</a></li>
                     <li class="tocline1">10.4.16&nbsp;&nbsp;&nbsp;<a href="#status.415">415 Unsupported Media Type</a></li>
                     <li class="tocline1">10.4.17&nbsp;&nbsp;&nbsp;<a href="#status.416">416 Requested Range Not Satisfiable</a></li>
                     <li class="tocline1">10.4.18&nbsp;&nbsp;&nbsp;<a href="#status.417">417 Expectation Failed</a></li>
                  </ul>
               </li>
               <li class="tocline1">10.5&nbsp;&nbsp;&nbsp;<a href="#status.5xx">Server Error 5xx</a><ul class="toc">
                     <li class="tocline1">10.5.1&nbsp;&nbsp;&nbsp;<a href="#status.500">500 Internal Server Error</a></li>
                     <li class="tocline1">10.5.2&nbsp;&nbsp;&nbsp;<a href="#status.501">501 Not Implemented</a></li>
                     <li class="tocline1">10.5.3&nbsp;&nbsp;&nbsp;<a href="#status.502">502 Bad Gateway</a></li>
                     <li class="tocline1">10.5.4&nbsp;&nbsp;&nbsp;<a href="#status.503">503 Service Unavailable</a></li>
                     <li class="tocline1">10.5.5&nbsp;&nbsp;&nbsp;<a href="#status.504">504 Gateway Timeout</a></li>
                     <li class="tocline1">10.5.6&nbsp;&nbsp;&nbsp;<a href="#status.505">505 HTTP Version Not Supported</a></li>
                  </ul>
               </li>
            </ul>
         </li>
         <li class="tocline0">11.&nbsp;&nbsp;&nbsp;<a href="#access.authentication">Access Authentication</a></li>
         <li class="tocline0">12.&nbsp;&nbsp;&nbsp;<a href="#content.negotiation">Content Negotiation</a><ul class="toc">
               <li class="tocline1">12.1&nbsp;&nbsp;&nbsp;<a href="#server-driven.negotiation">Server-driven Negotiation</a></li>
               <li class="tocline1">12.2&nbsp;&nbsp;&nbsp;<a href="#agent-driven.negotiation">Agent-driven Negotiation</a></li>
               <li class="tocline1">12.3&nbsp;&nbsp;&nbsp;<a href="#transparent.negotiation">Transparent Negotiation</a></li>
            </ul>
         </li>
         <li class="tocline0">13.&nbsp;&nbsp;&nbsp;<a href="#caching">Caching in HTTP</a><ul class="toc">
               <li class="tocline1">13.1&nbsp;&nbsp;&nbsp;<a href="#rfc.section.13.1"></a><ul class="toc">
                     <li class="tocline1">13.1.1&nbsp;&nbsp;&nbsp;<a href="#cache.correctness">Cache Correctness</a></li>
                     <li class="tocline1">13.1.2&nbsp;&nbsp;&nbsp;<a href="#warnings">Warnings</a></li>
                     <li class="tocline1">13.1.3&nbsp;&nbsp;&nbsp;<a href="#cache-control.mechanisms">Cache-control Mechanisms</a></li>
                     <li class="tocline1">13.1.4&nbsp;&nbsp;&nbsp;<a href="#explicit.ua.warnings">Explicit User Agent Warnings</a></li>
                     <li class="tocline1">13.1.5&nbsp;&nbsp;&nbsp;<a href="#exceptions.to.the.rules.and.warnings">Exceptions to the Rules and Warnings</a></li>
                     <li class="tocline1">13.1.6&nbsp;&nbsp;&nbsp;<a href="#client-controlled.behavior">Client-controlled Behavior</a></li>
                  </ul>
               </li>
               <li class="tocline1">13.2&nbsp;&nbsp;&nbsp;<a href="#expiration.model">Expiration Model</a><ul class="toc">
                     <li class="tocline1">13.2.1&nbsp;&nbsp;&nbsp;<a href="#server-specified.expiration">Server-Specified Expiration</a></li>
                     <li class="tocline1">13.2.2&nbsp;&nbsp;&nbsp;<a href="#heuristic.expiration">Heuristic Expiration</a></li>
                     <li class="tocline1">13.2.3&nbsp;&nbsp;&nbsp;<a href="#age.calculations">Age Calculations</a></li>
                     <li class="tocline1">13.2.4&nbsp;&nbsp;&nbsp;<a href="#expiration.calculations">Expiration Calculations</a></li>
                     <li class="tocline1">13.2.5&nbsp;&nbsp;&nbsp;<a href="#disambiguating.expiration.values">Disambiguating Expiration Values</a></li>
                     <li class="tocline1">13.2.6&nbsp;&nbsp;&nbsp;<a href="#disambiguating.multiple.responses">Disambiguating Multiple Responses</a></li>
                  </ul>
               </li>
               <li class="tocline1">13.3&nbsp;&nbsp;&nbsp;<a href="#validation.model">Validation Model</a><ul class="toc">
                     <li class="tocline1">13.3.1&nbsp;&nbsp;&nbsp;<a href="#last-modified.dates">Last-Modified Dates</a></li>
                     <li class="tocline1">13.3.2&nbsp;&nbsp;&nbsp;<a href="#entity.tag.cache.validators">Entity Tag Cache Validators</a></li>
                     <li class="tocline1">13.3.3&nbsp;&nbsp;&nbsp;<a href="#weak.and.strong.validators">Weak and Strong Validators</a></li>
                     <li class="tocline1">13.3.4&nbsp;&nbsp;&nbsp;<a href="#rules.for.when.to.use.entity.tags.and.last-modified.dates">Rules for When to Use Entity Tags and Last-Modified Dates</a></li>
                     <li class="tocline1">13.3.5&nbsp;&nbsp;&nbsp;<a href="#non-validating.conditionals">Non-validating Conditionals</a></li>
                  </ul>
               </li>
               <li class="tocline1">13.4&nbsp;&nbsp;&nbsp;<a href="#response.cacheability">Response Cacheability</a></li>
               <li class="tocline1">13.5&nbsp;&nbsp;&nbsp;<a href="#constructing.responses.from.caches">Constructing Responses From Caches</a><ul class="toc">
                     <li class="tocline1">13.5.1&nbsp;&nbsp;&nbsp;<a href="#end-to-end.and.hop-by-hop.headers">End-to-end and Hop-by-hop Headers</a></li>
                     <li class="tocline1">13.5.2&nbsp;&nbsp;&nbsp;<a href="#non-modifiable.headers">Non-modifiable Headers</a></li>
                     <li class="tocline1">13.5.3&nbsp;&nbsp;&nbsp;<a href="#combining.headers">Combining Headers</a></li>
                     <li class="tocline1">13.5.4&nbsp;&nbsp;&nbsp;<a href="#combining.byte.ranges">Combining Byte Ranges</a></li>
                  </ul>
               </li>
               <li class="tocline1">13.6&nbsp;&nbsp;&nbsp;<a href="#caching.negotiated.responses">Caching Negotiated Responses</a></li>
               <li class="tocline1">13.7&nbsp;&nbsp;&nbsp;<a href="#shared.and.non-shared.caches">Shared and Non-Shared Caches</a></li>
               <li class="tocline1">13.8&nbsp;&nbsp;&nbsp;<a href="#errors.or.incomplete.response.cache.behavior">Errors or Incomplete Response Cache Behavior</a></li>
               <li class="tocline1">13.9&nbsp;&nbsp;&nbsp;<a href="#side.effects.of.get.and.head">Side Effects of GET and HEAD</a></li>
               <li class="tocline1">13.10&nbsp;&nbsp;&nbsp;<a href="#invalidation.after.updates.or.deletions">Invalidation After Updates or Deletions</a></li>
               <li class="tocline1">13.11&nbsp;&nbsp;&nbsp;<a href="#write-through.mandatory">Write-Through Mandatory</a></li>
               <li class="tocline1">13.12&nbsp;&nbsp;&nbsp;<a href="#cache.replacement">Cache Replacement</a></li>
               <li class="tocline1">13.13&nbsp;&nbsp;&nbsp;<a href="#history.lists">History Lists</a></li>
            </ul>
         </li>
         <li class="tocline0">14.&nbsp;&nbsp;&nbsp;<a href="#header.fields">Header Field Definitions</a><ul class="toc">
               <li class="tocline1">14.1&nbsp;&nbsp;&nbsp;<a href="#header.accept">Accept</a></li>
               <li class="tocline1">14.2&nbsp;&nbsp;&nbsp;<a href="#header.accept-charset">Accept-Charset</a></li>
               <li class="tocline1">14.3&nbsp;&nbsp;&nbsp;<a href="#header.accept-encoding">Accept-Encoding</a></li>
               <li class="tocline1">14.4&nbsp;&nbsp;&nbsp;<a href="#header.accept-language">Accept-Language</a></li>
               <li class="tocline1">14.5&nbsp;&nbsp;&nbsp;<a href="#header.accept-ranges">Accept-Ranges</a></li>
               <li class="tocline1">14.6&nbsp;&nbsp;&nbsp;<a href="#header.age">Age</a></li>
               <li class="tocline1">14.7&nbsp;&nbsp;&nbsp;<a href="#header.allow">Allow</a></li>
               <li class="tocline1">14.8&nbsp;&nbsp;&nbsp;<a href="#header.authorization">Authorization</a></li>
               <li class="tocline1">14.9&nbsp;&nbsp;&nbsp;<a href="#header.cache-control">Cache-Control</a><ul class="toc">
                     <li class="tocline1">14.9.1&nbsp;&nbsp;&nbsp;<a href="#what.is.cacheable">What is Cacheable</a></li>
                     <li class="tocline1">14.9.2&nbsp;&nbsp;&nbsp;<a href="#what.may.be.stored.by.caches">What May be Stored by Caches</a></li>
                     <li class="tocline1">14.9.3&nbsp;&nbsp;&nbsp;<a href="#modifications.of.the.basic.expiration.mechanism">Modifications of the Basic Expiration Mechanism</a></li>
                     <li class="tocline1">14.9.4&nbsp;&nbsp;&nbsp;<a href="#cache.revalidation.and.reload.controls">Cache Revalidation and Reload Controls</a></li>
                     <li class="tocline1">14.9.5&nbsp;&nbsp;&nbsp;<a href="#no-transform.directive">No-Transform Directive</a></li>
                     <li class="tocline1">14.9.6&nbsp;&nbsp;&nbsp;<a href="#cache.control.extensions">Cache Control Extensions</a></li>
                  </ul>
               </li>
               <li class="tocline1">14.10&nbsp;&nbsp;&nbsp;<a href="#header.connection">Connection</a></li>
               <li class="tocline1">14.11&nbsp;&nbsp;&nbsp;<a href="#header.content-encoding">Content-Encoding</a></li>
               <li class="tocline1">14.12&nbsp;&nbsp;&nbsp;<a href="#header.content-language">Content-Language</a></li>
               <li class="tocline1">14.13&nbsp;&nbsp;&nbsp;<a href="#header.content-length">Content-Length</a></li>
               <li class="tocline1">14.14&nbsp;&nbsp;&nbsp;<a href="#header.content-location">Content-Location</a></li>
               <li class="tocline1">14.15&nbsp;&nbsp;&nbsp;<a href="#header.content-md5">Content-MD5</a></li>
               <li class="tocline1">14.16&nbsp;&nbsp;&nbsp;<a href="#header.content-range">Content-Range</a></li>
               <li class="tocline1">14.17&nbsp;&nbsp;&nbsp;<a href="#header.content-type">Content-Type</a></li>
               <li class="tocline1">14.18&nbsp;&nbsp;&nbsp;<a href="#header.date">Date</a><ul class="toc">
                     <li class="tocline1">14.18.1&nbsp;&nbsp;&nbsp;<a href="#clockless.origin.server.operation">Clockless Origin Server Operation</a></li>
                  </ul>
               </li>
               <li class="tocline1">14.19&nbsp;&nbsp;&nbsp;<a href="#header.etag">ETag</a></li>
               <li class="tocline1">14.20&nbsp;&nbsp;&nbsp;<a href="#header.expect">Expect</a></li>
               <li class="tocline1">14.21&nbsp;&nbsp;&nbsp;<a href="#header.expires">Expires</a></li>
               <li class="tocline1">14.22&nbsp;&nbsp;&nbsp;<a href="#header.from">From</a></li>
               <li class="tocline1">14.23&nbsp;&nbsp;&nbsp;<a href="#header.host">Host</a></li>
               <li class="tocline1">14.24&nbsp;&nbsp;&nbsp;<a href="#header.if-match">If-Match</a></li>
               <li class="tocline1">14.25&nbsp;&nbsp;&nbsp;<a href="#header.if-modified-since">If-Modified-Since</a></li>
               <li class="tocline1">14.26&nbsp;&nbsp;&nbsp;<a href="#header.if-none-match">If-None-Match</a></li>
               <li class="tocline1">14.27&nbsp;&nbsp;&nbsp;<a href="#header.if-range">If-Range</a></li>
               <li class="tocline1">14.28&nbsp;&nbsp;&nbsp;<a href="#header.if-unmodified-since">If-Unmodified-Since</a></li>
               <li class="tocline1">14.29&nbsp;&nbsp;&nbsp;<a href="#header.last-modified">Last-Modified</a></li>
               <li class="tocline1">14.30&nbsp;&nbsp;&nbsp;<a href="#header.location">Location</a></li>
               <li class="tocline1">14.31&nbsp;&nbsp;&nbsp;<a href="#header.max-forwards">Max-Forwards</a></li>
               <li class="tocline1">14.32&nbsp;&nbsp;&nbsp;<a href="#header.pragma">Pragma</a></li>
               <li class="tocline1">14.33&nbsp;&nbsp;&nbsp;<a href="#header.proxy-authenticate">Proxy-Authenticate</a></li>
               <li class="tocline1">14.34&nbsp;&nbsp;&nbsp;<a href="#header.proxy-authorization">Proxy-Authorization</a></li>
               <li class="tocline1">14.35&nbsp;&nbsp;&nbsp;<a href="#header.range">Range</a><ul class="toc">
                     <li class="tocline1">14.35.1&nbsp;&nbsp;&nbsp;<a href="#byte.ranges">Byte Ranges</a></li>
                     <li class="tocline1">14.35.2&nbsp;&nbsp;&nbsp;<a href="#range.retrieval.requests">Range Retrieval Requests</a></li>
                  </ul>
               </li>
               <li class="tocline1">14.36&nbsp;&nbsp;&nbsp;<a href="#header.referer">Referer</a></li>
               <li class="tocline1">14.37&nbsp;&nbsp;&nbsp;<a href="#header.retry-after">Retry-After</a></li>
               <li class="tocline1">14.38&nbsp;&nbsp;&nbsp;<a href="#header.server">Server</a></li>
               <li class="tocline1">14.39&nbsp;&nbsp;&nbsp;<a href="#header.te">TE</a></li>
               <li class="tocline1">14.40&nbsp;&nbsp;&nbsp;<a href="#header.trailer">Trailer</a></li>
               <li class="tocline1">14.41&nbsp;&nbsp;&nbsp;<a href="#header.transfer-encoding">Transfer-Encoding</a></li>
               <li class="tocline1">14.42&nbsp;&nbsp;&nbsp;<a href="#header.upgrade">Upgrade</a></li>
               <li class="tocline1">14.43&nbsp;&nbsp;&nbsp;<a href="#header.user-agent">User-Agent</a></li>
               <li class="tocline1">14.44&nbsp;&nbsp;&nbsp;<a href="#header.vary">Vary</a></li>
               <li class="tocline1">14.45&nbsp;&nbsp;&nbsp;<a href="#header.via">Via</a></li>
               <li class="tocline1">14.46&nbsp;&nbsp;&nbsp;<a href="#header.warning">Warning</a></li>
               <li class="tocline1">14.47&nbsp;&nbsp;&nbsp;<a href="#header.www-authenticate">WWW-Authenticate</a></li>
            </ul>
         </li>
         <li class="tocline0">15.&nbsp;&nbsp;&nbsp;<a href="#security.considerations">Security Considerations</a><ul class="toc">
               <li class="tocline1">15.1&nbsp;&nbsp;&nbsp;<a href="#personal.information">Personal Information</a><ul class="toc">
                     <li class="tocline1">15.1.1&nbsp;&nbsp;&nbsp;<a href="#abuse.of.server.log.information">Abuse of Server Log Information</a></li>
                     <li class="tocline1">15.1.2&nbsp;&nbsp;&nbsp;<a href="#security.sensitive">Transfer of Sensitive Information</a></li>
                     <li class="tocline1">15.1.3&nbsp;&nbsp;&nbsp;<a href="#encoding.sensitive.information.in.uris">Encoding Sensitive Information in URI's</a></li>
                     <li class="tocline1">15.1.4&nbsp;&nbsp;&nbsp;<a href="#privacy.issues.connected.to.accept.headers">Privacy Issues Connected to Accept Headers</a></li>
                  </ul>
               </li>
               <li class="tocline1">15.2&nbsp;&nbsp;&nbsp;<a href="#attack.pathname">Attacks Based On File and Path Names</a></li>
               <li class="tocline1">15.3&nbsp;&nbsp;&nbsp;<a href="#dns.spoofing">DNS Spoofing</a></li>
               <li class="tocline1">15.4&nbsp;&nbsp;&nbsp;<a href="#location.spoofing">Location Headers and Spoofing</a></li>
               <li class="tocline1">15.5&nbsp;&nbsp;&nbsp;<a href="#content-disposition.issues">Content-Disposition Issues</a></li>
               <li class="tocline1">15.6&nbsp;&nbsp;&nbsp;<a href="#auth.credentials.and.idle.clients">Authentication Credentials and Idle Clients</a></li>
               <li class="tocline1">15.7&nbsp;&nbsp;&nbsp;<a href="#attack.proxies">Proxies and Caching</a><ul class="toc">
                     <li class="tocline1">15.7.1&nbsp;&nbsp;&nbsp;<a href="#attack.DoS">Denial of Service Attacks on Proxies</a></li>
                  </ul>
               </li>
            </ul>
         </li>
         <li class="tocline0">16.&nbsp;&nbsp;&nbsp;<a href="#ack">Acknowledgments</a></li>
         <li class="tocline0">17.&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a></li>
         <li class="tocline0">18.&nbsp;&nbsp;&nbsp;<a href="#rfc.authors">Authors' Addresses</a></li>
         <li class="tocline0">19.&nbsp;&nbsp;&nbsp;<a href="#rfc.section.19">Appendices</a><ul class="toc">
               <li class="tocline1">19.1&nbsp;&nbsp;&nbsp;<a href="#internet.media.type.http">Internet Media Type message/http and application/http</a></li>
               <li class="tocline1">19.2&nbsp;&nbsp;&nbsp;<a href="#internet.media.type.multipart.byteranges">Internet Media Type multipart/byteranges</a></li>
               <li class="tocline1">19.3&nbsp;&nbsp;&nbsp;<a href="#tolerant.applications">Tolerant Applications</a></li>
               <li class="tocline1">19.4&nbsp;&nbsp;&nbsp;<a href="#differences.between.http.entities.and.rfc.2045.entities">Differences Between HTTP Entities and RFC 2045 Entities</a><ul class="toc">
                     <li class="tocline1">19.4.1&nbsp;&nbsp;&nbsp;<a href="#mime-version">MIME-Version</a></li>
                     <li class="tocline1">19.4.2&nbsp;&nbsp;&nbsp;<a href="#conversion.to.canonical.form">Conversion to Canonical Form</a></li>
                     <li class="tocline1">19.4.3&nbsp;&nbsp;&nbsp;<a href="#conversion.of.date.formats">Conversion of Date Formats</a></li>
                     <li class="tocline1">19.4.4&nbsp;&nbsp;&nbsp;<a href="#introduction.of.content-encoding">Introduction of Content-Encoding</a></li>
                     <li class="tocline1">19.4.5&nbsp;&nbsp;&nbsp;<a href="#no.content-transfer-encoding">No Content-Transfer-Encoding</a></li>
                     <li class="tocline1">19.4.6&nbsp;&nbsp;&nbsp;<a href="#introduction.of.transfer-encoding">Introduction of Transfer-Encoding</a></li>
                     <li class="tocline1">19.4.7&nbsp;&nbsp;&nbsp;<a href="#mhtml.line.length">MHTML and Line Length Limitations</a></li>
                  </ul>
               </li>
               <li class="tocline1">19.5&nbsp;&nbsp;&nbsp;<a href="#additional.features">Additional Features</a><ul class="toc">
                     <li class="tocline1">19.5.1&nbsp;&nbsp;&nbsp;<a href="#content-disposition">Content-Disposition</a></li>
                  </ul>
               </li>
               <li class="tocline1">19.6&nbsp;&nbsp;&nbsp;<a href="#compatibility">Compatibility with Previous Versions</a><ul class="toc">
                     <li class="tocline1">19.6.1&nbsp;&nbsp;&nbsp;<a href="#changes.from.1.0">Changes from HTTP/1.0</a><ul class="toc">
                           <li class="tocline1">19.6.1.1&nbsp;&nbsp;&nbsp;<a href="#changes.to.simplify.multi-homed.web.servers.and.conserve.ip.addresses">Changes to Simplify Multi-homed Web Servers and Conserve IP Addresses</a></li>
                        </ul>
                     </li>
                     <li class="tocline1">19.6.2&nbsp;&nbsp;&nbsp;<a href="#compatibility.with.http.1.0.persistent.connections">Compatibility with HTTP/1.0 Persistent Connections</a></li>
                     <li class="tocline1">19.6.3&nbsp;&nbsp;&nbsp;<a href="#changes.from.rfc.2068">Changes from RFC 2068</a></li>
                  </ul>
               </li>
            </ul>
         </li>
         <li class="tocline0">20.&nbsp;&nbsp;&nbsp;<a href="#rfc.section.20">Index</a></li>
         <li class="tocline0"><a href="#rfc.ipr">Intellectual Property and Copyright Statements</a></li>
         <li class="tocline0"><a href="#rfc.index">Index</a></li>
      </ul>
      <h1 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a id="introduction" href="#introduction">Introduction</a></h1>
      <h2 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1</a>&nbsp;<a id="intro.purpose" href="#intro.purpose">Purpose</a></h2>
      <p id="rfc.section.1.1.p.1">The Hypertext Transfer Protocol (HTTP) is an application-level protocol for distributed, collaborative, hypermedia information
         systems. HTTP has been in use by the World-Wide Web global information initiative since 1990. The first version of HTTP, referred
         to as HTTP/0.9, was a simple protocol for raw data transfer across the Internet. HTTP/1.0, as defined by RFC 1945 <a href="#RFC1945" id="rfc.xref.RFC1945.1"><cite title="Hypertext Transfer Protocol -- HTTP/1.0">[RFC1945]</cite></a>, improved the protocol by allowing messages to be in the format of MIME-like messages, containing metainformation about the
         data transferred and modifiers on the request/response semantics. However, HTTP/1.0 does not sufficiently take into consideration
         the effects of hierarchical proxies, caching, the need for persistent connections, or virtual hosts. In addition, the proliferation
         of incompletely-implemented applications calling themselves "HTTP/1.0" has necessitated a protocol version change in order
         for two communicating applications to determine each other's true capabilities.
      </p>
      <p id="rfc.section.1.1.p.2">This specification defines the protocol referred to as "HTTP/1.1". This protocol includes more stringent requirements than
         HTTP/1.0 in order to ensure reliable implementation of its features.
      </p>
      <p id="rfc.section.1.1.p.3">Practical information systems require more functionality than simple retrieval, including search, front-end update, and annotation.
         HTTP allows an open-ended set of methods and headers that indicate the purpose of a request <a href="#RFC2324" id="rfc.xref.RFC2324.2"><cite title="Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)">[RFC2324]</cite></a>. It builds on the discipline of reference provided by the Uniform Resource Identifier (URI) <a href="#RFC1630" id="rfc.xref.RFC1630.1"><cite title="Universal Resource Identifiers in WWW: A Unifying Syntax for the Expression of Names and Addresses of Objects on the Network as used in the World-Wide Web">[RFC1630]</cite></a>, as a location (URL) <a href="#RFC1738" id="rfc.xref.RFC1738.1"><cite title="Uniform Resource Locators (URL)">[RFC1738]</cite></a> or name (URN) <a href="#RFC1737" id="rfc.xref.RFC1737.1"><cite title="Functional Requirements for Uniform Resource Names">[RFC1737]</cite></a>, for indicating the resource to which a method is to be applied. Messages are passed in a format similar to that used by
         Internet mail <a href="#RFC822" id="rfc.xref.RFC822.1"><cite title="Standard for the format of ARPA Internet text messages">[RFC822]</cite></a> as defined by the Multipurpose Internet Mail Extensions (MIME) <a href="#RFC2045" id="rfc.xref.RFC2045.1"><cite title="Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies">[RFC2045]</cite></a>.
      </p>
      <p id="rfc.section.1.1.p.4">HTTP is also used as a generic protocol for communication between user agents and proxies/gateways to other Internet systems,
         including those supported by the SMTP <a href="#RFC821" id="rfc.xref.RFC821.1"><cite title="Simple Mail Transfer Protocol">[RFC821]</cite></a>, NNTP <a href="#RFC977" id="rfc.xref.RFC977.1"><cite title="Network News Transfer Protocol">[RFC977]</cite></a>, FTP <a href="#RFC959" id="rfc.xref.RFC959.1"><cite title="File Transfer Protocol">[RFC959]</cite></a>, Gopher <a href="#RFC1436" id="rfc.xref.RFC1436.1"><cite title="The Internet Gopher Protocol (a distributed document search and retrieval protocol)">[RFC1436]</cite></a>, and WAIS <a href="#WAIS" id="rfc.xref.WAIS.1"><cite title="WAIS Interface Protocol Prototype Functional Specification (v1.5)">[WAIS]</cite></a> protocols. In this way, HTTP allows basic hypermedia access to resources available from diverse applications.
      </p>
      <h2 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2</a>&nbsp;<a id="intro.requirements" href="#intro.requirements">Requirements</a></h2>
      <p id="rfc.section.1.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"
         in this document are to be interpreted as described in RFC 2119 <a href="#RFC2119" id="rfc.xref.RFC2119.1"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.
      </p>
      <p id="rfc.section.1.2.p.2">An implementation is not compliant if it fails to satisfy one or more of the <em class="bcp14">MUST</em> or <em class="bcp14">REQUIRED</em> level requirements for the protocols it implements. An implementation that satisfies all the <em class="bcp14">MUST</em> or <em class="bcp14">REQUIRED</em> level and all the <em class="bcp14">SHOULD</em> level requirements for its protocols is said to be "unconditionally compliant"; one that satisfies all the <em class="bcp14">MUST</em> level requirements but not all the <em class="bcp14">SHOULD</em> level requirements for its protocols is said to be "conditionally compliant."
      </p>
      <h2 id="rfc.section.1.3"><a href="#rfc.section.1.3">1.3</a>&nbsp;<a id="intro.terminology" href="#intro.terminology">Terminology</a></h2>
      <p id="rfc.section.1.3.p.1">This specification uses a number of terms to refer to the roles played by participants in, and objects of, the HTTP communication.</p>
      <p id="rfc.section.1.3.p.2"> <span id="rfc.iref.c.1"></span>  <dfn>connection</dfn>  
      </p>
      <dl class="empty">
         <dd>A transport layer virtual circuit established between two programs for the purpose of communication.</dd>
      </dl>
      <p id="rfc.section.1.3.p.3"> <span id="rfc.iref.m.1"></span>  <dfn>message</dfn>  
      </p>
      <dl class="empty">
         <dd>The basic unit of HTTP communication, consisting of a structured sequence of octets matching the syntax defined in <a href="#http.message" title="HTTP Message">Section&nbsp;4</a> and transmitted via the connection.
         </dd>
      </dl>
      <p id="rfc.section.1.3.p.4"> <span id="rfc.iref.r.1"></span>  <dfn>request</dfn>  
      </p>
      <dl class="empty">
         <dd>An HTTP request message, as defined in <a href="#request" title="Request">Section&nbsp;5</a>.
         </dd>
      </dl>
      <p id="rfc.section.1.3.p.5"> <span id="rfc.iref.r.2"></span>  <dfn>response</dfn>  
      </p>
      <dl class="empty">
         <dd>An HTTP response message, as defined in <a href="#response" title="Response">Section&nbsp;6</a>.
         </dd>
      </dl>
      <p id="rfc.section.1.3.p.6"> <span id="rfc.iref.r.3"></span>  <dfn>resource</dfn>  
      </p>
      <dl class="empty">
         <dd>A network data object or service that can be identified by a URI, as defined in <a href="#uri" title="Uniform Resource Identifiers">Section&nbsp;3.2</a>. Resources may be available in multiple representations (e.g. multiple languages, data formats, size, and resolutions) or
            vary in other ways.
         </dd>
      </dl>
      <p id="rfc.section.1.3.p.7"> <span id="rfc.iref.e.1"></span>  <dfn>entity</dfn>  
      </p>
      <dl class="empty">
         <dd>The information transferred as the payload of a request or response. An entity consists of metainformation in the form of
            entity-header fields and content in the form of an entity-body, as described in <a href="#entity" title="Entity">Section&nbsp;7</a>.
         </dd>
      </dl>
      <p id="rfc.section.1.3.p.8"> <span id="rfc.iref.r.4"></span>  <dfn>representation</dfn>  
      </p>
      <dl class="empty">
         <dd>An entity included with a response that is subject to content negotiation, as described in <a href="#content.negotiation" title="Content Negotiation">Section&nbsp;12</a>. There may exist multiple representations associated with a particular response status.
         </dd>
      </dl>
      <p id="rfc.section.1.3.p.9"> <span id="rfc.iref.c.2"></span>  <dfn>content negotiation</dfn>  
      </p>
      <dl class="empty">
         <dd>The mechanism for selecting the appropriate representation when servicing a request, as described in <a href="#content.negotiation" title="Content Negotiation">Section&nbsp;12</a>. The representation of entities in any response can be negotiated (including error responses).
         </dd>
      </dl>
      <p id="rfc.section.1.3.p.10"> <span id="rfc.iref.v.1"></span>  <dfn>variant</dfn>  
      </p>
      <dl class="empty">
         <dd>A resource may have one, or more than one, representation(s) associated with it at any given instant. Each of these representations
            is termed a `varriant'. Use of the term `variant' does not necessarily imply that the resource is subject to content negotiation.
         </dd>
      </dl>
      <p id="rfc.section.1.3.p.11"> <span id="rfc.iref.c.3"></span>  <dfn>client</dfn>  
      </p>
      <dl class="empty">
         <dd>A program that establishes connections for the purpose of sending requests.</dd>
      </dl>
      <p id="rfc.section.1.3.p.12"> <span id="rfc.iref.u.1"></span>  <dfn>user agent</dfn>  
      </p>
      <dl class="empty">
         <dd>The client which initiates a request. These are often browsers, editors, spiders (web-traversing robots), or other end user
            tools.
         </dd>
      </dl>
      <p id="rfc.section.1.3.p.13"> <span id="rfc.iref.s.1"></span>  <dfn>server</dfn>  
      </p>
      <dl class="empty">
         <dd>An application program that accepts connections in order to service requests by sending back responses. Any given program
            may be capable of being both a client and a server; our use of these terms refers only to the role being performed by the
            program for a particular connection, rather than to the program's capabilities in general. Likewise, any server may act as
            an origin server, proxy, gateway, or tunnel, switching behavior based on the nature of each request.
         </dd>
      </dl>
      <p id="rfc.section.1.3.p.14"> <span id="rfc.iref.o.1"></span>  <dfn>origin server</dfn>  
      </p>
      <dl class="empty">
         <dd>The server on which a given resource resides or is to be created.</dd>
      </dl>
      <p id="rfc.section.1.3.p.15"> <span id="rfc.iref.p.1"></span>  <dfn>proxy</dfn>  
      </p>
      <dl class="empty">
         <dd>An intermediary program which acts as both a server and a client for the purpose of making requests on behalf of other clients.
            Requests are serviced internally or by passing them on, with possible translation, to other servers. A proxy <em class="bcp14">MUST</em> implement both the client and server requirements of this specification. A "transparent proxy" is a proxy that does not modify
            the request or response beyond what is required for proxy authentication and identification. A "non-transparent proxy" is
            a proxy that modifies the request or response in order to provide some added service to the user agent, such as group annotation
            services, media type transformation, protocol reduction, or anonymity filtering. Except where either transparent or non-transparent
            behavior is explicitly stated, the HTTP proxy requirements apply to both types of proxies.
         </dd>
      </dl>
      <p id="rfc.section.1.3.p.16"> <span id="rfc.iref.g.1"></span>  <dfn>gateway</dfn>  
      </p>
      <dl class="empty">
         <dd>A server which acts as an intermediary for some other server. Unlike a proxy, a gateway receives requests as if it were the
            origin server for the requested resource; the requesting client may not be aware that it is communicating with a gateway.
         </dd>
      </dl>
      <p id="rfc.section.1.3.p.17"> <span id="rfc.iref.t.1"></span>  <dfn>tunnel</dfn>  
      </p>
      <dl class="empty">
         <dd>An intermediary program which is acting as a blind relay between two connections. Once active, a tunnel is not considered
            a party to the HTTP communication, though the tunnel may have been initiated by an HTTP request. The tunnel ceases to exist
            when both ends of the relayed connections are closed.
         </dd>
      </dl>
      <p id="rfc.section.1.3.p.18"> <span id="rfc.iref.c.4"></span>  <dfn>cache</dfn>  
      </p>
      <dl class="empty">
         <dd>A program's local store of response messages and the subsystem that controls its message storage, retrieval, and deletion.
            A cache stores cacheable responses in order to reduce the response time and network bandwidth consumption on future, equivalent
            requests. Any client or server may include a cache, though a cache cannot be used by a server that is acting as a tunnel.
         </dd>
      </dl>
      <p id="rfc.section.1.3.p.19"> <span id="rfc.iref.c.5"></span>  <dfn>cacheable</dfn>  
      </p>
      <dl class="empty">
         <dd>A response is cacheable if a cache is allowed to store a copy of the response message for use in answering subsequent requests.
            The rules for determining the cacheability of HTTP responses are defined in <a href="#caching" title="Caching in HTTP">Section&nbsp;13</a>. Even if a resource is cacheable, there may be additional constraints on whether a cache can use the cached copy for a particular
            request.
         </dd>
      </dl>
      <p id="rfc.section.1.3.p.20"> <span id="rfc.iref.f.1"></span>  <dfn>first-hand</dfn>  
      </p>
      <dl class="empty">
         <dd>A response is first-hand if it comes directly and without unnecessary delay from the origin server, perhaps via one or more
            proxies. A response is also first-hand if its validity has just been checked directly with the origin server.
         </dd>
      </dl>
      <p id="rfc.section.1.3.p.21"> <span id="rfc.iref.e.2"></span>  <dfn>explicit expiration time</dfn>  
      </p>
      <dl class="empty">
         <dd>The time at which the origin server intends that an entity should no longer be returned by a cache without further validation.</dd>
      </dl>
      <p id="rfc.section.1.3.p.22"> <span id="rfc.iref.h.1"></span>  <dfn>heuristic expiration time</dfn>  
      </p>
      <dl class="empty">
         <dd>An expiration time assigned by a cache when no explicit expiration time is available.</dd>
      </dl>
      <p id="rfc.section.1.3.p.23"> <span id="rfc.iref.a.1"></span>  <dfn>age</dfn>  
      </p>
      <dl class="empty">
         <dd>The age of a response is the time since it was sent by, or successfully validated with, the origin server.</dd>
      </dl>
      <p id="rfc.section.1.3.p.24"> <span id="rfc.iref.f.2"></span>  <dfn>freshness lifetime</dfn>  
      </p>
      <dl class="empty">
         <dd>The length of time between the generation of a response and its expiration time.</dd>
      </dl>
      <p id="rfc.section.1.3.p.25"> <span id="rfc.iref.f.3"></span>  <dfn>fresh</dfn>  
      </p>
      <dl class="empty">
         <dd>A response is fresh if its age has not yet exceeded its freshness lifetime.</dd>
      </dl>
      <p id="rfc.section.1.3.p.26"> <span id="rfc.iref.s.2"></span>  <dfn>stale</dfn>  
      </p>
      <dl class="empty">
         <dd>A response is stale if its age has passed its freshness lifetime.</dd>
      </dl>
      <p id="rfc.section.1.3.p.27"> <span id="rfc.iref.s.3"></span>  <dfn>semantically transparent</dfn>  
      </p>
      <dl class="empty">
         <dd>A cache behaves in a "semantically transparent" manner, with respect to a particular response, when its use affects neither
            the requesting client nor the origin server, except to improve performance. When a cache is semantically transparent, the
            client receives exactly the same response (except for hop-by-hop headers) that it would have received had its request been
            handled directly by the origin server.
         </dd>
      </dl>
      <p id="rfc.section.1.3.p.28"> <span id="rfc.iref.v.2"></span>  <dfn>validator</dfn>  
      </p>
      <dl class="empty">
         <dd>A protocol element (e.g., an entity tag or a Last-Modified time) that is used to find out whether a cache entry is an equivalent
            copy of an entity.
         </dd>
      </dl>
      <p id="rfc.section.1.3.p.29"> <span id="rfc.iref.u.2"></span>  <span id="rfc.iref.d.1"></span>  <dfn>upstream</dfn>/<dfn>downstream</dfn>  
      </p>
      <dl class="empty">
         <dd>Upstream and downstream describe the flow of a message: all messages flow from upstream to downstream.</dd>
      </dl>
      <p id="rfc.section.1.3.p.30"> <span id="rfc.iref.i.1"></span>  <span id="rfc.iref.o.2"></span>  <dfn>inbound</dfn>/<dfn>outbound</dfn>  
      </p>
      <dl class="empty">
         <dd>Inbound and outbound refer to the request and response paths for messages: "inbound" means "traveling toward the origin server",
            and "outbound" means "traveling toward the user agent"
         </dd>
      </dl>
      <h2 id="rfc.section.1.4"><a href="#rfc.section.1.4">1.4</a>&nbsp;<a id="intro.overall.operation" href="#intro.overall.operation">Overall Operation</a></h2>
      <p id="rfc.section.1.4.p.1">The HTTP protocol is a request/response protocol. A client sends a request to the server in the form of a request method,
         URI, and protocol version, followed by a MIME-like message containing request modifiers, client information, and possible
         body content over a connection with a server. The server responds with a status line, including the message's protocol version
         and a success or error code, followed by a MIME-like message containing server information, entity metainformation, and possible
         entity-body content. The relationship between HTTP and MIME is described in <a href="#differences.between.http.entities.and.rfc.2045.entities" title="Differences Between HTTP Entities and RFC 2045 Entities">Appendix&nbsp;19.4</a>.
      </p>
      <p id="rfc.section.1.4.p.2">Most HTTP communication is initiated by a user agent and consists of a request to be applied to a resource on some origin
         server. In the simplest case, this may be accomplished via a single connection (v) between the user agent (UA) and the origin
         server (O).
      </p>
      <div id="rfc.figure.u.1"></div><pre class="drawing">       request chain ------------------------&gt;
    UA -------------------v------------------- O
       &lt;----------------------- response chain
</pre><p id="rfc.section.1.4.p.4">A more complicated situation occurs when one or more intermediaries are present in the request/response chain. There are three
         common forms of intermediary: proxy, gateway, and tunnel. A proxy is a forwarding agent, receiving requests for a URI in its
         absolute form, rewriting all or part of the message, and forwarding the reformatted request toward the server identified by
         the URI. A gateway is a receiving agent, acting as a layer above some other server(s) and, if necessary, translating the requests
         to the underlying server's protocol. A tunnel acts as a relay point between two connections without changing the messages;
         tunnels are used when the communication needs to pass through an intermediary (such as a firewall) even when the intermediary
         cannot understand the contents of the messages.
      </p>
      <div id="rfc.figure.u.2"></div><pre class="drawing">       request chain --------------------------------------&gt;
    UA -----v----- A -----v----- B -----v----- C -----v----- O
       &lt;------------------------------------- response chain
</pre><p id="rfc.section.1.4.p.6">The figure above shows three intermediaries (A, B, and C) between the user agent and origin server. A request or response
         message that travels the whole chain will pass through four separate connections. This distinction is important because some
         HTTP communication options may apply only to the connection with the nearest, non-tunnel neighbor, only to the end-points
         of the chain, or to all connections along the chain. Although the diagram is linear, each participant may be engaged in multiple,
         simultaneous communications. For example, B may be receiving requests from many clients other than A, and/or forwarding requests
         to servers other than C, at the same time that it is handling A's request.
      </p>
      <p id="rfc.section.1.4.p.7">Any party to the communication which is not acting as a tunnel may employ an internal cache for handling requests. The effect
         of a cache is that the request/response chain is shortened if one of the participants along the chain has a cached response
         applicable to that request. The following illustrates the resulting chain if B has a cached copy of an earlier response from
         O (via C) for a request which has not been cached by UA or A.
      </p>
      <div id="rfc.figure.u.3"></div><pre class="drawing">          request chain ----------&gt;
       UA -----v----- A -----v----- B - - - - - - C - - - - - - O
          &lt;--------- response chain
</pre><p id="rfc.section.1.4.p.9">Not all responses are usefully cacheable, and some requests may contain modifiers which place special requirements on cache
         behavior. HTTP requirements for cache behavior and cacheable responses are defined in <a href="#caching" title="Caching in HTTP">Section&nbsp;13</a>.
      </p>
      <p id="rfc.section.1.4.p.10">In fact, there are a wide variety of architectures and configurations of caches and proxies currently being experimented with
         or deployed across the World Wide Web. These systems include national hierarchies of proxy caches to save transoceanic bandwidth,
         systems that broadcast or multicast cache entries, organizations that distribute subsets of cached data via CD-ROM, and so
         on. HTTP systems are used in corporate intranets over high-bandwidth links, and for access via PDAs with low-power radio links
         and intermittent connectivity. The goal of HTTP/1.1 is to support the wide diversity of configurations already deployed while
         introducing protocol constructs that meet the needs of those who build web applications that require high reliability and,
         failing that, at least reliable indications of failure.
      </p>
      <p id="rfc.section.1.4.p.11">HTTP communication usually takes place over TCP/IP connections. The default port is TCP 80 <a href="#RFC1700" id="rfc.xref.RFC1700.1"><cite title="Assigned Numbers">[RFC1700]</cite></a>, but other ports can be used. This does not preclude HTTP from being implemented on top of any other protocol on the Internet,
         or on other networks. HTTP only presumes a reliable transport; any protocol that provides such guarantees can be used; the
         mapping of the HTTP/1.1 request and response structures onto the transport data units of the protocol in question is outside
         the scope of this specification.
      </p>
      <p id="rfc.section.1.4.p.12">In HTTP/1.0, most implementations used a new connection for each request/response exchange. In HTTP/1.1, a connection may
         be used for one or more request/response exchanges, although connections may be closed for a variety of reasons (see <a href="#persistent.connections" title="Persistent Connections">Section&nbsp;8.1</a>).
      </p>
      <h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;<a id="notation" href="#notation">Notational Conventions and Generic Grammar</a></h1>
      <h2 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1</a>&nbsp;<a id="notation.abnf" href="#notation.abnf">Augmented BNF</a></h2>
      <p id="rfc.section.2.1.p.1">All of the mechanisms specified in this document are described in both prose and an augmented Backus-Naur Form (BNF) similar
         to that used by RFC 822 <a href="#RFC822" id="rfc.xref.RFC822.2"><cite title="Standard for the format of ARPA Internet text messages">[RFC822]</cite></a>. Implementors will need to be familiar with the notation in order to understand this specification. The augmented BNF includes
         the following constructs:
      </p>
      <p id="rfc.section.2.1.p.2">name = definition </p>
      <dl class="empty">
         <dd>The name of a rule is simply the name itself (without any enclosing "&lt;" and "&gt;") and is separated from its definition by the
            equal "=" character. White space is only significant in that indentation of continuation lines is used to indicate a rule
            definition that spans more than one line. Certain basic rules are in uppercase, such as SP, LWS, HT, CRLF, DIGIT, ALPHA, etc.
            Angle brackets are used within definitions whenever their presence will facilitate discerning the use of rule names.
         </dd>
      </dl>
      <p id="rfc.section.2.1.p.3">"literal" </p>
      <dl class="empty">
         <dd>Quotation marks surround literal text. Unless stated otherwise, the text is case-insensitive.</dd>
      </dl>
      <p id="rfc.section.2.1.p.4">rule1 | rule2 </p>
      <dl class="empty">
         <dd>Elements separated by a bar ("|") are alternatives, e.g., "yes | no" will accept yes or no.</dd>
      </dl>
      <p id="rfc.section.2.1.p.5">(rule1 rule2) </p>
      <dl class="empty">
         <dd>Elements enclosed in parentheses are treated as a single element. Thus, "(elem (foo | bar) elem)" allows the token sequences
            "elem foo elem" and "elem bar elem".
         </dd>
      </dl>
      <p id="rfc.section.2.1.p.6">*rule </p>
      <dl class="empty">
         <dd>The character "*" preceding an element indicates repetition. The full form is "&lt;n&gt;*&lt;m&gt;element" indicating at least &lt;n&gt; and
            at most &lt;m&gt; occurrences of element. Default values are 0 and infinity so that "*(element)" allows any number, including zero;
            "1*element" requires at least one; and "1*2element" allows one or two.
         </dd>
      </dl>
      <p id="rfc.section.2.1.p.7">[rule] </p>
      <dl class="empty">
         <dd>Square brackets enclose optional elements; "[foo bar]" is equivalent to "*1(foo bar)".</dd>
      </dl>
      <p id="rfc.section.2.1.p.8">N rule </p>
      <dl class="empty">
         <dd>Specific repetition: "&lt;n&gt;(element)" is equivalent to "&lt;n&gt;*&lt;n&gt;(element)"; that is, exactly &lt;n&gt; occurrences of (element). Thus
            2DIGIT is a 2-digit number, and 3ALPHA is a string of three alphabetic characters.
         </dd>
      </dl>
      <p id="rfc.section.2.1.p.9">#rule </p>
      <dl class="empty">
         <dd>A construct "#" is defined, similar to "*", for defining lists of elements. The full form is "&lt;n&gt;#&lt;m&gt;element" indicating at
            least &lt;n&gt; and at most &lt;m&gt; elements, each separated by one or more commas (",") and <em class="bcp14">OPTIONAL</em> linear white space (LWS). This makes the usual form of lists very easy; a rule such as
         </dd>
         <dd>( *LWS element *( *LWS "," *LWS element ))</dd>
         <dd>can be shown as</dd>
         <dd>1#element</dd>
         <dd>Wherever this construct is used, null elements are allowed, but do not contribute to the count of elements present. That is,
            "(element), , (element) " is permitted, but counts as only two elements. Therefore, where at least one element is required,
            at least one non-null element <em class="bcp14">MUST</em> be present. Default values are 0 and infinity so that "#element" allows any number, including zero; "1#element" requires at
            least one; and "1#2element" allows one or two.
         </dd>
      </dl>
      <p id="rfc.section.2.1.p.10">; comment </p>
      <dl class="empty">
         <dd>A semi-colon, set off some distance to the right of rule text, starts a comment that continues to the end of line. This is
            a simple way of including useful notes in parallel with the specifications.
         </dd>
      </dl>
      <p id="rfc.section.2.1.p.11">implied *LWS </p>
      <dl class="empty">
         <dd>The grammar described by this specification is word-based. Except where noted otherwise, linear white space (LWS) can be included
            between any two adjacent words (token or quoted-string), and between adjacent words and separators, without changing the interpretation
            of a field. At least one delimiter (LWS and/or separators) <em class="bcp14">MUST</em> exist between any two tokens (for the definition of "token" below), since they would otherwise be interpreted as a single
            token.
         </dd>
      </dl>
      <h2 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2</a>&nbsp;<a id="basic.rules" href="#basic.rules">Basic Rules</a></h2>
      <p id="rfc.section.2.2.p.1">The following rules are used throughout this specification to describe basic parsing constructs. The US-ASCII coded character
         set is defined by ANSI X3.4-1986 <a href="#USASCII" id="rfc.xref.USASCII.1"><cite title="Coded Character Set -- 7-bit American Standard Code for Information Interchange">[USASCII]</cite></a>.
      </p>
      <div id="rfc.figure.u.4"></div><pre class="inline"><span id="rfc.iref.g.2"></span><span id="rfc.iref.g.3"></span><span id="rfc.iref.g.4"></span><span id="rfc.iref.g.5"></span><span id="rfc.iref.g.6"></span><span id="rfc.iref.g.7"></span><span id="rfc.iref.g.8"></span><span id="rfc.iref.g.9"></span><span id="rfc.iref.g.10"></span><span id="rfc.iref.g.11"></span><span id="rfc.iref.g.12"></span>    OCTET          = &lt;any 8-bit sequence of data&gt;
    CHAR           = &lt;any US-ASCII character (octets 0 - 127)&gt;
    UPALPHA        = &lt;any US-ASCII uppercase letter "A".."Z"&gt;
    LOALPHA        = &lt;any US-ASCII lowercase letter "a".."z"&gt;
    ALPHA          = UPALPHA | LOALPHA
    DIGIT          = &lt;any US-ASCII digit "0".."9"&gt;
    CTL            = &lt;any US-ASCII control character
                     (octets 0 - 31) and DEL (127)&gt;
    CR             = &lt;US-ASCII CR, carriage return (13)&gt;
    LF             = &lt;US-ASCII LF, linefeed (10)&gt;
    SP             = &lt;US-ASCII SP, space (32)&gt;
    HT             = &lt;US-ASCII HT, horizontal-tab (9)&gt;
    &lt;"&gt;            = &lt;US-ASCII double-quote mark (34)&gt;
</pre><p id="rfc.section.2.2.p.3">HTTP/1.1 defines the sequence CR LF as the end-of-line marker for all protocol elements except the entity-body (see <a href="#tolerant.applications" title="Tolerant Applications">Appendix&nbsp;19.3</a> for tolerant applications). The end-of-line marker within an entity-body is defined by its associated media type, as described
         in <a href="#media.types" title="Media Types">Section&nbsp;3.7</a>.
      </p>
      <div id="rfc.figure.u.5"></div><pre class="inline"><span id="rfc.iref.g.13"></span>    CRLF           = CR LF
</pre><p id="rfc.section.2.2.p.5">HTTP/1.1 header field values can be folded onto multiple lines if the continuation line begins with a space or horizontal
         tab. All linear white space, including folding, has the same semantics as SP. A recipient <em class="bcp14">MAY</em> replace any linear white space with a single SP before interpreting the field value or forwarding the message downstream.
      </p>
      <div id="rfc.figure.u.6"></div><pre class="inline"><span id="rfc.iref.g.14"></span>    LWS            = [CRLF] 1*( SP | HT )
</pre><p id="rfc.section.2.2.p.7">The TEXT rule is only used for descriptive field contents and values that are not intended to be interpreted by the message
         parser. Words of *TEXT <em class="bcp14">MAY</em> contain characters from character sets other than ISO-8859-1 <a href="#ISO-8859" id="rfc.xref.ISO-8859.1"><cite title="Information technology - 8-bit single byte coded graphic - character sets">[ISO-8859]</cite></a> only when encoded according to the rules of RFC 2047 <a href="#RFC2047" id="rfc.xref.RFC2047.1"><cite title="MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Text">[RFC2047]</cite></a>.
      </p>
      <div id="rfc.figure.u.7"></div><pre class="inline"><span id="rfc.iref.g.15"></span>    TEXT           = &lt;any OCTET except CTLs,
                     but including LWS&gt;
</pre><p id="rfc.section.2.2.p.9">A CRLF is allowed in the definition of TEXT only as part of a header field continuation. It is expected that the folding LWS
         will be replaced with a single SP before interpretation of the TEXT value.
      </p>
      <p id="rfc.section.2.2.p.10">Hexadecimal numeric characters are used in several protocol elements.</p>
      <div id="rfc.figure.u.8"></div><pre class="inline"><span id="rfc.iref.g.16"></span>    HEX            = "A" | "B" | "C" | "D" | "E" | "F"
                   | "a" | "b" | "c" | "d" | "e" | "f" | DIGIT
</pre><p id="rfc.section.2.2.p.12">Many HTTP/1.1 header field values consist of words separated by LWS or special characters. These special characters <em class="bcp14">MUST</em> be in a quoted string to be used within a parameter value (as defined in <a href="#transfer.codings" title="Transfer Codings">Section&nbsp;3.6</a>).
      </p>
      <div id="rfc.figure.u.9"></div><pre class="inline"><span id="rfc.iref.g.17"></span><span id="rfc.iref.g.18"></span>    token          = 1*&lt;any CHAR except CTLs or separators&gt;
    separators     = "(" | ")" | "&lt;" | "&gt;" | "@"
                   | "," | ";" | ":" | "\" | &lt;"&gt;
                   | "/" | "[" | "]" | "?" | "="
                   | "{" | "}" | SP | HT
</pre><p id="rfc.section.2.2.p.14">Comments can be included in some HTTP header fields by surrounding the comment text with parentheses. Comments are only allowed
         in fields containing "comment" as part of their field value definition. In all other fields, parentheses are considered part
         of the field value.
      </p>
      <div id="rfc.figure.u.10"></div><pre class="inline"><span id="rfc.iref.g.19"></span><span id="rfc.iref.g.20"></span>    comment        = "(" *( ctext | quoted-pair | comment ) ")"
    ctext          = &lt;any TEXT excluding "(" and ")"&gt;
</pre><p id="rfc.section.2.2.p.16">A string of text is parsed as a single word if it is quoted using double-quote marks.</p>
      <div id="rfc.figure.u.11"></div><pre class="inline"><span id="rfc.iref.g.21"></span><span id="rfc.iref.g.22"></span>    quoted-string  = ( &lt;"&gt; *(qdtext | quoted-pair ) &lt;"&gt; )
    qdtext         = &lt;any TEXT except &lt;"&gt;&gt;
</pre><p id="rfc.section.2.2.p.18">The backslash character ("\") <em class="bcp14">MAY</em> be used as a single-character quoting mechanism only within quoted-string and comment constructs.
      </p>
      <div id="rfc.figure.u.12"></div><pre class="inline"><span id="rfc.iref.g.23"></span>    quoted-pair    = "\" CHAR
</pre><h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;<a id="protocol.parameters" href="#protocol.parameters">Protocol Parameters</a></h1>
      <h2 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1</a>&nbsp;<a id="http.version" href="#http.version">HTTP Version</a></h2>
      <p id="rfc.section.3.1.p.1">HTTP uses a "&lt;major&gt;.&lt;minor&gt;" numbering scheme to indicate versions of the protocol. The protocol versioning policy is intended
         to allow the sender to indicate the format of a message and its capacity for understanding further HTTP communication, rather
         than the features obtained via that communication. No change is made to the version number for the addition of message components
         which do not affect communication behavior or which only add to extensible field values. The &lt;minor&gt; number is incremented
         when the changes made to the protocol add features which do not change the general message parsing algorithm, but which may
         add to the message semantics and imply additional capabilities of the sender. The &lt;major&gt; number is incremented when the format
         of a message within the protocol is changed. See RFC 2145 <a href="#RFC2145" id="rfc.xref.RFC2145.1"><cite title="Use and Interpretation of HTTP Version Numbers">[RFC2145]</cite></a> for a fuller explanation.
      </p>
      <p id="rfc.section.3.1.p.2">The version of an HTTP message is indicated by an HTTP-Version field in the first line of the message.</p>
      <div id="rfc.figure.u.13"></div><pre class="inline"><span id="rfc.iref.g.24"></span>       HTTP-Version   = "HTTP" "/" 1*DIGIT "." 1*DIGIT
</pre><p id="rfc.section.3.1.p.4">Note that the major and minor numbers <em class="bcp14">MUST</em> be treated as separate integers and that each <em class="bcp14">MAY</em> be incremented higher than a single digit. Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in turn is lower than HTTP/12.3.
         Leading zeros <em class="bcp14">MUST</em> be ignored by recipients and <em class="bcp14">MUST NOT</em> be sent.
      </p>
      <p id="rfc.section.3.1.p.5">An application that sends a request or response message that includes HTTP-Version of "HTTP/1.1" <em class="bcp14">MUST</em> be at least conditionally compliant with this specification. Applications that are at least conditionally compliant with this
         specification <em class="bcp14">SHOULD</em> use an HTTP-Version of "HTTP/1.1" in their messages, and <em class="bcp14">MUST</em> do so for any message that is not compatible with HTTP/1.0. For more details on when to send specific HTTP-Version values,
         see RFC 2145 <a href="#RFC2145" id="rfc.xref.RFC2145.2"><cite title="Use and Interpretation of HTTP Version Numbers">[RFC2145]</cite></a>.
      </p>
      <p id="rfc.section.3.1.p.6">The HTTP version of an application is the highest HTTP version for which the application is at least conditionally compliant.</p>
      <p id="rfc.section.3.1.p.7">Proxy and gateway applications need to be careful when forwarding messages in protocol versions different from that of the
         application. Since the protocol version indicates the protocol capability of the sender, a proxy/gateway <em class="bcp14">MUST NOT</em> send a message with a version indicator which is greater than its actual version. If a higher version request is received,
         the proxy/gateway <em class="bcp14">MUST</em> either downgrade the request version, or respond with an error, or switch to tunnel behavior.
      </p>
      <p id="rfc.section.3.1.p.8">Due to interoperability problems with HTTP/1.0 proxies discovered since the publication of RFC 2068 <a href="#RFC2068" id="rfc.xref.RFC2068.2"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[RFC2068]</cite></a>, caching proxies MUST, gateways <em class="bcp14">MAY</em>, and tunnels <em class="bcp14">MUST NOT</em> upgrade the request to the highest version they support. The proxy/gateway's response to that request <em class="bcp14">MUST</em> be in the same major version as the request.
      </p>
      <p id="rfc.section.3.1.p.9"> </p>
      <dl class="empty">
         <dd> <b>Note:</b> Converting between versions of HTTP may involve modification of header fields required or forbidden by the versions involved.
         </dd>
      </dl>
      <h2 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2</a>&nbsp;<a id="uri" href="#uri">Uniform Resource Identifiers</a></h2>
      <p id="rfc.section.3.2.p.1">URIs have been known by many names: WWW addresses, Universal Document Identifiers, Universal Resource Identifiers <a href="#RFC1630" id="rfc.xref.RFC1630.2"><cite title="Universal Resource Identifiers in WWW: A Unifying Syntax for the Expression of Names and Addresses of Objects on the Network as used in the World-Wide Web">[RFC1630]</cite></a>, and finally the combination of Uniform Resource Locators (URL) <a href="#RFC1738" id="rfc.xref.RFC1738.2"><cite title="Uniform Resource Locators (URL)">[RFC1738]</cite></a> and Names (URN) <a href="#RFC1737" id="rfc.xref.RFC1737.2"><cite title="Functional Requirements for Uniform Resource Names">[RFC1737]</cite></a>. As far as HTTP is concerned, Uniform Resource Identifiers are simply formatted strings which identify--via name, location,
         or any other characteristic--a resource.
      </p>
      <h3 id="rfc.section.3.2.1"><a href="#rfc.section.3.2.1">3.2.1</a>&nbsp;<a id="general.syntax" href="#general.syntax">General Syntax</a></h3>
      <p id="rfc.section.3.2.1.p.1">URIs in HTTP can be represented in absolute form or relative to some known base URI <a href="#RFC1808" id="rfc.xref.RFC1808.1"><cite title="Relative Uniform Resource Locators">[RFC1808]</cite></a>, depending upon the context of their use. The two forms are differentiated by the fact that absolute URIs always begin with
         a scheme name followed by a colon. For definitive information on URL syntax and semantics, see "Uniform Resource Identifiers
         (URI): Generic Syntax and Semantics," RFC 2396 <a href="#RFC2396" id="rfc.xref.RFC2396.1"><cite title="Uniform Resource Identifiers (URI): Generic Syntax">[RFC2396]</cite></a> (which replaces RFCs 1738 <a href="#RFC1738" id="rfc.xref.RFC1738.3"><cite title="Uniform Resource Locators (URL)">[RFC1738]</cite></a> and RFC 1808 <a href="#RFC1808" id="rfc.xref.RFC1808.2"><cite title="Relative Uniform Resource Locators">[RFC1808]</cite></a>). This specification adopts the definitions of "URI-reference", "absoluteURI", "relativeURI", "port", "host","abs_path",
         "rel_path", and "authority" from that specification.
      </p>
      <p id="rfc.section.3.2.1.p.2">The HTTP protocol does not place any a priori limit on the length of a URI. Servers <em class="bcp14">MUST</em> be able to handle the URI of any resource they serve, and <em class="bcp14">SHOULD</em> be able to handle URIs of unbounded length if they provide GET-based forms that could generate such URIs. A server <em class="bcp14">SHOULD</em> return 414 (Request-URI Too Long) status if a URI is longer than the server can handle (see <a href="#status.414" id="rfc.xref.status.414.1" title="414 Request-URI Too Long">Section&nbsp;10.4.15</a>).
      </p>
      <p id="rfc.section.3.2.1.p.3"> </p>
      <dl class="empty">
         <dd> <b>Note:</b> Servers ought to be cautious about depending on URI lengths above 255 bytes, because some older client or proxy implementations
            might not properly support these lengths.
         </dd>
      </dl>
      <h3 id="rfc.section.3.2.2"><a href="#rfc.section.3.2.2">3.2.2</a>&nbsp;<a id="http.url" href="#http.url">http URL</a></h3>
      <p id="rfc.section.3.2.2.p.1">The "http" scheme is used to locate network resources via the HTTP protocol. This section defines the scheme-specific syntax
         and semantics for http URLs.
      </p>
      <div id="rfc.figure.u.14"></div><pre class="inline"><span id="rfc.iref.g.25"></span>http_URL = "http:" "//" host [ ":" port ] [ abs_path [ "?" query ]]
</pre><p id="rfc.section.3.2.2.p.3">If the port is empty or not given, port 80 is assumed. The semantics are that the identified resource is located at the server
         listening for TCP connections on that port of that host, and the Request-URI for the resource is abs_path (<a href="#request-uri" title="Request-URI">Section&nbsp;5.1.2</a>). The use of IP addresses in URLs <em class="bcp14">SHOULD</em> be avoided whenever possible (see RFC 1900 <a href="#RFC1900" id="rfc.xref.RFC1900.1"><cite title="Renumbering Needs Work">[RFC1900]</cite></a>). If the abs_path is not present in the URL, it <em class="bcp14">MUST</em> be given as "/" when used as a Request-URI for a resource (<a href="#request-uri" title="Request-URI">Section&nbsp;5.1.2</a>). If a proxy receives a host name which is not a fully qualified domain name, it <em class="bcp14">MAY</em> add its domain to the host name it received. If a proxy receives a fully qualified domain name, the proxy <em class="bcp14">MUST NOT</em> change the host name.
      </p>
      <h3 id="rfc.section.3.2.3"><a href="#rfc.section.3.2.3">3.2.3</a>&nbsp;<a id="uri.comparison" href="#uri.comparison">URI Comparison</a></h3>
      <p id="rfc.section.3.2.3.p.1">When comparing two URIs to decide if they match or not, a client <em class="bcp14">SHOULD</em> use a case-sensitive octet-by-octet comparison of the entire URIs, with these exceptions: 
      </p>
      <ul>
         <li>A port that is empty or not given is equivalent to the default port for that URI-reference;</li>
         <li>Comparisons of host names <em class="bcp14">MUST</em> be case-insensitive;
         </li>
         <li>Comparisons of scheme names <em class="bcp14">MUST</em> be case-insensitive;
         </li>
         <li>An empty abs_path is equivalent to an abs_path of "/".</li>
      </ul>
      <p id="rfc.section.3.2.3.p.2">Characters other than those in the "reserved" and "unsafe" sets (see RFC 2396 <a href="#RFC2396" id="rfc.xref.RFC2396.2"><cite title="Uniform Resource Identifiers (URI): Generic Syntax">[RFC2396]</cite></a>) are equivalent to their ""%" HEX HEX" encoding.
      </p>
      <p id="rfc.section.3.2.3.p.3">For example, the following three URIs are equivalent:</p>
      <div id="rfc.figure.u.15"></div><pre class="text">   http://abc.com:80/~smith/home.html
   http://ABC.com/%7Esmith/home.html
   http://ABC.com:/%7esmith/home.html
</pre><h2 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3</a>&nbsp;<a id="date.time.formats" href="#date.time.formats">Date/Time Formats</a></h2>
      <h3 id="rfc.section.3.3.1"><a href="#rfc.section.3.3.1">3.3.1</a>&nbsp;<a id="full.date" href="#full.date">Full Date</a></h3>
      <p id="rfc.section.3.3.1.p.1">HTTP applications have historically allowed three different formats for the representation of date/time stamps:</p>
      <div id="rfc.figure.u.16"></div><pre class="text">   Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123
   Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036
   Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format
</pre><p id="rfc.section.3.3.1.p.3">The first format is preferred as an Internet standard and represents a fixed-length subset of that defined by RFC 1123 <a href="#RFC1123" id="rfc.xref.RFC1123.1"><cite title="Requirements for Internet Hosts - Application and Support">[RFC1123]</cite></a> (an update to RFC 822 <a href="#RFC822" id="rfc.xref.RFC822.3"><cite title="Standard for the format of ARPA Internet text messages">[RFC822]</cite></a>). The second format is in common use, but is based on the obsolete RFC 850 <a href="#RFC1036" id="rfc.xref.RFC1036.1"><cite title="Standard for interchange of USENET messages">[RFC1036]</cite></a> date format and lacks a four-digit year. HTTP/1.1 clients and servers that parse the date value <em class="bcp14">MUST</em> accept all three formats (for compatibility with HTTP/1.0), though they <em class="bcp14">MUST</em> only generate the RFC 1123 format for representing HTTP-date values in header fields. See <a href="#tolerant.applications" title="Tolerant Applications">Appendix&nbsp;19.3</a> for further information.
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> Recipients of date values are encouraged to be robust in accepting date values that may have been sent by non-HTTP applications,
            as is sometimes the case when retrieving or posting messages via proxies/gateways to SMTP or NNTP.
         </dd>
      </dl>
      <p id="rfc.section.3.3.1.p.5">All HTTP date/time stamps <em class="bcp14">MUST</em> be represented in Greenwich Mean Time (GMT), without exception. For the purposes of HTTP, GMT is exactly equal to UTC (Coordinated
         Universal Time). This is indicated in the first two formats by the inclusion of "GMT" as the three-letter abbreviation for
         time zone, and <em class="bcp14">MUST</em> be assumed when reading the asctime format. HTTP-date is case sensitive and <em class="bcp14">MUST NOT</em> include additional LWS beyond that specifically included as SP in the grammar.
      </p>
      <div id="rfc.figure.u.17"></div><pre class="inline"><span id="rfc.iref.g.26"></span><span id="rfc.iref.g.27"></span><span id="rfc.iref.g.28"></span><span id="rfc.iref.g.29"></span><span id="rfc.iref.g.30"></span><span id="rfc.iref.g.31"></span><span id="rfc.iref.g.32"></span><span id="rfc.iref.g.33"></span><span id="rfc.iref.g.34"></span><span id="rfc.iref.g.35"></span><span id="rfc.iref.g.36"></span>    HTTP-date    = rfc1123-date | rfc850-date | asctime-date
    rfc1123-date = wkday "," SP date1 SP time SP "GMT"
    rfc850-date  = weekday "," SP date2 SP time SP "GMT"
    asctime-date = wkday SP date3 SP time SP 4DIGIT
    date1        = 2DIGIT SP month SP 4DIGIT
                   ; day month year (e.g., 02 Jun 1982)
    date2        = 2DIGIT "-" month "-" 2DIGIT
                   ; day-month-year (e.g., 02-Jun-82)
    date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))
                   ; month day (e.g., Jun  2)
    time         = 2DIGIT ":" 2DIGIT ":" 2DIGIT
                   ; 00:00:00 - 23:59:59
    wkday        = "Mon" | "Tue" | "Wed"
                 | "Thu" | "Fri" | "Sat" | "Sun"
    weekday      = "Monday" | "Tuesday" | "Wednesday"
                 | "Thursday" | "Friday" | "Saturday" | "Sunday"
    month        = "Jan" | "Feb" | "Mar" | "Apr"
                 | "May" | "Jun" | "Jul" | "Aug"
                 | "Sep" | "Oct" | "Nov" | "Dec"
</pre><p id="rfc.section.3.3.1.p.7"> <b>Note:</b> HTTP requirements for the date/time stamp format apply only to their usage within the protocol stream. Clients and servers
         are not required to use these formats for user presentation, request logging, etc.
      </p>
      <h3 id="rfc.section.3.3.2"><a href="#rfc.section.3.3.2">3.3.2</a>&nbsp;<a id="delta.seconds" href="#delta.seconds">Delta Seconds</a></h3>
      <p id="rfc.section.3.3.2.p.1">Some HTTP header fields allow a time value to be specified as an integer number of seconds, represented in decimal, after
         the time that the message was received.
      </p>
      <div id="rfc.figure.u.18"></div><pre class="inline"><span id="rfc.iref.g.37"></span>    delta-seconds  = 1*DIGIT
</pre><h2 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4</a>&nbsp;<a id="character.sets" href="#character.sets">Character Sets</a></h2>
      <p id="rfc.section.3.4.p.1">HTTP uses the same definition of the term "character set" as that described for MIME:</p>
      <p id="rfc.section.3.4.p.2">The term "character set" is used in this document to refer to a method used with one or more tables to convert a sequence
         of octets into a sequence of characters. Note that unconditional conversion in the other direction is not required, in that
         not all characters may be available in a given character set and a character set may provide more than one sequence of octets
         to represent a particular character. This definition is intended to allow various kinds of character encoding, from simple
         single-table mappings such as US-ASCII to complex table switching methods such as those that use ISO-2022's techniques. However,
         the definition associated with a MIME character set name <em class="bcp14">MUST</em> fully specify the mapping to be performed from octets to characters. In particular, use of external profiling information
         to determine the exact mapping is not permitted.
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> This use of the term "character set" is more commonly referred to as a "character encoding." However, since HTTP and MIME
            share the same registry, it is important that the terminology also be shared.
         </dd>
      </dl>
      <p id="rfc.section.3.4.p.4">HTTP character sets are identified by case-insensitive tokens. The complete set of tokens is defined by the IANA Character
         Set registry <a href="#RFC1700" id="rfc.xref.RFC1700.2"><cite title="Assigned Numbers">[RFC1700]</cite></a>.
      </p>
      <div id="rfc.figure.u.19"></div><pre class="inline"><span id="rfc.iref.g.38"></span>    charset = token
</pre><p id="rfc.section.3.4.p.6">Although HTTP allows an arbitrary token to be used as a charset value, any token that has a predefined value within the IANA
         Character Set registry <a href="#RFC1700" id="rfc.xref.RFC1700.3"><cite title="Assigned Numbers">[RFC1700]</cite></a>  <em class="bcp14">MUST</em> represent the character set defined by that registry. Applications <em class="bcp14">SHOULD</em> limit their use of character sets to those defined by the IANA registry.
      </p>
      <p id="rfc.section.3.4.p.7">Implementors should be aware of IETF character set requirements <a href="#RFC2279" id="rfc.xref.RFC2279.1"><cite title="UTF-8, a transformation format of ISO 10646">[RFC2279]</cite></a>  <a href="#RFC2277" id="rfc.xref.RFC2277.1"><cite title="IETF Policy on Character Sets and Languages">[RFC2277]</cite></a>.
      </p>
      <h3 id="rfc.section.3.4.1"><a href="#rfc.section.3.4.1">3.4.1</a>&nbsp;<a id="missing.charset" href="#missing.charset">Missing Charset</a></h3>
      <p id="rfc.section.3.4.1.p.1">Some HTTP/1.0 software has interpreted a Content-Type header without charset parameter incorrectly to mean "recipient should
         guess." Senders wishing to defeat this behavior <em class="bcp14">MAY</em> include a charset parameter even when the charset is ISO-8859-1 and <em class="bcp14">SHOULD</em> do so when it is known that it will not confuse the recipient.
      </p>
      <p id="rfc.section.3.4.1.p.2">Unfortunately, some older HTTP/1.0 clients did not deal properly with an explicit charset parameter. HTTP/1.1 recipients <em class="bcp14">MUST</em> respect the charset label provided by the sender; and those user agents that have a provision to "guess" a charset <em class="bcp14">MUST</em> use the charset from the content-type field if they support that charset, rather than the recipient's preference, when initially
         displaying a document. See <a href="#canonicalization.and.text.defaults" title="Canonicalization and Text Defaults">Section&nbsp;3.7.1</a>.
      </p>
      <h2 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5</a>&nbsp;<a id="content.codings" href="#content.codings">Content Codings</a></h2>
      <p id="rfc.section.3.5.p.1">Content coding values indicate an encoding transformation that has been or can be applied to an entity. Content codings are
         primarily used to allow a document to be compressed or otherwise usefully transformed without losing the identity of its underlying
         media type and without loss of information. Frequently, the entity is stored in coded form, transmitted directly, and only
         decoded by the recipient.
      </p>
      <div id="rfc.figure.u.20"></div><pre class="inline"><span id="rfc.iref.g.39"></span>    content-coding   = token
</pre><p id="rfc.section.3.5.p.3">All content-coding values are case-insensitive. HTTP/1.1 uses content-coding values in the Accept-Encoding (<a href="#header.accept-encoding" id="rfc.xref.header.accept-encoding.1" title="Accept-Encoding">Section&nbsp;14.3</a>) and Content-Encoding (<a href="#header.content-encoding" id="rfc.xref.header.content-encoding.1" title="Content-Encoding">Section&nbsp;14.11</a>) header fields. Although the value describes the content-coding, what is more important is that it indicates what decoding
         mechanism will be required to remove the encoding.
      </p>
      <p id="rfc.section.3.5.p.4">The Internet Assigned Numbers Authority (IANA) acts as a registry for content-coding value tokens. Initially, the registry
         contains the following tokens:
      </p>
      <p id="rfc.section.3.5.p.5">gzip<span id="rfc.iref.g.40"></span>  
      </p>
      <dl class="empty">
         <dd>An encoding format produced by the file compression program "gzip" (GNU zip) as described in RFC 1952 <a href="#RFC1952" id="rfc.xref.RFC1952.1"><cite title="GZIP file format specification version 4.3">[RFC1952]</cite></a>. This format is a Lempel-Ziv coding (LZ77) with a 32 bit CRC.
         </dd>
      </dl>
      <p id="rfc.section.3.5.p.6">compress<span id="rfc.iref.c.6"></span>  
      </p>
      <dl class="empty">
         <dd>The encoding format produced by the common UNIX file compression program "compress". This format is an adaptive Lempel-Ziv-Welch
            coding (LZW).
         </dd>
         <dd>Use of program names for the identification of encoding formats is not desirable and is discouraged for future encodings.
            Their use here is representative of historical practice, not good design. For compatibility with previous implementations
            of HTTP, applications <em class="bcp14">SHOULD</em> consider "x-gzip" and "x-compress" to be equivalent to "gzip" and "compress" respectively.
         </dd>
      </dl>
      <p id="rfc.section.3.5.p.7">deflate<span id="rfc.iref.d.2"></span>  
      </p>
      <dl class="empty">
         <dd>The "zlib" format defined in RFC 1950 <a href="#RFC1950" id="rfc.xref.RFC1950.1"><cite title="ZLIB Compressed Data Format Specification version 3.3">[RFC1950]</cite></a> in combination with the "deflate" compression mechanism described in RFC 1951 <a href="#RFC1951" id="rfc.xref.RFC1951.1"><cite title="DEFLATE Compressed Data Format Specification version 1.3">[RFC1951]</cite></a>.
         </dd>
      </dl>
      <p id="rfc.section.3.5.p.8">identity<span id="rfc.iref.i.2"></span>  
      </p>
      <dl class="empty">
         <dd>The default (identity) encoding; the use of no transformation whatsoever. This content-coding is used only in the Accept-Encoding
            header, and <em class="bcp14">SHOULD NOT</em> be used in the Content-Encoding header.
         </dd>
      </dl>
      <p id="rfc.section.3.5.p.9">New content-coding value tokens <em class="bcp14">SHOULD</em> be registered; to allow interoperability between clients and servers, specifications of the content coding algorithms needed
         to implement a new value <em class="bcp14">SHOULD</em> be publicly available and adequate for independent implementation, and conform to the purpose of content coding defined in
         this section.
      </p>
      <h2 id="rfc.section.3.6"><a href="#rfc.section.3.6">3.6</a>&nbsp;<a id="transfer.codings" href="#transfer.codings">Transfer Codings</a></h2>
      <p id="rfc.section.3.6.p.1">Transfer-coding values are used to indicate an encoding transformation that has been, can be, or may need to be applied to
         an entity-body in order to ensure "safe transport" through the network. This differs from a content coding in that the transfer-coding
         is a property of the message, not of the original entity.
      </p>
      <div id="rfc.figure.u.21"></div><pre class="inline"><span id="rfc.iref.g.41"></span><span id="rfc.iref.g.42"></span>    transfer-coding         = "chunked" | transfer-extension
    transfer-extension      = token *( ";" parameter )
</pre><p id="rfc.section.3.6.p.3">Parameters are in the form of attribute/value pairs.</p>
      <div id="rfc.figure.u.22"></div><pre class="inline"><span id="rfc.iref.g.43"></span><span id="rfc.iref.g.44"></span><span id="rfc.iref.g.45"></span>    parameter               = attribute "=" value
    attribute               = token
    value                   = token | quoted-string
</pre><p id="rfc.section.3.6.p.5">All transfer-coding values are case-insensitive. HTTP/1.1 uses transfer-coding values in the TE header field (<a href="#header.te" id="rfc.xref.header.te.1" title="TE">Section&nbsp;14.39</a>) and in the Transfer-Encoding header field (<a href="#header.transfer-encoding" id="rfc.xref.header.transfer-encoding.1" title="Transfer-Encoding">Section&nbsp;14.41</a>).
      </p>
      <p id="rfc.section.3.6.p.6">Whenever a transfer-coding is applied to a message-body, the set of transfer-codings <em class="bcp14">MUST</em> include "chunked", unless the message is terminated by closing the connection. When the "chunked" transfer-coding is used,
         it <em class="bcp14">MUST</em> be the last transfer-coding applied to the message-body. The "chunked" transfer-coding <em class="bcp14">MUST NOT</em> be applied more than once to a message-body. These rules allow the recipient to determine the transfer-length of the message
         (<a href="#message.length" title="Message Length">Section&nbsp;4.4</a>).
      </p>
      <p id="rfc.section.3.6.p.7">Transfer-codings are analogous to the Content-Transfer-Encoding values of MIME <a href="#RFC2045" id="rfc.xref.RFC2045.2"><cite title="Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies">[RFC2045]</cite></a>, which were designed to enable safe transport of binary data over a 7-bit transport service. However, safe transport has
         a different focus for an 8bit-clean transfer protocol. In HTTP, the only unsafe characteristic of message-bodies is the difficulty
         in determining the exact body length (<a href="#entity.length" title="Entity Length">Section&nbsp;7.2.2</a>), or the desire to encrypt data over a shared transport.
      </p>
      <p id="rfc.section.3.6.p.8">The Internet Assigned Numbers Authority (IANA) acts as a registry for transfer-coding value tokens. Initially, the registry
         contains the following tokens: "chunked" (<a href="#chunked.transfer.encoding" title="Chunked Transfer Coding">Section&nbsp;3.6.1</a>), "identity" (section 3.6.2), "gzip" (<a href="#content.codings" title="Content Codings">Section&nbsp;3.5</a>), "compress" (<a href="#content.codings" title="Content Codings">Section&nbsp;3.5</a>), and "deflate" (<a href="#content.codings" title="Content Codings">Section&nbsp;3.5</a>).
      </p>
      <p id="rfc.section.3.6.p.9">New transfer-coding value tokens <em class="bcp14">SHOULD</em> be registered in the same way as new content-coding value tokens (<a href="#content.codings" title="Content Codings">Section&nbsp;3.5</a>).
      </p>
      <p id="rfc.section.3.6.p.10">A server which receives an entity-body with a transfer-coding it does not understand <em class="bcp14">SHOULD</em> return 501 (Unimplemented), and close the connection. A server <em class="bcp14">MUST NOT</em> send transfer-codings to an HTTP/1.0 client.
      </p>
      <h3 id="rfc.section.3.6.1"><a href="#rfc.section.3.6.1">3.6.1</a>&nbsp;<a id="chunked.transfer.encoding" href="#chunked.transfer.encoding">Chunked Transfer Coding</a></h3>
      <p id="rfc.section.3.6.1.p.1">The chunked encoding modifies the body of a message in order to transfer it as a series of chunks, each with its own size
         indicator, followed by an <em class="bcp14">OPTIONAL</em> trailer containing entity-header fields. This allows dynamically produced content to be transferred along with the information
         necessary for the recipient to verify that it has received the full message.
      </p>
      <div id="rfc.figure.u.23"></div><pre class="inline"><span id="rfc.iref.g.46"></span><span id="rfc.iref.g.47"></span><span id="rfc.iref.g.48"></span><span id="rfc.iref.g.49"></span><span id="rfc.iref.g.50"></span><span id="rfc.iref.g.51"></span><span id="rfc.iref.g.52"></span><span id="rfc.iref.g.53"></span><span id="rfc.iref.g.54"></span>    Chunked-Body   = *chunk
                     last-chunk
                     trailer
                     CRLF

    chunk          = chunk-size [ chunk-extension ] CRLF
                     chunk-data CRLF
    chunk-size     = 1*HEX
    last-chunk     = 1*("0") [ chunk-extension ] CRLF

    chunk-extension= *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
    chunk-ext-name = token
    chunk-ext-val  = token | quoted-string
    chunk-data     = chunk-size(OCTET)
    trailer        = *(entity-header CRLF)
</pre><p id="rfc.section.3.6.1.p.3">The chunk-size field is a string of hex digits indicating the size of the chunk. The chunked encoding is ended by any chunk
         whose size is zero, followed by the trailer, which is terminated by an empty line.
      </p>
      <p id="rfc.section.3.6.1.p.4">The trailer allows the sender to include additional HTTP header fields at the end of the message. The Trailer header field
         can be used to indicate which header fields are included in a trailer (see <a href="#header.trailer" id="rfc.xref.header.trailer.1" title="Trailer">Section&nbsp;14.40</a>).
      </p>
      <p id="rfc.section.3.6.1.p.5">A server using chunked transfer-coding in a response <em class="bcp14">MUST NOT</em> use the trailer for any header fields unless at least one of the following is true: 
      </p>
      <ol>
         <li>the request included a TE header field that indicates "trailers" is acceptable in the transfer-coding of the response, as
            described in <a href="#header.te" id="rfc.xref.header.te.2" title="TE">Section&nbsp;14.39</a>; or,
         </li>
         <li>the server is the origin server for the response, the trailer fields consist entirely of optional metadata, and the recipient
            could use the message (in a manner acceptable to the origin server) without receiving this metadata. In other words, the origin
            server is willing to accept the possibility that the trailer fields might be silently discarded along the path to the client.
         </li>
      </ol>
      <p id="rfc.section.3.6.1.p.6">This requirement prevents an interoperability failure when the message is being received by an HTTP/1.1 (or later) proxy and
         forwarded to an HTTP/1.0 recipient. It avoids a situation where compliance with the protocol would have necessitated a possibly
         infinite buffer on the proxy.
      </p>
      <p id="rfc.section.3.6.1.p.7">An example process for decoding a Chunked-Body is presented in <a href="#introduction.of.transfer-encoding" title="Introduction of Transfer-Encoding">Appendix&nbsp;19.4.6</a>.
      </p>
      <p id="rfc.section.3.6.1.p.8">All HTTP/1.1 applications <em class="bcp14">MUST</em> be able to receive and decode the "chunked" transfer-coding, and <em class="bcp14">MUST</em> ignore chunk-extension extensions they do not understand.
      </p>
      <h2 id="rfc.section.3.7"><a href="#rfc.section.3.7">3.7</a>&nbsp;<a id="media.types" href="#media.types">Media Types</a></h2>
      <p id="rfc.section.3.7.p.1">HTTP uses Internet Media Types <a href="#RFC1590" id="rfc.xref.RFC1590.1"><cite title="Media Type Registration Procedure">[RFC1590]</cite></a> in the Content-Type (<a href="#header.content-type" id="rfc.xref.header.content-type.1" title="Content-Type">Section&nbsp;14.17</a>) and Accept (<a href="#header.accept" id="rfc.xref.header.accept.1" title="Accept">Section&nbsp;14.1</a>) header fields in order to provide open and extensible data typing and type negotiation.
      </p>
      <div id="rfc.figure.u.24"></div><pre class="inline"><span id="rfc.iref.g.55"></span><span id="rfc.iref.g.56"></span><span id="rfc.iref.g.57"></span>    media-type     = type "/" subtype *( ";" parameter )
    type           = token
    subtype        = token
</pre><p id="rfc.section.3.7.p.3">Parameters <em class="bcp14">MAY</em> follow the type/subtype in the form of attribute/value pairs (as defined in <a href="#transfer.codings" title="Transfer Codings">Section&nbsp;3.6</a>).
      </p>
      <p id="rfc.section.3.7.p.4">The type, subtype, and parameter attribute names are case-insensitive. Parameter values might or might not be case-sensitive,
         depending on the semantics of the parameter name. Linear white space (LWS) <em class="bcp14">MUST NOT</em> be used between the type and subtype, nor between an attribute and its value. The presence or absence of a parameter might
         be significant to the processing of a media-type, depending on its definition within the media type registry.
      </p>
      <p id="rfc.section.3.7.p.5">Note that some older HTTP applications do not recognize media type parameters. When sending data to older HTTP applications,
         implementations <em class="bcp14">SHOULD</em> only use media type parameters when they are required by that type/subtype definition.
      </p>
      <p id="rfc.section.3.7.p.6">Media-type values are registered with the Internet Assigned Number Authority (IANA <a href="#RFC1700" id="rfc.xref.RFC1700.4"><cite title="Assigned Numbers">[RFC1700]</cite></a>). The media type registration process is outlined in RFC 1590 <a href="#RFC1590" id="rfc.xref.RFC1590.2"><cite title="Media Type Registration Procedure">[RFC1590]</cite></a>. Use of non-registered media types is discouraged.
      </p>
      <h3 id="rfc.section.3.7.1"><a href="#rfc.section.3.7.1">3.7.1</a>&nbsp;<a id="canonicalization.and.text.defaults" href="#canonicalization.and.text.defaults">Canonicalization and Text Defaults</a></h3>
      <p id="rfc.section.3.7.1.p.1">Internet media types are registered with a canonical form. An entity-body transferred via HTTP messages <em class="bcp14">MUST</em> be represented in the appropriate canonical form prior to its transmission except for "text" types, as defined in the next
         paragraph.
      </p>
      <p id="rfc.section.3.7.1.p.2">When in canonical form, media subtypes of the "text" type use CRLF as the text line break. HTTP relaxes this requirement and
         allows the transport of text media with plain CR or LF alone representing a line break when it is done consistently for an
         entire entity-body. HTTP applications <em class="bcp14">MUST</em> accept CRLF, bare CR, and bare LF as being representative of a line break in text media received via HTTP. In addition, if
         the text is represented in a character set that does not use octets 13 and 10 for CR and LF respectively, as is the case for
         some multi-byte character sets, HTTP allows the use of whatever octet sequences are defined by that character set to represent
         the equivalent of CR and LF for line breaks. This flexibility regarding line breaks applies only to text media in the entity-body;
         a bare CR or LF <em class="bcp14">MUST NOT</em> be substituted for CRLF within any of the HTTP control structures (such as header fields and multipart boundaries).
      </p>
      <p id="rfc.section.3.7.1.p.3">If an entity-body is encoded with a content-coding, the underlying data <em class="bcp14">MUST</em> be in a form defined above prior to being encoded.
      </p>
      <p id="rfc.section.3.7.1.p.4">The "charset" parameter is used with some media types to define the character set (<a href="#character.sets" title="Character Sets">Section&nbsp;3.4</a>) of the data. When no explicit charset parameter is provided by the sender, media subtypes of the "text" type are defined
         to have a default charset value of "ISO-8859-1" when received via HTTP. Data in character sets other than "ISO-8859-1" or
         its subsets <em class="bcp14">MUST</em> be labeled with an appropriate charset value. See <a href="#missing.charset" title="Missing Charset">Section&nbsp;3.4.1</a> for compatibility problems.
      </p>
      <h3 id="rfc.section.3.7.2"><a href="#rfc.section.3.7.2">3.7.2</a>&nbsp;<a id="multipart.types" href="#multipart.types">Multipart Types</a></h3>
      <p id="rfc.section.3.7.2.p.1">MIME provides for a number of "multipart" types -- encapsulations of one or more entities within a single message-body. All
         multipart types share a common syntax, as defined in section <a href="http://tools.ietf.org/html/rfc2046#section-5.1.1" id="rfc.xref.RFC2046.1">5.1.1</a> of RFC 2046 <a href="#RFC2046" id="rfc.xref.RFC2046.2"><cite title="Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types">[RFC2046]</cite></a>, and <em class="bcp14">MUST</em> include a boundary parameter as part of the media type value. The message body is itself a protocol element and <em class="bcp14">MUST</em> therefore use only CRLF to represent line breaks between body-parts. Unlike in RFC 2046, the epilogue of any multipart message <em class="bcp14">MUST</em> be empty; HTTP applications <em class="bcp14">MUST NOT</em> transmit the epilogue (even if the original multipart contains an epilogue). These restrictions exist in order to preserve
         the self-delimiting nature of a multipart message-body, wherein the "end" of the message-body is indicated by the ending multipart
         boundary.
      </p>
      <p id="rfc.section.3.7.2.p.2">In general, HTTP treats a multipart message-body no differently than any other media type: strictly as payload. The one exception
         is the "multipart/byteranges" type (<a href="#internet.media.type.multipart.byteranges" title="Internet Media Type multipart/byteranges">Appendix&nbsp;19.2</a>) when it appears in a 206 (Partial Content) response, which will be interpreted by some HTTP caching mechanisms as described
         in sections <a href="#combining.byte.ranges" title="Combining Byte Ranges">13.5.4</a> and <a href="#header.content-range" id="rfc.xref.header.content-range.1" title="Content-Range">14.16</a>. In all other cases, an HTTP user agent <em class="bcp14">SHOULD</em> follow the same or similar behavior as a MIME user agent would upon receipt of a multipart type. The MIME header fields within
         each body-part of a multipart message-body do not have any significance to HTTP beyond that defined by their MIME semantics.
      </p>
      <p id="rfc.section.3.7.2.p.3">In general, an HTTP user agent <em class="bcp14">SHOULD</em> follow the same or similar behavior as a MIME user agent would upon receipt of a multipart type. If an application receives
         an unrecognized multipart subtype, the application <em class="bcp14">MUST</em> treat it as being equivalent to "multipart/mixed".
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> The "multipart/form-data" type has been specifically defined for carrying form data suitable for processing via the POST request
            method, as described in RFC 1867 <a href="#RFC1867" id="rfc.xref.RFC1867.1"><cite title="Form-based File Upload in HTML">[RFC1867]</cite></a>.
         </dd>
      </dl>
      <h2 id="rfc.section.3.8"><a href="#rfc.section.3.8">3.8</a>&nbsp;<a id="product.tokens" href="#product.tokens">Product Tokens</a></h2>
      <p id="rfc.section.3.8.p.1">Product tokens are used to allow communicating applications to identify themselves by software name and version. Most fields
         using product tokens also allow sub-products which form a significant part of the application to be listed, separated by white
         space. By convention, the products are listed in order of their significance for identifying the application.
      </p>
      <div id="rfc.figure.u.25"></div><pre class="inline"><span id="rfc.iref.g.58"></span><span id="rfc.iref.g.59"></span>    product         = token ["/" product-version]
    product-version = token
</pre><p id="rfc.section.3.8.p.3">Examples:</p>
      <div id="rfc.figure.u.26"></div><pre class="text">    User-Agent: CERN-LineMode/2.15 libwww/2.17b3
    Server: Apache/0.8.4
</pre><p id="rfc.section.3.8.p.5">Product tokens <em class="bcp14">SHOULD</em> be short and to the point. They <em class="bcp14">MUST NOT</em> be used for advertising or other non-essential information. Although any token character <em class="bcp14">MAY</em> appear in a product-version, this token <em class="bcp14">SHOULD</em> only be used for a version identifier (i.e., successive versions of the same product <em class="bcp14">SHOULD</em> only differ in the product-version portion of the product value).
      </p>
      <h2 id="rfc.section.3.9"><a href="#rfc.section.3.9">3.9</a>&nbsp;<a id="quality.values" href="#quality.values">Quality Values</a></h2>
      <p id="rfc.section.3.9.p.1">HTTP content negotiation (<a href="#content.negotiation" title="Content Negotiation">Section&nbsp;12</a>) uses short "floating point" numbers to indicate the relative importance ("weight") of various negotiable parameters. A weight
         is normalized to a real number in the range 0 through 1, where 0 is the minimum and 1 the maximum value. If a parameter has
         a quality value of 0, then content with this parameter is `not acceptable' for the client. HTTP/1.1 applications <em class="bcp14">MUST NOT</em> generate more than three digits after the decimal point. User configuration of these values <em class="bcp14">SHOULD</em> also be limited in this fashion.
      </p>
      <div id="rfc.figure.u.27"></div><pre class="inline"><span id="rfc.iref.g.60"></span>    qvalue         = ( "0" [ "." 0*3DIGIT ] )
                   | ( "1" [ "." 0*3("0") ] )
</pre><p id="rfc.section.3.9.p.3">"Quality values" is a misnomer, since these values merely represent relative degradation in desired quality.</p>
      <h2 id="rfc.section.3.10"><a href="#rfc.section.3.10">3.10</a>&nbsp;<a id="language.tags" href="#language.tags">Language Tags</a></h2>
      <p id="rfc.section.3.10.p.1">A language tag identifies a natural language spoken, written, or otherwise conveyed by human beings for communication of information
         to other human beings. Computer languages are explicitly excluded. HTTP uses language tags within the Accept-Language and
         Content-Language fields.
      </p>
      <p id="rfc.section.3.10.p.2">The syntax and registry of HTTP language tags is the same as that defined by RFC 1766 <a href="#RFC1766" id="rfc.xref.RFC1766.1"><cite title="Tags for the Identification of Languages">[RFC1766]</cite></a>. In summary, a language tag is composed of 1 or more parts: A primary language tag and a possibly empty series of subtags:
      </p>
      <div id="rfc.figure.u.28"></div><pre class="inline"><span id="rfc.iref.g.61"></span><span id="rfc.iref.g.62"></span><span id="rfc.iref.g.63"></span>     language-tag  = primary-tag *( "-" subtag )
     primary-tag   = 1*8ALPHA
     subtag        = 1*8ALPHA
</pre><p id="rfc.section.3.10.p.4">White space is not allowed within the tag and all tags are case-insensitive. The name space of language tags is administered
         by the IANA. Example tags include:
      </p>
      <div id="rfc.figure.u.29"></div><pre class="text">    en, en-US, en-cockney, i-cherokee, x-pig-latin
</pre><p id="rfc.section.3.10.p.6">where any two-letter primary-tag is an ISO-639 language abbreviation and any two-letter initial subtag is an ISO-3166 country
         code. (The last three tags above are not registered tags; all but the last are examples of tags which could be registered
         in future.)
      </p>
      <h2 id="rfc.section.3.11"><a href="#rfc.section.3.11">3.11</a>&nbsp;<a id="entity.tags" href="#entity.tags">Entity Tags</a></h2>
      <p id="rfc.section.3.11.p.1">Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the
         ETag (<a href="#header.etag" id="rfc.xref.header.etag.1" title="ETag">Section&nbsp;14.19</a>), If-Match (<a href="#header.if-match" id="rfc.xref.header.if-match.1" title="If-Match">Section&nbsp;14.24</a>), If-None-Match (<a href="#header.if-none-match" id="rfc.xref.header.if-none-match.1" title="If-None-Match">Section&nbsp;14.26</a>), and If-Range (<a href="#header.if-range" id="rfc.xref.header.if-range.1" title="If-Range">Section&nbsp;14.27</a>) header fields. The definition of how they are used and compared as cache validators is in <a href="#weak.and.strong.validators" title="Weak and Strong Validators">Section&nbsp;13.3.3</a>. An entity tag consists of an opaque quoted string, possibly prefixed by a weakness indicator.
      </p>
      <div id="rfc.figure.u.30"></div><pre class="inline"><span id="rfc.iref.g.64"></span><span id="rfc.iref.g.65"></span><span id="rfc.iref.g.66"></span>   entity-tag = [ weak ] opaque-tag
   weak       = "W/"
   opaque-tag = quoted-string
</pre><p id="rfc.section.3.11.p.3">A "strong entity tag" <em class="bcp14">MAY</em> be shared by two entities of a resource only if they are equivalent by octet equality.
      </p>
      <p id="rfc.section.3.11.p.4">A "weak entity tag," indicated by the "W/" prefix, <em class="bcp14">MAY</em> be shared by two entities of a resource only if the entities are equivalent and could be substituted for each other with no
         significant change in semantics. A weak entity tag can only be used for weak comparison.
      </p>
      <p id="rfc.section.3.11.p.5">An entity tag <em class="bcp14">MUST</em> be unique across all versions of all entities associated with a particular resource. A given entity tag value <em class="bcp14">MAY</em> be used for entities obtained by requests on different URIs. The use of the same entity tag value in conjunction with entities
         obtained by requests on different URIs does not imply the equivalence of those entities.
      </p>
      <h2 id="rfc.section.3.12"><a href="#rfc.section.3.12">3.12</a>&nbsp;<a id="range.units" href="#range.units">Range Units</a></h2>
      <p id="rfc.section.3.12.p.1">HTTP/1.1 allows a client to request that only part (a range of) the response entity be included within the response. HTTP/1.1
         uses range units in the Range (<a href="#header.range" id="rfc.xref.header.range.1" title="Range">Section&nbsp;14.35</a>) and Content-Range (<a href="#header.content-range" id="rfc.xref.header.content-range.2" title="Content-Range">Section&nbsp;14.16</a>) header fields. An entity can be broken down into subranges according to various structural units.
      </p>
      <div id="rfc.figure.u.31"></div><pre class="inline"><span id="rfc.iref.g.67"></span><span id="rfc.iref.g.68"></span><span id="rfc.iref.g.69"></span>   range-unit       = bytes-unit | other-range-unit
   bytes-unit       = "bytes"
   other-range-unit = token
</pre><p id="rfc.section.3.12.p.3">The only range unit defined by HTTP/1.1 is "bytes". HTTP/1.1 implementations <em class="bcp14">MAY</em> ignore ranges specified using other units.
      </p>
      <p id="rfc.section.3.12.p.4">HTTP/1.1 has been designed to allow implementations of applications that do not depend on knowledge of ranges.</p>
      <h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a id="http.message" href="#http.message">HTTP Message</a></h1>
      <h2 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1</a>&nbsp;<a id="message.types" href="#message.types">Message Types</a></h2>
      <p id="rfc.section.4.1.p.1">HTTP messages consist of requests from client to server and responses from server to client.</p>
      <div id="rfc.figure.u.32"></div><pre class="inline"><span id="rfc.iref.g.70"></span>    HTTP-message   = Request | Response     ; HTTP/1.1 messages
</pre><p id="rfc.section.4.1.p.3">Request (<a href="#request" title="Request">Section&nbsp;5</a>) and Response (<a href="#response" title="Response">Section&nbsp;6</a>) messages use the generic message format of RFC 822 <a href="#RFC822" id="rfc.xref.RFC822.4"><cite title="Standard for the format of ARPA Internet text messages">[RFC822]</cite></a> for transferring entities (the payload of the message). Both types of message consist of a start-line, zero or more header
         fields (also known as "headers"), an empty line (i.e., a line with nothing preceding the CRLF) indicating the end of the header
         fields, and possibly a message-body.
      </p>
      <div id="rfc.figure.u.33"></div><pre class="inline"><span id="rfc.iref.g.71"></span><span id="rfc.iref.g.72"></span>     generic-message = start-line
                       *(message-header CRLF)
                       CRLF
                       [ message-body ]
     start-line      = Request-Line | Status-Line
</pre><p id="rfc.section.4.1.p.5">In the interest of robustness, servers <em class="bcp14">SHOULD</em> ignore any empty line(s) received where a Request-Line is expected. In other words, if the server is reading the protocol
         stream at the beginning of a message and receives a CRLF first, it should ignore the CRLF.
      </p>
      <p id="rfc.section.4.1.p.6">Certain buggy HTTP/1.0 client implementations generate extra CRLF's after a POST request. To restate what is explicitly forbidden
         by the BNF, an HTTP/1.1 client <em class="bcp14">MUST NOT</em> preface or follow a request with an extra CRLF.
      </p>
      <h2 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2</a>&nbsp;<a id="message.headers" href="#message.headers">Message Headers</a></h2>
      <p id="rfc.section.4.2.p.1">HTTP header fields, which include general-header (<a href="#general.header.fields" title="General Header Fields">Section&nbsp;4.5</a>), request-header (<a href="#request.header.fields" title="Request Header Fields">Section&nbsp;5.3</a>), response-header (<a href="#response.header.fields" title="Response Header Fields">Section&nbsp;6.2</a>), and entity-header (<a href="#entity.header.fields" title="Entity Header Fields">Section&nbsp;7.1</a>) fields, follow the same generic format as that given in <a href="http://tools.ietf.org/html/rfc822#section-3.1" id="rfc.xref.RFC822.5">Section 3.1</a> of RFC 822 <a href="#RFC822" id="rfc.xref.RFC822.6"><cite title="Standard for the format of ARPA Internet text messages">[RFC822]</cite></a>. Each header field consists of a name followed by a colon (":") and the field value. Field names are case-insensitive. The
         field value <em class="bcp14">MAY</em> be preceded by any amount of LWS, though a single SP is preferred. Header fields can be extended over multiple lines by preceding
         each extra line with at least one SP or HT. Applications ought to follow "common form", where one is known or indicated, when
         generating HTTP constructs, since there might exist some implementations that fail to accept anything beyond the common forms.
      </p>
      <div id="rfc.figure.u.34"></div><pre class="inline"><span id="rfc.iref.g.73"></span><span id="rfc.iref.g.74"></span><span id="rfc.iref.g.75"></span><span id="rfc.iref.g.76"></span>    message-header = field-name ":" [ field-value ]
    field-name     = token
    field-value    = *( field-content | LWS )
    field-content  = &lt;the OCTETs making up the field-value
                     and consisting of either *TEXT or combinations
                     of token, separators, and quoted-string&gt;
</pre><p id="rfc.section.4.2.p.3">The field-content does not include any leading or trailing LWS: linear white space occurring before the first non-whitespace
         character of the field-value or after the last non-whitespace character of the field-value. Such leading or trailing LWS <em class="bcp14">MAY</em> be removed without changing the semantics of the field value. Any LWS that occurs between field-content <em class="bcp14">MAY</em> be replaced with a single SP before interpreting the field value or forwarding the message downstream.
      </p>
      <p id="rfc.section.4.2.p.4">The order in which header fields with differing field names are received is not significant. However, it is "good practice"
         to send general-header fields first, followed by request-header or response-header fields, and ending with the entity-header
         fields.
      </p>
      <p id="rfc.section.4.2.p.5">Multiple message-header fields with the same field-name <em class="bcp14">MAY</em> be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list [i.e.,
         #(values)]. It <em class="bcp14">MUST</em> be possible to combine the multiple header fields into one "field-name: field-value" pair, without changing the semantics
         of the message, by appending each subsequent field-value to the first, each separated by a comma. The order in which header
         fields with the same field-name are received is therefore significant to the interpretation of the combined field value, and
         thus a proxy <em class="bcp14">MUST NOT</em> change the order of these field values when a message is forwarded.
      </p>
      <h2 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3</a>&nbsp;<a id="message.body" href="#message.body">Message Body</a></h2>
      <p id="rfc.section.4.3.p.1">The message-body (if any) of an HTTP message is used to carry the entity-body associated with the request or response. The
         message-body differs from the entity-body only when a transfer-coding has been applied, as indicated by the Transfer-Encoding
         header field (<a href="#header.transfer-encoding" id="rfc.xref.header.transfer-encoding.2" title="Transfer-Encoding">Section&nbsp;14.41</a>).
      </p>
      <div id="rfc.figure.u.35"></div><pre class="inline"><span id="rfc.iref.g.77"></span>    message-body = entity-body
                 | &lt;entity-body encoded as per Transfer-Encoding&gt;
</pre><p id="rfc.section.4.3.p.3">Transfer-Encoding <em class="bcp14">MUST</em> be used to indicate any transfer-codings applied by an application to ensure safe and proper transfer of the message. Transfer-Encoding
         is a property of the message, not of the entity, and thus <em class="bcp14">MAY</em> be added or removed by any application along the request/response chain. (However, <a href="#transfer.codings" title="Transfer Codings">Section&nbsp;3.6</a> places restrictions on when certain transfer-codings may be used.)
      </p>
      <p id="rfc.section.4.3.p.4">The rules for when a message-body is allowed in a message differ for requests and responses.</p>
      <p id="rfc.section.4.3.p.5">The presence of a message-body in a request is signaled by the inclusion of a Content-Length or Transfer-Encoding header field
         in the request's message-headers. A message-body <em class="bcp14">MUST NOT</em> be included in a request if the specification of the request method (<a href="#method" title="Method">Section&nbsp;5.1.1</a>) does not allow sending an entity-body in requests. A server <em class="bcp14">SHOULD</em> read and forward a message-body on any request; if the request method does not include defined semantics for an entity-body,
         then the message-body <em class="bcp14">SHOULD</em> be ignored when handling the request.
      </p>
      <p id="rfc.section.4.3.p.6">For response messages, whether or not a message-body is included with a message is dependent on both the request method and
         the response status code (<a href="#status.code.and.reason.phrase" title="Status Code and Reason Phrase">Section&nbsp;6.1.1</a>). All responses to the HEAD request method <em class="bcp14">MUST NOT</em> include a message-body, even though the presence of entity-header fields might lead one to believe they do. All 1xx (informational),
         204 (no content), and 304 (not modified) responses <em class="bcp14">MUST NOT</em> include a message-body. All other responses do include a message-body, although it <em class="bcp14">MAY</em> be of zero length.
      </p>
      <h2 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4</a>&nbsp;<a id="message.length" href="#message.length">Message Length</a></h2>
      <p id="rfc.section.4.4.p.1">The transfer-length of a message is the length of the message-body as it appears in the message; that is, after any transfer-codings
         have been applied. When a message-body is included with a message, the transfer-length of that body is determined by one of
         the following (in order of precedence):
      </p>
      <p id="rfc.section.4.4.p.2"> </p>
      <ol>
         <li>
            <p>Any response message which "<em class="bcp14">MUST NOT</em>" include a message-body (such as the 1xx, 204, and 304 responses and any response to a HEAD request) is always terminated
               by the first empty line after the header fields, regardless of the entity-header fields present in the message.
            </p>
         </li>
         <li>
            <p>If a Transfer-Encoding header field (<a href="#header.transfer-encoding" id="rfc.xref.header.transfer-encoding.3" title="Transfer-Encoding">Section&nbsp;14.41</a>) is present and has any value other than "identity", then the transfer-length is defined by use of the "chunked" transfer-coding
               (<a href="#transfer.codings" title="Transfer Codings">Section&nbsp;3.6</a>), unless the message is terminated by closing the connection.
            </p>
         </li>
         <li>
            <p>If a Content-Length header field (<a href="#header.content-length" id="rfc.xref.header.content-length.1" title="Content-Length">Section&nbsp;14.13</a>) is present, its decimal value in OCTETs represents both the entity-length and the transfer-length. The Content-Length header
               field <em class="bcp14">MUST NOT</em> be sent if these two lengths are different (i.e., if a Transfer-Encoding header field is present). If a message is received
               with both a Transfer-Encoding header field and a Content-Length header field, the latter <em class="bcp14">MUST</em> be ignored.
            </p>
         </li>
         <li>
            <p>If the message uses the media type "multipart/byteranges", and the ransfer-length is not otherwise specified, then this self-elimiting
               media type defines the transfer-length. This media type UST NOT be used unless the sender knows that the recipient can arse
               it; the presence in a request of a Range header with ultiple byte-range specifiers from a 1.1 client implies that the lient
               can parse multipart/byteranges responses. 
            </p>
            <dl class="empty">
               <dd>A range header might be forwarded by a 1.0 proxy that does not understand multipart/byteranges; in this case the server <em class="bcp14">MUST</em> delimit the message using methods defined in items 1, 3 or 5 of this section.
               </dd>
            </dl>
         </li>
         <li>
            <p>By the server closing the connection. (Closing the connection cannot be used to indicate the end of a request body, since
               that would leave no possibility for the server to send back a response.)
            </p>
         </li>
      </ol>
      <p id="rfc.section.4.4.p.3">For compatibility with HTTP/1.0 applications, HTTP/1.1 requests containing a message-body <em class="bcp14">MUST</em> include a valid Content-Length header field unless the server is known to be HTTP/1.1 compliant. If a request contains a message-body
         and a Content-Length is not given, the server <em class="bcp14">SHOULD</em> respond with 400 (bad request) if it cannot determine the length of the message, or with 411 (length required) if it wishes
         to insist on receiving a valid Content-Length.
      </p>
      <p id="rfc.section.4.4.p.4">All HTTP/1.1 applications that receive entities <em class="bcp14">MUST</em> accept the "chunked" transfer-coding (<a href="#transfer.codings" title="Transfer Codings">Section&nbsp;3.6</a>), thus allowing this mechanism to be used for messages when the message length cannot be determined in advance.
      </p>
      <p id="rfc.section.4.4.p.5">Messages <em class="bcp14">MUST NOT</em> include both a Content-Length header field and a non-identity transfer-coding. If the message does include a non-identity
         transfer-coding, the Content-Length <em class="bcp14">MUST</em> be ignored.
      </p>
      <p id="rfc.section.4.4.p.6">When a Content-Length is given in a message where a message-body is allowed, its field value <em class="bcp14">MUST</em> exactly match the number of OCTETs in the message-body. HTTP/1.1 user agents <em class="bcp14">MUST</em> notify the user when an invalid length is received and detected.
      </p>
      <h2 id="rfc.section.4.5"><a href="#rfc.section.4.5">4.5</a>&nbsp;<a id="general.header.fields" href="#general.header.fields">General Header Fields</a></h2>
      <p id="rfc.section.4.5.p.1">There are a few header fields which have general applicability for both request and response messages, but which do not apply
         to the entity being transferred. These header fields apply only to the message being transmitted.
      </p>
      <div id="rfc.figure.u.36"></div><pre class="inline"><span id="rfc.iref.g.78"></span>    general-header = Cache-Control            ; <a href="#header.cache-control" id="rfc.xref.header.cache-control.1" title="Cache-Control">Section&nbsp;14.9</a>
                   | Connection               ; <a href="#header.connection" id="rfc.xref.header.connection.1" title="Connection">Section&nbsp;14.10</a>
                   | Date                     ; <a href="#header.date" id="rfc.xref.header.date.1" title="Date">Section&nbsp;14.18</a>
                   | Pragma                   ; <a href="#header.pragma" id="rfc.xref.header.pragma.1" title="Pragma">Section&nbsp;14.32</a>
                   | Trailer                  ; <a href="#header.trailer" id="rfc.xref.header.trailer.2" title="Trailer">Section&nbsp;14.40</a>
                   | Transfer-Encoding        ; <a href="#header.transfer-encoding" id="rfc.xref.header.transfer-encoding.4" title="Transfer-Encoding">Section&nbsp;14.41</a>
                   | Upgrade                  ; <a href="#header.upgrade" id="rfc.xref.header.upgrade.1" title="Upgrade">Section&nbsp;14.42</a>
                   | Via                      ; <a href="#header.via" id="rfc.xref.header.via.1" title="Via">Section&nbsp;14.45</a>
                   | Warning                  ; <a href="#header.warning" id="rfc.xref.header.warning.1" title="Warning">Section&nbsp;14.46</a>
</pre><p id="rfc.section.4.5.p.3">General-header field names can be extended reliably only in combination with a change in the protocol version. However, new
         or experimental header fields may be given the semantics of general header fields if all parties in the communication recognize
         them to be general-header fields. Unrecognized header fields are treated as entity-header fields.
      </p>
      <h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a>&nbsp;<a id="request" href="#request">Request</a></h1>
      <p id="rfc.section.5.p.1">A request message from a client to a server includes, within the first line of that message, the method to be applied to the
         resource, the identifier of the resource, and the protocol version in use.
      </p>
      <div id="rfc.figure.u.37"></div><pre class="inline"><span id="rfc.iref.g.79"></span>     Request       = Request-Line              ; <a href="#request-line" title="Request-Line">Section&nbsp;5.1</a>
                     *(( general-header        ; <a href="#general.header.fields" title="General Header Fields">Section&nbsp;4.5</a>
                      | request-header         ; <a href="#request.header.fields" title="Request Header Fields">Section&nbsp;5.3</a>
                      | entity-header ) CRLF)  ; <a href="#entity.header.fields" title="Entity Header Fields">Section&nbsp;7.1</a>
                     CRLF
                     [ message-body ]          ; <a href="#message.body" title="Message Body">Section&nbsp;4.3</a>
</pre><h2 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1</a>&nbsp;<a id="request-line" href="#request-line">Request-Line</a></h2>
      <p id="rfc.section.5.1.p.1">The Request-Line begins with a method token, followed by the Request-URI and the protocol version, and ending with CRLF. The
         elements are separated by SP characters. No CR or LF is allowed except in the final CRLF sequence.
      </p>
      <div id="rfc.figure.u.38"></div><pre class="inline"><span id="rfc.iref.g.80"></span>     Request-Line   = Method SP Request-URI SP HTTP-Version CRLF
</pre><h3 id="rfc.section.5.1.1"><a href="#rfc.section.5.1.1">5.1.1</a>&nbsp;<a id="method" href="#method">Method</a></h3>
      <p id="rfc.section.5.1.1.p.1">The Method token indicates the method to be performed on the resource identified by the Request-URI. The method is case-sensitive.</p>
      <div id="rfc.figure.u.39"></div><pre class="inline"><span id="rfc.iref.g.81"></span><span id="rfc.iref.g.82"></span>    Method         = "OPTIONS"                ; <a href="#OPTIONS" id="rfc.xref.OPTIONS.1" title="OPTIONS">Section&nbsp;9.2</a>
                   | "GET"                    ; <a href="#GET" id="rfc.xref.GET.1" title="GET">Section&nbsp;9.3</a>
                   | "HEAD"                   ; <a href="#HEAD" id="rfc.xref.HEAD.1" title="HEAD">Section&nbsp;9.4</a>
                   | "POST"                   ; <a href="#POST" id="rfc.xref.POST.1" title="POST">Section&nbsp;9.5</a>
                   | "PUT"                    ; <a href="#PUT" id="rfc.xref.PUT.1" title="PUT">Section&nbsp;9.6</a>
                   | "DELETE"                 ; <a href="#DELETE" id="rfc.xref.DELETE.1" title="DELETE">Section&nbsp;9.7</a>
                   | "TRACE"                  ; <a href="#TRACE" id="rfc.xref.TRACE.1" title="TRACE">Section&nbsp;9.8</a>
                   | "CONNECT"                ; <a href="#CONNECT" id="rfc.xref.CONNECT.1" title="CONNECT">Section&nbsp;9.9</a>
                   | extension-method
    extension-method = token
</pre><p id="rfc.section.5.1.1.p.3">The list of methods allowed by a resource can be specified in an Allow header field (<a href="#header.allow" id="rfc.xref.header.allow.1" title="Allow">Section&nbsp;14.7</a>). The return code of the response always notifies the client whether a method is currently allowed on a resource, since the
         set of allowed methods can change dynamically. An origin server <em class="bcp14">SHOULD</em> return the status code 405 (Method Not Allowed) if the method is known by the origin server but not allowed for the requested
         resource, and 501 (Not Implemented) if the method is unrecognized or not implemented by the origin server. The methods GET
         and HEAD <em class="bcp14">MUST</em> be supported by all general-purpose servers. All other methods are <em class="bcp14">OPTIONAL</em>; however, if the above methods are implemented, they <em class="bcp14">MUST</em> be implemented with the same semantics as those specified in <a href="#method.definitions" title="Method Definitions">Section&nbsp;9</a>.
      </p>
      <h3 id="rfc.section.5.1.2"><a href="#rfc.section.5.1.2">5.1.2</a>&nbsp;<a id="request-uri" href="#request-uri">Request-URI</a></h3>
      <p id="rfc.section.5.1.2.p.1">The Request-URI is a Uniform Resource Identifier (<a href="#uri" title="Uniform Resource Identifiers">Section&nbsp;3.2</a>) and identifies the resource upon which to apply the request.
      </p>
      <div id="rfc.figure.u.40"></div><pre class="inline"><span id="rfc.iref.g.83"></span>    Request-URI    = "*" | absoluteURI | abs_path | authority
</pre><p id="rfc.section.5.1.2.p.3">The four options for Request-URI are dependent on the nature of the request. The asterisk "*" means that the request does
         not apply to a particular resource, but to the server itself, and is only allowed when the method used does not necessarily
         apply to a resource. One example would be
      </p>
      <div id="rfc.figure.u.41"></div><pre class="text">    OPTIONS * HTTP/1.1
</pre><p id="rfc.section.5.1.2.p.5">The absoluteURI form is <em class="bcp14">REQUIRED</em> when the request is being made to a proxy. The proxy is requested to forward the request or service it from a valid cache,
         and return the response. Note that the proxy <em class="bcp14">MAY</em> forward the request on to another proxy or directly to the server specified by the absoluteURI. In order to avoid request
         loops, a proxy <em class="bcp14">MUST</em> be able to recognize all of its server names, including any aliases, local variations, and the numeric IP address. An example
         Request-Line would be:
      </p>
      <div id="rfc.figure.u.42"></div><pre class="text">    GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1
</pre><p id="rfc.section.5.1.2.p.7">To allow for transition to absoluteURIs in all requests in future versions of HTTP, all HTTP/1.1 servers <em class="bcp14">MUST</em> accept the absoluteURI form in requests, even though HTTP/1.1 clients will only generate them in requests to proxies.
      </p>
      <p id="rfc.section.5.1.2.p.8">The authority form is only used by the CONNECT method (<a href="#CONNECT" id="rfc.xref.CONNECT.2" title="CONNECT">Section&nbsp;9.9</a>).
      </p>
      <p id="rfc.section.5.1.2.p.9">The most common form of Request-URI is that used to identify a resource on an origin server or gateway. In this case the absolute
         path of the URI <em class="bcp14">MUST</em> be transmitted (see <a href="#general.syntax" title="General Syntax">Section&nbsp;3.2.1</a>, abs_path) as the Request-URI, and the network location of the URI (authority) <em class="bcp14">MUST</em> be transmitted in a Host header field. For example, a client wishing to retrieve the resource above directly from the origin
         server would create a TCP connection to port 80 of the host "www.w3.org" and send the lines:
      </p>
      <div id="rfc.figure.u.43"></div><pre class="text">    GET /pub/WWW/TheProject.html HTTP/1.1
    Host: www.w3.org
</pre><p id="rfc.section.5.1.2.p.11">followed by the remainder of the Request. Note that the absolute path cannot be empty; if none is present in the original
         URI, it <em class="bcp14">MUST</em> be given as "/" (the server root).
      </p>
      <p id="rfc.section.5.1.2.p.12">The Request-URI is transmitted in the format specified in <a href="#general.syntax" title="General Syntax">Section&nbsp;3.2.1</a>. If the Request-URI is encoded using the "% HEX HEX" encoding <a href="#RFC2396" id="rfc.xref.RFC2396.3"><cite title="Uniform Resource Identifiers (URI): Generic Syntax">[RFC2396]</cite></a>, the origin server <em class="bcp14">MUST</em> decode the Request-URI in order to properly interpret the request. Servers <em class="bcp14">SHOULD</em> respond to invalid Request-URIs with an appropriate status code.
      </p>
      <p id="rfc.section.5.1.2.p.13">A transparent proxy <em class="bcp14">MUST NOT</em> rewrite the "abs_path" part of the received Request-URI when forwarding it to the next inbound server, except as noted above
         to replace a null abs_path with "/".
      </p>
      <p id="rfc.section.5.1.2.p.14"> </p>
      <dl class="empty">
         <dd> <b>Note:</b> The "no rewrite" rule prevents the proxy from changing the meaning of the request when the origin server is improperly using
            a non-reserved URI character for a reserved purpose. Implementors should be aware that some pre-HTTP/1.1 proxies have been
            known to rewrite the Request-URI.
         </dd>
      </dl>
      <h2 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2</a>&nbsp;<a id="the.resource.identified.by.a.request" href="#the.resource.identified.by.a.request">The Resource Identified by a Request</a></h2>
      <p id="rfc.section.5.2.p.1">The exact resource identified by an Internet request is determined by examining both the Request-URI and the Host header field.</p>
      <p id="rfc.section.5.2.p.2">An origin server that does not allow resources to differ by the requested host <em class="bcp14">MAY</em> ignore the Host header field value when determining the resource identified by an HTTP/1.1 request. (But see <a href="#changes.to.simplify.multi-homed.web.servers.and.conserve.ip.addresses" title="Changes to Simplify Multi-homed Web Servers and Conserve IP Addresses">Appendix&nbsp;19.6.1.1</a> for other requirements on Host support in HTTP/1.1.)
      </p>
      <p id="rfc.section.5.2.p.3">An origin server that does differentiate resources based on the host requested (sometimes referred to as virtual hosts or
         vanity host names) <em class="bcp14">MUST</em> use the following rules for determining the requested resource on an HTTP/1.1 request: 
      </p>
      <ol>
         <li>If Request-URI is an absoluteURI, the host is part of the Request-URI. Any Host header field value in the request <em class="bcp14">MUST</em> be ignored.
         </li>
         <li>If the Request-URI is not an absoluteURI, and the request includes a Host header field, the host is determined by the Host
            header field value.
         </li>
         <li>If the host as determined by rule 1 or 2 is not a valid host on the server, the response <em class="bcp14">MUST</em> be a 400 (Bad Request) error message.
         </li>
      </ol>
      <p id="rfc.section.5.2.p.4">Recipients of an HTTP/1.0 request that lacks a Host header field <em class="bcp14">MAY</em> attempt to use heuristics (e.g., examination of the URI path for something unique to a particular host) in order to determine
         what exact resource is being requested.
      </p>
      <h2 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3</a>&nbsp;<a id="request.header.fields" href="#request.header.fields">Request Header Fields</a></h2>
      <p id="rfc.section.5.3.p.1">The request-header fields allow the client to pass additional information about the request, and about the client itself,
         to the server. These fields act as request modifiers, with semantics equivalent to the parameters on a programming language
         method invocation.
      </p>
      <div id="rfc.figure.u.44"></div><pre class="inline"><span id="rfc.iref.g.84"></span>    request-header = Accept                   ; <a href="#header.accept" id="rfc.xref.header.accept.2" title="Accept">Section&nbsp;14.1</a>
                   | Accept-Charset           ; <a href="#header.accept-charset" id="rfc.xref.header.accept-charset.1" title="Accept-Charset">Section&nbsp;14.2</a>
                   | Accept-Encoding          ; <a href="#header.accept-encoding" id="rfc.xref.header.accept-encoding.2" title="Accept-Encoding">Section&nbsp;14.3</a>
                   | Accept-Language          ; <a href="#header.accept-language" id="rfc.xref.header.accept-language.1" title="Accept-Language">Section&nbsp;14.4</a>
                   | Authorization            ; <a href="#header.authorization" id="rfc.xref.header.authorization.1" title="Authorization">Section&nbsp;14.8</a>
                   | Expect                   ; <a href="#header.expect" id="rfc.xref.header.expect.1" title="Expect">Section&nbsp;14.20</a>
                   | From                     ; <a href="#header.from" id="rfc.xref.header.from.1" title="From">Section&nbsp;14.22</a>
                   | Host                     ; <a href="#header.host" id="rfc.xref.header.host.1" title="Host">Section&nbsp;14.23</a>
                   | If-Match                 ; <a href="#header.if-match" id="rfc.xref.header.if-match.2" title="If-Match">Section&nbsp;14.24</a>
                   | If-Modified-Since        ; <a href="#header.if-modified-since" id="rfc.xref.header.if-modified-since.1" title="If-Modified-Since">Section&nbsp;14.25</a>
                   | If-None-Match            ; <a href="#header.if-none-match" id="rfc.xref.header.if-none-match.2" title="If-None-Match">Section&nbsp;14.26</a>
                   | If-Range                 ; <a href="#header.if-range" id="rfc.xref.header.if-range.2" title="If-Range">Section&nbsp;14.27</a>
                   | If-Unmodified-Since      ; <a href="#header.if-unmodified-since" id="rfc.xref.header.if-unmodified-since.1" title="If-Unmodified-Since">Section&nbsp;14.28</a>
                   | Max-Forwards             ; <a href="#header.max-forwards" id="rfc.xref.header.max-forwards.1" title="Max-Forwards">Section&nbsp;14.31</a>
                   | Proxy-Authorization      ; <a href="#header.proxy-authorization" id="rfc.xref.header.proxy-authorization.1" title="Proxy-Authorization">Section&nbsp;14.34</a>
                   | Range                    ; <a href="#header.range" id="rfc.xref.header.range.2" title="Range">Section&nbsp;14.35</a>
                   | Referer                  ; <a href="#header.referer" id="rfc.xref.header.referer.1" title="Referer">Section&nbsp;14.36</a>
                   | TE                       ; <a href="#header.te" id="rfc.xref.header.te.3" title="TE">Section&nbsp;14.39</a>
                   | User-Agent               ; <a href="#header.user-agent" id="rfc.xref.header.user-agent.1" title="User-Agent">Section&nbsp;14.43</a>
</pre><p id="rfc.section.5.3.p.3">Request-header field names can be extended reliably only in combination with a change in the protocol version. However, new
         or experimental header fields <em class="bcp14">MAY</em> be given the semantics of request-header fields if all parties in the communication recognize them to be request-header fields.
         Unrecognized header fields are treated as entity-header fields.
      </p>
      <h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a>&nbsp;<a id="response" href="#response">Response</a></h1>
      <p id="rfc.section.6.p.1">After receiving and interpreting a request message, a server responds with an HTTP response message.</p>
      <div id="rfc.figure.u.45"></div><pre class="inline"><span id="rfc.iref.g.85"></span>    Response      = Status-Line               ; <a href="#status-line" title="Status-Line">Section&nbsp;6.1</a>
                    *(( general-header        ; <a href="#general.header.fields" title="General Header Fields">Section&nbsp;4.5</a>
                     | response-header        ; <a href="#response.header.fields" title="Response Header Fields">Section&nbsp;6.2</a>
                     | entity-header ) CRLF)  ; <a href="#entity.header.fields" title="Entity Header Fields">Section&nbsp;7.1</a>
                    CRLF
                    [ message-body ]          ; <a href="#entity.body" title="Entity Body">Section&nbsp;7.2</a>
</pre><h2 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1</a>&nbsp;<a id="status-line" href="#status-line">Status-Line</a></h2>
      <p id="rfc.section.6.1.p.1">The first line of a Response message is the Status-Line, consisting of the protocol version followed by a numeric status code
         and its associated textual phrase, with each element separated by SP characters. No CR or LF is allowed except in the final
         CRLF sequence.
      </p>
      <div id="rfc.figure.u.46"></div><pre class="inline"><span id="rfc.iref.g.86"></span>    Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
</pre><h3 id="rfc.section.6.1.1"><a href="#rfc.section.6.1.1">6.1.1</a>&nbsp;<a id="status.code.and.reason.phrase" href="#status.code.and.reason.phrase">Status Code and Reason Phrase</a></h3>
      <p id="rfc.section.6.1.1.p.1">The Status-Code element is a 3-digit integer result code of the attempt to understand and satisfy the request. These codes
         are fully defined in <a href="#status.codes" title="Status Code Definitions">Section&nbsp;10</a>. The Reason-Phrase is intended to give a short textual description of the Status-Code. The Status-Code is intended for use
         by automata and the Reason-Phrase is intended for the human user. The client is not required to examine or display the Reason-Phrase.
      </p>
      <p id="rfc.section.6.1.1.p.2">The first digit of the Status-Code defines the class of response. The last two digits do not have any categorization role.
         There are 5 values for the first digit: 
      </p>
      <ul>
         <li>1xx: Informational - Request received, continuing process</li>
         <li>2xx: Success - The action was successfully received, understood, and accepted</li>
         <li>3xx: Redirection - Further action must be taken in order to complete the request</li>
         <li>4xx: Client Error - The request contains bad syntax or cannot be fulfilled</li>
         <li>5xx: Server Error - The server failed to fulfill an apparently valid request</li>
      </ul>
      <p id="rfc.section.6.1.1.p.3">The individual values of the numeric status codes defined for HTTP/1.1, and an example set of corresponding Reason-Phrase's,
         are presented below. The reason phrases listed here are only recommendations -- they <em class="bcp14">MAY</em> be replaced by local equivalents without affecting the protocol.
      </p>
      <div id="rfc.figure.u.47"></div><pre class="inline"><span id="rfc.iref.g.87"></span><span id="rfc.iref.g.88"></span><span id="rfc.iref.g.89"></span>   Status-Code    =
         "100"  ; <a href="#status.100" id="rfc.xref.status.100.1" title="100 Continue">Section&nbsp;10.1.1</a>: Continue
       | "101"  ; <a href="#status.101" id="rfc.xref.status.101.1" title="101 Switching Protocols">Section&nbsp;10.1.2</a>: Switching Protocols
       | "200"  ; <a href="#status.200" id="rfc.xref.status.200.1" title="200 OK">Section&nbsp;10.2.1</a>: OK
       | "201"  ; <a href="#status.201" id="rfc.xref.status.201.1" title="201 Created">Section&nbsp;10.2.2</a>: Created
       | "202"  ; <a href="#status.202" id="rfc.xref.status.202.1" title="202 Accepted">Section&nbsp;10.2.3</a>: Accepted
       | "203"  ; <a href="#status.203" id="rfc.xref.status.203.1" title="203 Non-Authoritative Information">Section&nbsp;10.2.4</a>: Non-Authoritative Information
       | "204"  ; <a href="#status.204" id="rfc.xref.status.204.1" title="204 No Content">Section&nbsp;10.2.5</a>: No Content
       | "205"  ; <a href="#status.205" id="rfc.xref.status.205.1" title="205 Reset Content">Section&nbsp;10.2.6</a>: Reset Content
       | "206"  ; <a href="#status.206" id="rfc.xref.status.206.1" title="206 Partial Content">Section&nbsp;10.2.7</a>: Partial Content
       | "300"  ; <a href="#status.300" id="rfc.xref.status.300.1" title="300 Multiple Choices">Section&nbsp;10.3.1</a>: Multiple Choices
       | "301"  ; <a href="#status.301" id="rfc.xref.status.301.1" title="301 Moved Permanently">Section&nbsp;10.3.2</a>: Moved Permanently
       | "302"  ; <a href="#status.302" id="rfc.xref.status.302.1" title="302 Found">Section&nbsp;10.3.3</a>: Found
       | "303"  ; <a href="#status.303" id="rfc.xref.status.303.1" title="303 See Other">Section&nbsp;10.3.4</a>: See Other
       | "304"  ; <a href="#status.304" id="rfc.xref.status.304.1" title="304 Not Modified">Section&nbsp;10.3.5</a>: Not Modified
       | "305"  ; <a href="#status.305" id="rfc.xref.status.305.1" title="305 Use Proxy">Section&nbsp;10.3.6</a>: Use Proxy
       | "307"  ; <a href="#status.307" id="rfc.xref.status.307.1" title="307 Temporary Redirect">Section&nbsp;10.3.8</a>: Temporary Redirect
       | "400"  ; <a href="#status.400" id="rfc.xref.status.400.1" title="400 Bad Request">Section&nbsp;10.4.1</a>: Bad Request
       | "401"  ; <a href="#status.401" id="rfc.xref.status.401.1" title="401 Unauthorized">Section&nbsp;10.4.2</a>: Unauthorized
       | "402"  ; <a href="#status.402" id="rfc.xref.status.402.1" title="402 Payment Required">Section&nbsp;10.4.3</a>: Payment Required
       | "403"  ; <a href="#status.403" id="rfc.xref.status.403.1" title="403 Forbidden">Section&nbsp;10.4.4</a>: Forbidden
       | "404"  ; <a href="#status.404" id="rfc.xref.status.404.1" title="404 Not Found">Section&nbsp;10.4.5</a>: Not Found
       | "405"  ; <a href="#status.405" id="rfc.xref.status.405.1" title="405 Method Not Allowed">Section&nbsp;10.4.6</a>: Method Not Allowed
       | "406"  ; <a href="#status.406" id="rfc.xref.status.406.1" title="406 Not Acceptable">Section&nbsp;10.4.7</a>: Not Acceptable
       | "407"  ; <a href="#status.407" id="rfc.xref.status.407.1" title="407 Proxy Authentication Required">Section&nbsp;10.4.8</a>: Proxy Authentication Required
       | "408"  ; <a href="#status.408" id="rfc.xref.status.408.1" title="408 Request Timeout">Section&nbsp;10.4.9</a>: Request Time-out
       | "409"  ; <a href="#status.409" id="rfc.xref.status.409.1" title="409 Conflict">Section&nbsp;10.4.10</a>: Conflict
       | "410"  ; <a href="#status.410" id="rfc.xref.status.410.1" title="410 Gone">Section&nbsp;10.4.11</a>: Gone
       | "411"  ; <a href="#status.411" id="rfc.xref.status.411.1" title="411 Length Required">Section&nbsp;10.4.12</a>: Length Required
       | "412"  ; <a href="#status.412" id="rfc.xref.status.412.1" title="412 Precondition Failed">Section&nbsp;10.4.13</a>: Precondition Failed
       | "413"  ; <a href="#status.413" id="rfc.xref.status.413.1" title="413 Request Entity Too Large">Section&nbsp;10.4.14</a>: Request Entity Too Large
       | "414"  ; <a href="#status.414" id="rfc.xref.status.414.2" title="414 Request-URI Too Long">Section&nbsp;10.4.15</a>: Request-URI Too Large
       | "415"  ; <a href="#status.415" id="rfc.xref.status.415.1" title="415 Unsupported Media Type">Section&nbsp;10.4.16</a>: Unsupported Media Type
       | "416"  ; <a href="#status.416" id="rfc.xref.status.416.1" title="416 Requested Range Not Satisfiable">Section&nbsp;10.4.17</a>: Requested range not satisfiable
       | "417"  ; <a href="#status.417" id="rfc.xref.status.417.1" title="417 Expectation Failed">Section&nbsp;10.4.18</a>: Expectation Failed
       | "500"  ; <a href="#status.500" id="rfc.xref.status.500.1" title="500 Internal Server Error">Section&nbsp;10.5.1</a>: Internal Server Error
       | "501"  ; <a href="#status.501" id="rfc.xref.status.501.1" title="501 Not Implemented">Section&nbsp;10.5.2</a>: Not Implemented
       | "502"  ; <a href="#status.502" id="rfc.xref.status.502.1" title="502 Bad Gateway">Section&nbsp;10.5.3</a>: Bad Gateway
       | "503"  ; <a href="#status.503" id="rfc.xref.status.503.1" title="503 Service Unavailable">Section&nbsp;10.5.4</a>: Service Unavailable
       | "504"  ; <a href="#status.504" id="rfc.xref.status.504.1" title="504 Gateway Timeout">Section&nbsp;10.5.5</a>: Gateway Time-out
       | "505"  ; <a href="#status.505" id="rfc.xref.status.505.1" title="505 HTTP Version Not Supported">Section&nbsp;10.5.6</a>: HTTP Version not supported
       | extension-code

   extension-code = 3DIGIT
   Reason-Phrase  = *&lt;TEXT, excluding CR, LF&gt;
</pre><p id="rfc.section.6.1.1.p.5">HTTP status codes are extensible. HTTP applications are not required to understand the meaning of all registered status codes,
         though such understanding is obviously desirable. However, applications <em class="bcp14">MUST</em> understand the class of any status code, as indicated by the first digit, and treat any unrecognized response as being equivalent
         to the x00 status code of that class, with the exception that an unrecognized response <em class="bcp14">MUST NOT</em> be cached. For example, if an unrecognized status code of 431 is received by the client, it can safely assume that there was
         something wrong with its request and treat the response as if it had received a 400 status code. In such cases, user agents <em class="bcp14">SHOULD</em> present to the user the entity returned with the response, since that entity is likely to include human-readable information
         which will explain the unusual status.
      </p>
      <h2 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2</a>&nbsp;<a id="response.header.fields" href="#response.header.fields">Response Header Fields</a></h2>
      <p id="rfc.section.6.2.p.1">The response-header fields allow the server to pass additional information about the response which cannot be placed in the
         Status-Line. These header fields give information about the server and about further access to the resource identified by
         the Request-URI.
      </p>
      <div id="rfc.figure.u.48"></div><pre class="inline"><span id="rfc.iref.g.90"></span>    response-header = Accept-Ranges           ; <a href="#header.accept-ranges" id="rfc.xref.header.accept-ranges.1" title="Accept-Ranges">Section&nbsp;14.5</a>
                    | Age                     ; <a href="#header.age" id="rfc.xref.header.age.1" title="Age">Section&nbsp;14.6</a>
                    | ETag                    ; <a href="#header.etag" id="rfc.xref.header.etag.2" title="ETag">Section&nbsp;14.19</a>
                    | Location                ; <a href="#header.location" id="rfc.xref.header.location.1" title="Location">Section&nbsp;14.30</a>
                    | Proxy-Authenticate      ; <a href="#header.proxy-authenticate" id="rfc.xref.header.proxy-authenticate.1" title="Proxy-Authenticate">Section&nbsp;14.33</a>
                    | Retry-After             ; <a href="#header.retry-after" id="rfc.xref.header.retry-after.1" title="Retry-After">Section&nbsp;14.37</a>
                    | Server                  ; <a href="#header.server" id="rfc.xref.header.server.1" title="Server">Section&nbsp;14.38</a>
                    | Vary                    ; <a href="#header.vary" id="rfc.xref.header.vary.1" title="Vary">Section&nbsp;14.44</a>
                    | WWW-Authenticate        ; <a href="#header.www-authenticate" id="rfc.xref.header.www-authenticate.1" title="WWW-Authenticate">Section&nbsp;14.47</a>
</pre><p id="rfc.section.6.2.p.3">Response-header field names can be extended reliably only in combination with a change in the protocol version. However, new
         or experimental header fields <em class="bcp14">MAY</em> be given the semantics of response-header fields if all parties in the communication recognize them to be response-header
         fields. Unrecognized header fields are treated as entity-header fields.
      </p>
      <h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a>&nbsp;<a id="entity" href="#entity">Entity</a></h1>
      <p id="rfc.section.7.p.1">Request and Response messages <em class="bcp14">MAY</em> transfer an entity if not otherwise restricted by the request method or response status code. An entity consists of entity-header
         fields and an entity-body, although some responses will only include the entity-headers.
      </p>
      <p id="rfc.section.7.p.2">In this section, both sender and recipient refer to either the client or the server, depending on who sends and who receives
         the entity.
      </p>
      <h2 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1</a>&nbsp;<a id="entity.header.fields" href="#entity.header.fields">Entity Header Fields</a></h2>
      <p id="rfc.section.7.1.p.1">Entity-header fields define metainformation about the entity-body or, if no body is present, about the resource identified
         by the request. Some of this metainformation is <em class="bcp14">OPTIONAL</em>; some might be <em class="bcp14">REQUIRED</em> by portions of this specification.
      </p>
      <div id="rfc.figure.u.49"></div><pre class="inline"><span id="rfc.iref.g.91"></span><span id="rfc.iref.g.92"></span>    entity-header  = Allow                    ; <a href="#header.allow" id="rfc.xref.header.allow.2" title="Allow">Section&nbsp;14.7</a>
                   | Content-Encoding         ; <a href="#header.content-encoding" id="rfc.xref.header.content-encoding.2" title="Content-Encoding">Section&nbsp;14.11</a>
                   | Content-Language         ; <a href="#header.content-language" id="rfc.xref.header.content-language.1" title="Content-Language">Section&nbsp;14.12</a>
                   | Content-Length           ; <a href="#header.content-length" id="rfc.xref.header.content-length.2" title="Content-Length">Section&nbsp;14.13</a>
                   | Content-Location         ; <a href="#header.content-location" id="rfc.xref.header.content-location.1" title="Content-Location">Section&nbsp;14.14</a>
                   | Content-MD5              ; <a href="#header.content-md5" id="rfc.xref.header.content-md5.1" title="Content-MD5">Section&nbsp;14.15</a>
                   | Content-Range            ; <a href="#header.content-range" id="rfc.xref.header.content-range.3" title="Content-Range">Section&nbsp;14.16</a>
                   | Content-Type             ; <a href="#header.content-type" id="rfc.xref.header.content-type.2" title="Content-Type">Section&nbsp;14.17</a>
                   | Expires                  ; <a href="#header.expires" id="rfc.xref.header.expires.1" title="Expires">Section&nbsp;14.21</a>
                   | Last-Modified            ; <a href="#header.last-modified" id="rfc.xref.header.last-modified.1" title="Last-Modified">Section&nbsp;14.29</a>
                   | extension-header

    extension-header = message-header
</pre><p id="rfc.section.7.1.p.3">The extension-header mechanism allows additional entity-header fields to be defined without changing the protocol, but these
         fields cannot be assumed to be recognizable by the recipient. Unrecognized header fields <em class="bcp14">SHOULD</em> be ignored by the recipient and <em class="bcp14">MUST</em> be forwarded by transparent proxies.
      </p>
      <h2 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2</a>&nbsp;<a id="entity.body" href="#entity.body">Entity Body</a></h2>
      <p id="rfc.section.7.2.p.1">The entity-body (if any) sent with an HTTP request or response is in a format and encoding defined by the entity-header fields.</p>
      <div id="rfc.figure.u.50"></div><pre class="inline"><span id="rfc.iref.g.93"></span>    entity-body    = *OCTET
</pre><p id="rfc.section.7.2.p.3">An entity-body is only present in a message when a message-body is present, as described in <a href="#message.body" title="Message Body">Section&nbsp;4.3</a>. The entity-body is obtained from the message-body by decoding any Transfer-Encoding that might have been applied to ensure
         safe and proper transfer of the message.
      </p>
      <h3 id="rfc.section.7.2.1"><a href="#rfc.section.7.2.1">7.2.1</a>&nbsp;<a id="type" href="#type">Type</a></h3>
      <p id="rfc.section.7.2.1.p.1">When an entity-body is included with a message, the data type of that body is determined via the header fields Content-Type
         and Content-Encoding. These define a two-layer, ordered encoding model:
      </p>
      <div id="rfc.figure.u.51"></div><pre class="text">    entity-body := Content-Encoding( Content-Type( data ) )
</pre><p id="rfc.section.7.2.1.p.3">Content-Type specifies the media type of the underlying data. Content-Encoding may be used to indicate any additional content
         codings applied to the data, usually for the purpose of data compression, that are a property of the requested resource. There
         is no default encoding.
      </p>
      <p id="rfc.section.7.2.1.p.4">Any HTTP/1.1 message containing an entity-body <em class="bcp14">SHOULD</em> include a Content-Type header field defining the media type of that body. If and only if the media type is not given by a
         Content-Type field, the recipient <em class="bcp14">MAY</em> attempt to guess the media type via inspection of its content and/or the name extension(s) of the URI used to identify the
         resource. If the media type remains unknown, the recipient <em class="bcp14">SHOULD</em> treat it as type "application/octet-stream".
      </p>
      <h3 id="rfc.section.7.2.2"><a href="#rfc.section.7.2.2">7.2.2</a>&nbsp;<a id="entity.length" href="#entity.length">Entity Length</a></h3>
      <p id="rfc.section.7.2.2.p.1">The entity-length of a message is the length of the message-body before any transfer-codings have been applied. <a href="#message.length" title="Message Length">Section&nbsp;4.4</a> defines how the transfer-length of a message-body is determined.
      </p>
      <h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a>&nbsp;<a id="connections" href="#connections">Connections</a></h1>
      <h2 id="rfc.section.8.1"><a href="#rfc.section.8.1">8.1</a>&nbsp;<a id="persistent.connections" href="#persistent.connections">Persistent Connections</a></h2>
      <h3 id="rfc.section.8.1.1"><a href="#rfc.section.8.1.1">8.1.1</a>&nbsp;<a id="persistent.purpose" href="#persistent.purpose">Purpose</a></h3>
      <p id="rfc.section.8.1.1.p.1">Prior to persistent connections, a separate TCP connection was established to fetch each URL, increasing the load on HTTP
         servers and causing congestion on the Internet. The use of inline images and other associated data often require a client
         to make multiple requests of the same server in a short amount of time. Analysis of these performance problems and results
         from a prototype implementation are available <a href="#Pad1995" id="rfc.xref.Pad1995.1"><cite title="Improving HTTP Latency">[Pad1995]</cite></a>  <a href="#Spe" id="rfc.xref.Spe.1"><cite title="Analysis of HTTP Performance Problems">[Spe]</cite></a>. Implementation experience and measurements of actual HTTP/1.1 (RFC 2068) implementations show good results <a href="#Nie1997" id="rfc.xref.Nie1997.1"><cite title="Network Performance Effects of HTTP/1.1, CSS1, and PNG">[Nie1997]</cite></a>. Alternatives have also been explored, for example, T/TCP <a href="#Tou1998" id="rfc.xref.Tou1998.1"><cite title="Analysis of HTTP Performance">[Tou1998]</cite></a>.
      </p>
      <p id="rfc.section.8.1.1.p.2">Persistent HTTP connections have a number of advantages: </p>
      <ul>
         <li>By opening and closing fewer TCP connections, CPU time is saved in routers and hosts (clients, servers, proxies, gateways,
            tunnels, or caches), and memory used for TCP protocol control blocks can be saved in hosts.
         </li>
         <li>HTTP requests and responses can be pipelined on a connection. Pipelining allows a client to make multiple requests without
            waiting for each response, allowing a single TCP connection to be used much more efficiently, with much lower elapsed time.
         </li>
         <li>Network congestion is reduced by reducing the number of packets caused by TCP opens, and by allowing TCP sufficient time to
            determine the congestion state of the network.
         </li>
         <li>Latency on subsequent requests is reduced since there is no time spent in TCP's connection opening handshake.</li>
         <li>HTTP can evolve more gracefully, since errors can be reported without the penalty of closing the TCP connection. Clients using
            future versions of HTTP might optimistically try a new feature, but if communicating with an older server, retry with old
            semantics after an error is reported.
         </li>
      </ul>
      <p id="rfc.section.8.1.1.p.3">HTTP implementations <em class="bcp14">SHOULD</em> implement persistent connections.
      </p>
      <h3 id="rfc.section.8.1.2"><a href="#rfc.section.8.1.2">8.1.2</a>&nbsp;<a id="persistent.overall" href="#persistent.overall">Overall Operation</a></h3>
      <p id="rfc.section.8.1.2.p.1">A significant difference between HTTP/1.1 and earlier versions of HTTP is that persistent connections are the default behavior
         of any HTTP connection. That is, unless otherwise indicated, the client <em class="bcp14">SHOULD</em> assume that the server will maintain a persistent connection, even after error responses from the server.
      </p>
      <p id="rfc.section.8.1.2.p.2">Persistent connections provide a mechanism by which a client and a server can signal the close of a TCP connection. This signaling
         takes place using the Connection header field (<a href="#header.connection" id="rfc.xref.header.connection.2" title="Connection">Section&nbsp;14.10</a>). Once a close has been signaled, the client <em class="bcp14">MUST NOT</em> send any more requests on that connection.
      </p>
      <h4 id="rfc.section.8.1.2.1"><a href="#rfc.section.8.1.2.1">8.1.2.1</a>&nbsp;<a id="persistent.negotiation" href="#persistent.negotiation">Negotiation</a></h4>
      <p id="rfc.section.8.1.2.1.p.1">An HTTP/1.1 server <em class="bcp14">MAY</em> assume that a HTTP/1.1 client intends to maintain a persistent connection unless a Connection header including the connection-token
         "close" was sent in the request. If the server chooses to close the connection immediately after sending the response, it <em class="bcp14">SHOULD</em> send a Connection header including the connection-token close.
      </p>
      <p id="rfc.section.8.1.2.1.p.2">An HTTP/1.1 client <em class="bcp14">MAY</em> expect a connection to remain open, but would decide to keep it open based on whether the response from a server contains
         a Connection header with the connection-token close. In case the client does not want to maintain a connection for more than
         that request, it <em class="bcp14">SHOULD</em> send a Connection header including the connection-token close.
      </p>
      <p id="rfc.section.8.1.2.1.p.3">If either the client or the server sends the close token in the Connection header, that request becomes the last one for the
         connection.
      </p>
      <p id="rfc.section.8.1.2.1.p.4">Clients and servers <em class="bcp14">SHOULD NOT</em> assume that a persistent connection is maintained for HTTP versions less than 1.1 unless it is explicitly signaled. See <a href="#compatibility.with.http.1.0.persistent.connections" title="Compatibility with HTTP/1.0 Persistent Connections">Appendix&nbsp;19.6.2</a> for more information on backward compatibility with HTTP/1.0 clients.
      </p>
      <p id="rfc.section.8.1.2.1.p.5">In order to remain persistent, all messages on the connection <em class="bcp14">MUST</em> have a self-defined message length (i.e., one not defined by closure of the connection), as described in <a href="#message.length" title="Message Length">Section&nbsp;4.4</a>.
      </p>
      <h4 id="rfc.section.8.1.2.2"><a href="#rfc.section.8.1.2.2">8.1.2.2</a>&nbsp;<a id="pipelining" href="#pipelining">Pipelining</a></h4>
      <p id="rfc.section.8.1.2.2.p.1">A client that supports persistent connections <em class="bcp14">MAY</em> "pipeline" its requests (i.e., send multiple requests without waiting for each response). A server <em class="bcp14">MUST</em> send its responses to those requests in the same order that the requests were received.
      </p>
      <p id="rfc.section.8.1.2.2.p.2">Clients which assume persistent connections and pipeline immediately after connection establishment <em class="bcp14">SHOULD</em> be prepared to retry their connection if the first pipelined attempt fails. If a client does such a retry, it <em class="bcp14">MUST NOT</em> pipeline before it knows the connection is persistent. Clients <em class="bcp14">MUST</em> also be prepared to resend their requests if the server closes the connection before sending all of the corresponding responses.
      </p>
      <p id="rfc.section.8.1.2.2.p.3">Clients <em class="bcp14">SHOULD NOT</em> pipeline requests using non-idempotent methods or non-idempotent sequences of methods (see <a href="#idempotent.methods" title="Idempotent Methods">Section&nbsp;9.1.2</a>). Otherwise, a premature termination of the transport connection could lead to indeterminate results. A client wishing to
         send a non-idempotent request <em class="bcp14">SHOULD</em> wait to send that request until it has received the response status for the previous request.
      </p>
      <h3 id="rfc.section.8.1.3"><a href="#rfc.section.8.1.3">8.1.3</a>&nbsp;<a id="persistent.proxy" href="#persistent.proxy">Proxy Servers</a></h3>
      <p id="rfc.section.8.1.3.p.1">It is especially important that proxies correctly implement the properties of the Connection header field as specified in <a href="#header.connection" id="rfc.xref.header.connection.3" title="Connection">Section&nbsp;14.10</a>.
      </p>
      <p id="rfc.section.8.1.3.p.2">The proxy server <em class="bcp14">MUST</em> signal persistent connections separately with its clients and the origin servers (or other proxy servers) that it connects
         to. Each persistent connection applies to only one transport link.
      </p>
      <p id="rfc.section.8.1.3.p.3">A proxy server <em class="bcp14">MUST NOT</em> establish a HTTP/1.1 persistent connection with an HTTP/1.0 client (but see RFC 2068 <a href="#RFC2068" id="rfc.xref.RFC2068.3"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[RFC2068]</cite></a> for information and discussion of the problems with the Keep-Alive header implemented by many HTTP/1.0 clients).
      </p>
      <h3 id="rfc.section.8.1.4"><a href="#rfc.section.8.1.4">8.1.4</a>&nbsp;<a id="persistent.practical" href="#persistent.practical">Practical Considerations</a></h3>
      <p id="rfc.section.8.1.4.p.1">Servers will usually have some time-out value beyond which they will no longer maintain an inactive connection. Proxy servers
         might make this a higher value since it is likely that the client will be making more connections through the same server.
         The use of persistent connections places no requirements on the length (or existence) of this time-out for either the client
         or the server.
      </p>
      <p id="rfc.section.8.1.4.p.2">When a client or server wishes to time-out it <em class="bcp14">SHOULD</em> issue a graceful close on the transport connection. Clients and servers <em class="bcp14">SHOULD</em> both constantly watch for the other side of the transport close, and respond to it as appropriate. If a client or server does
         not detect the other side's close promptly it could cause unnecessary resource drain on the network.
      </p>
      <p id="rfc.section.8.1.4.p.3">A client, server, or proxy <em class="bcp14">MAY</em> close the transport connection at any time. For example, a client might have started to send a new request at the same time
         that the server has decided to close the "idle" connection. From the server's point of view, the connection is being closed
         while it was idle, but from the client's point of view, a request is in progress.
      </p>
      <p id="rfc.section.8.1.4.p.4">This means that clients, servers, and proxies <em class="bcp14">MUST</em> be able to recover from asynchronous close events. Client software <em class="bcp14">SHOULD</em> reopen the transport connection and retransmit the aborted sequence of requests without user interaction so long as the request
         sequence is idempotent (see <a href="#idempotent.methods" title="Idempotent Methods">Section&nbsp;9.1.2</a>). Non-idempotent methods or sequences <em class="bcp14">MUST NOT</em> be automatically retried, although user agents <em class="bcp14">MAY</em> offer a human operator the choice of retrying the request(s). Confirmation by user-agent software with semantic understanding
         of the application <em class="bcp14">MAY</em> substitute for user confirmation. The automatic retry <em class="bcp14">SHOULD NOT</em> be repeated if the second sequence of requests fails.
      </p>
      <p id="rfc.section.8.1.4.p.5">Servers <em class="bcp14">SHOULD</em> always respond to at least one request per connection, if at all possible. Servers <em class="bcp14">SHOULD NOT</em> close a connection in the middle of transmitting a response, unless a network or client failure is suspected.
      </p>
      <p id="rfc.section.8.1.4.p.6">Clients that use persistent connections <em class="bcp14">SHOULD</em> limit the number of simultaneous connections that they maintain to a given server. A single-user client <em class="bcp14">SHOULD NOT</em> maintain more than 2 connections with any server or proxy. A proxy <em class="bcp14">SHOULD</em> use up to 2*N connections to another server or proxy, where N is the number of simultaneously active users. These guidelines
         are intended to improve HTTP response times and avoid congestion.
      </p>
      <h2 id="rfc.section.8.2"><a href="#rfc.section.8.2">8.2</a>&nbsp;<a id="message.transmission.requirements" href="#message.transmission.requirements">Message Transmission Requirements</a></h2>
      <h3 id="rfc.section.8.2.1"><a href="#rfc.section.8.2.1">8.2.1</a>&nbsp;<a id="persistent.flow" href="#persistent.flow">Persistent Connections and Flow Control</a></h3>
      <p id="rfc.section.8.2.1.p.1">HTTP/1.1 servers <em class="bcp14">SHOULD</em> maintain persistent connections and use TCP's flow control mechanisms to resolve temporary overloads, rather than terminating
         connections with the expectation that clients will retry. The latter technique can exacerbate network congestion.
      </p>
      <h3 id="rfc.section.8.2.2"><a href="#rfc.section.8.2.2">8.2.2</a>&nbsp;<a id="persistent.monitor" href="#persistent.monitor">Monitoring Connections for Error Status Messages</a></h3>
      <p id="rfc.section.8.2.2.p.1">An HTTP/1.1 (or later) client sending a message-body <em class="bcp14">SHOULD</em> monitor the network connection for an error status while it is transmitting the request. If the client sees an error status,
         it <em class="bcp14">SHOULD</em> immediately cease transmitting the body. If the body is being sent using a "chunked" encoding (<a href="#transfer.codings" title="Transfer Codings">Section&nbsp;3.6</a>), a zero length chunk and empty trailer <em class="bcp14">MAY</em> be used to prematurely mark the end of the message. If the body was preceded by a Content-Length header, the client <em class="bcp14">MUST</em> close the connection.
      </p>
      <h3 id="rfc.section.8.2.3"><a href="#rfc.section.8.2.3">8.2.3</a>&nbsp;<a id="use.of.the.100.status" href="#use.of.the.100.status">Use of the 100 (Continue) Status</a></h3>
      <p id="rfc.section.8.2.3.p.1">The purpose of the 100 (Continue) status (see <a href="#status.100" id="rfc.xref.status.100.2" title="100 Continue">Section&nbsp;10.1.1</a>) is to allow a client that is sending a request message with a request body to determine if the origin server is willing
         to accept the request (based on the request headers) before the client sends the request body. In some cases, it might either
         be inappropriate or highly inefficient for the client to send the body if the server will reject the message without looking
         at the body.
      </p>
      <p id="rfc.section.8.2.3.p.2">Requirements for HTTP/1.1 clients: </p>
      <ul>
         <li>If a client will wait for a 100 (Continue) response before sending the request body, it <em class="bcp14">MUST</em> send an Expect request-header field (<a href="#header.expect" id="rfc.xref.header.expect.2" title="Expect">Section&nbsp;14.20</a>) with the "100-continue" expectation.
         </li>
         <li>A client <em class="bcp14">MUST NOT</em> send an Expect request-header field (<a href="#header.expect" id="rfc.xref.header.expect.3" title="Expect">Section&nbsp;14.20</a>) with the "100-continue" expectation if it does not intend to send a request body.
         </li>
      </ul>
      <p id="rfc.section.8.2.3.p.3">Because of the presence of older implementations, the protocol allows ambiguous situations in which a client may send "Expect:
         100-continue" without receiving either a 417 (Expectation Failed) status or a 100 (Continue) status. Therefore, when a client
         sends this header field to an origin server (possibly via a proxy) from which it has never seen a 100 (Continue) status, the
         client <em class="bcp14">SHOULD NOT</em> wait for an indefinite period before sending the request body.
      </p>
      <p id="rfc.section.8.2.3.p.4">Requirements for HTTP/1.1 origin servers: </p>
      <ul>
         <li>Upon receiving a request which includes an Expect request-header field with the "100-continue" expectation, an origin server <em class="bcp14">MUST</em> either respond with 100 (Continue) status and continue to read from the input stream, or respond with a final status code.
            The origin server <em class="bcp14">MUST NOT</em> wait for the request body before sending the 100 (Continue) response. If it responds with a final status code, it <em class="bcp14">MAY</em> close the transport connection or it <em class="bcp14">MAY</em> continue to read and discard the rest of the request. It <em class="bcp14">MUST NOT</em> perform the requested method if it returns a final status code.
         </li>
         <li>An origin server <em class="bcp14">SHOULD NOT</em> send a 100 (Continue) response if the request message does not include an Expect request-header field with the "100-continue"
            expectation, and <em class="bcp14">MUST NOT</em> send a 100 (Continue) response if such a request comes from an HTTP/1.0 (or earlier) client. There is an exception to this
            rule: for compatibility with RFC 2068, a server <em class="bcp14">MAY</em> send a 100 (Continue) status in response to an HTTP/1.1 PUT or POST request that does not include an Expect request-header
            field with the "100-continue" expectation. This exception, the purpose of which is to minimize any client processing delays
            associated with an undeclared wait for 100 (Continue) status, applies only to HTTP/1.1 requests, and not to requests with
            any other HTTP-version value.
         </li>
         <li>An origin server <em class="bcp14">MAY</em> omit a 100 (Continue) response if it has already received some or all of the request body for the corresponding request.
         </li>
         <li>An origin server that sends a 100 (Continue) response <em class="bcp14">MUST</em> ultimately send a final status code, once the request body is received and processed, unless it terminates the transport connection
            prematurely.
         </li>
         <li>If an origin server receives a request that does not include an Expect request-header field with the "100-continue" expectation,
            the request includes a request body, and the server responds with a final status code before reading the entire request body
            from the transport connection, then the server <em class="bcp14">SHOULD NOT</em> close the transport connection until it has read the entire request, or until the client closes the connection. Otherwise,
            the client might not reliably receive the response message. However, this requirement is not be construed as preventing a
            server from defending itself against denial-of-service attacks, or from badly broken client implementations.
         </li>
      </ul>
      <p id="rfc.section.8.2.3.p.5">Requirements for HTTP/1.1 proxies: </p>
      <ul>
         <li>If a proxy receives a request that includes an Expect request-header field with the "100-continue" expectation, and the proxy
            either knows that the next-hop server complies with HTTP/1.1 or higher, or does not know the HTTP version of the next-hop
            server, it <em class="bcp14">MUST</em> forward the request, including the Expect header field.
         </li>
         <li>If the proxy knows that the version of the next-hop server is HTTP/1.0 or lower, it <em class="bcp14">MUST NOT</em> forward the request, and it <em class="bcp14">MUST</em> respond with a 417 (Expectation Failed) status.
         </li>
         <li>Proxies <em class="bcp14">SHOULD</em> maintain a cache recording the HTTP version numbers received from recently-referenced next-hop servers.
         </li>
         <li>A proxy <em class="bcp14">MUST NOT</em> forward a 100 (Continue) response if the request message was received from an HTTP/1.0 (or earlier) client and did not include
            an Expect request-header field with the "100-continue" expectation. This requirement overrides the general rule for forwarding
            of 1xx responses (see <a href="#status.1xx" title="Informational 1xx">Section&nbsp;10.1</a>).
         </li>
      </ul>
      <h3 id="rfc.section.8.2.4"><a href="#rfc.section.8.2.4">8.2.4</a>&nbsp;<a id="connection.premature" href="#connection.premature">Client Behavior if Server Prematurely Closes Connection</a></h3>
      <p id="rfc.section.8.2.4.p.1">If an HTTP/1.1 client sends a request which includes a request body, but which does not include an Expect request-header field
         with the "100-continue" expectation, and if the client is not directly connected to an HTTP/1.1 origin server, and if the
         client sees the connection close before receiving any status from the server, the client <em class="bcp14">SHOULD</em> retry the request. If the client does retry this request, it <em class="bcp14">MAY</em> use the following "binary exponential backoff" algorithm to be assured of obtaining a reliable response: 
      </p>
      <ol>
         <li>Initiate a new connection to the server</li>
         <li>Transmit the request-headers</li>
         <li>Initialize a variable R to the estimated round-trip time to the server (e.g., based on the time it took to establish the connection),
            or to a constant value of 5 seconds if the round-trip time is not available.
         </li>
         <li>Compute T = R * (2**N), where N is the number of previous retries of this request.</li>
         <li>Wait either for an error response from the server, or for T seconds (whichever comes first)</li>
         <li>If no error response is received, after T seconds transmit the body of the request.</li>
         <li>If client sees that the connection is closed prematurely, repeat from step 1 until the request is accepted, an error response
            is received, or the user becomes impatient and terminates the retry process.
         </li>
      </ol>
      <p id="rfc.section.8.2.4.p.2">If at any point an error status is received, the client </p>
      <ul>
         <li><em class="bcp14">SHOULD NOT</em> continue and
         </li>
         <li><em class="bcp14">SHOULD</em> close the connection if it has not completed sending the request message.
         </li>
      </ul>
      <h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a>&nbsp;<a id="method.definitions" href="#method.definitions">Method Definitions</a></h1>
      <p id="rfc.section.9.p.1">The set of common methods for HTTP/1.1 is defined below. Although this set can be expanded, additional methods cannot be assumed
         to share the same semantics for separately extended clients and servers. The Host request-header field (<a href="#header.host" id="rfc.xref.header.host.2" title="Host">Section&nbsp;14.23</a>) <em class="bcp14">MUST</em> accompany all HTTP/1.1 requests.
      </p>
      <h2 id="rfc.section.9.1"><a href="#rfc.section.9.1">9.1</a>&nbsp;<a id="safe.and.idempotent" href="#safe.and.idempotent">Safe and Idempotent Methods</a></h2>
      <h3 id="rfc.section.9.1.1"><a href="#rfc.section.9.1.1">9.1.1</a>&nbsp;<a id="safe.methods" href="#safe.methods">Safe Methods</a></h3>
      <p id="rfc.section.9.1.1.p.1">Implementors should be aware that the software represents the user in their interactions over the Internet, and should be
         careful to allow the user to be aware of any actions they might take which may have an unexpected significance to themselves
         or others.
      </p>
      <p id="rfc.section.9.1.1.p.2">In particular, the convention has been established that the GET and HEAD methods <em class="bcp14">SHOULD NOT</em> have the significance of taking an action other than retrieval. These methods ought to be considered "safe". This allows user
         agents to represent other methods, such as POST, PUT and DELETE, in a special way, so that the user is made aware of the fact
         that a possibly unsafe action is being requested.
      </p>
      <p id="rfc.section.9.1.1.p.3">Naturally, it is not possible to ensure that the server does not generate side-effects as a result of performing a GET request;
         in fact, some dynamic resources consider that a feature. The important distinction here is that the user did not request the
         side-effects, so therefore cannot be held accountable for them.
      </p>
      <h3 id="rfc.section.9.1.2"><a href="#rfc.section.9.1.2">9.1.2</a>&nbsp;<a id="idempotent.methods" href="#idempotent.methods">Idempotent Methods</a></h3>
      <p id="rfc.section.9.1.2.p.1">Methods can also have the property of "idempotence" in that (aside from error or expiration issues) the side-effects of N
         &gt; 0 identical requests is the same as for a single request. The methods GET, HEAD, PUT and DELETE share this property. Also,
         the methods OPTIONS and TRACE <em class="bcp14">SHOULD NOT</em> have side effects, and so are inherently idempotent.
      </p>
      <p id="rfc.section.9.1.2.p.2">However, it is possible that a sequence of several requests is non-idempotent, even if all of the methods executed in that
         sequence are idempotent. (A sequence is idempotent if a single execution of the entire sequence always yields a result that
         is not changed by a reexecution of all, or part, of that sequence.) For example, a sequence is non-idempotent if its result
         depends on a value that is later modified in the same sequence.
      </p>
      <p id="rfc.section.9.1.2.p.3">A sequence that never has side effects is idempotent, by definition (provided that no concurrent operations are being executed
         on the same set of resources).
      </p>
      <div id="rfc.iref.o.3"></div>
      <div id="rfc.iref.m.2"></div>
      <h2 id="rfc.section.9.2"><a href="#rfc.section.9.2">9.2</a>&nbsp;<a id="OPTIONS" href="#OPTIONS">OPTIONS</a></h2>
      <p id="rfc.section.9.2.p.1">The OPTIONS method represents a request for information about the communication options available on the request/response
         chain identified by the Request-URI. This method allows the client to determine the options and/or requirements associated
         with a resource, or the capabilities of a server, without implying a resource action or initiating a resource retrieval.
      </p>
      <p id="rfc.section.9.2.p.2">Responses to this method are not cacheable.</p>
      <p id="rfc.section.9.2.p.3">If the OPTIONS request includes an entity-body (as indicated by the presence of Content-Length or Transfer-Encoding), then
         the media type <em class="bcp14">MUST</em> be indicated by a Content-Type field. Although this specification does not define any use for such a body, future extensions
         to HTTP might use the OPTIONS body to make more detailed queries on the server. A server that does not support such an extension <em class="bcp14">MAY</em> discard the request body.
      </p>
      <p id="rfc.section.9.2.p.4">If the Request-URI is an asterisk ("*"), the OPTIONS request is intended to apply to the server in general rather than to
         a specific resource. Since a server's communication options typically depend on the resource, the "*" request is only useful
         as a "ping" or "no-op" type of method; it does nothing beyond allowing the client to test the capabilities of the server.
         For example, this can be used to test a proxy for HTTP/1.1 compliance (or lack thereof).
      </p>
      <p id="rfc.section.9.2.p.5">If the Request-URI is not an asterisk, the OPTIONS request applies only to the options that are available when communicating
         with that resource.
      </p>
      <p id="rfc.section.9.2.p.6">A 200 response <em class="bcp14">SHOULD</em> include any header fields that indicate optional features implemented by the server and applicable to that resource (e.g.,
         Allow), possibly including extensions not defined by this specification. The response body, if any, <em class="bcp14">SHOULD</em> also include information about the communication options. The format for such a body is not defined by this specification,
         but might be defined by future extensions to HTTP. Content negotiation <em class="bcp14">MAY</em> be used to select the appropriate response format. If no response body is included, the response <em class="bcp14">MUST</em> include a Content-Length field with a field-value of "0".
      </p>
      <p id="rfc.section.9.2.p.7">The Max-Forwards request-header field <em class="bcp14">MAY</em> be used to target a specific proxy in the request chain. When a proxy receives an OPTIONS request on an absoluteURI for which
         request forwarding is permitted, the proxy <em class="bcp14">MUST</em> check for a Max-Forwards field. If the Max-Forwards field-value is zero ("0"), the proxy <em class="bcp14">MUST NOT</em> forward the message; instead, the proxy <em class="bcp14">SHOULD</em> respond with its own communication options. If the Max-Forwards field-value is an integer greater than zero, the proxy <em class="bcp14">MUST</em> decrement the field-value when it forwards the request. If no Max-Forwards field is present in the request, then the forwarded
         request <em class="bcp14">MUST NOT</em> include a Max-Forwards field.
      </p>
      <div id="rfc.iref.g.94"></div>
      <div id="rfc.iref.m.3"></div>
      <h2 id="rfc.section.9.3"><a href="#rfc.section.9.3">9.3</a>&nbsp;<a id="GET" href="#GET">GET</a></h2>
      <p id="rfc.section.9.3.p.1">The GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI. If the Request-URI
         refers to a data-producing process, it is the produced data which shall be returned as the entity in the response and not
         the source text of the process, unless that text happens to be the output of the process.
      </p>
      <p id="rfc.section.9.3.p.2">The semantics of the GET method change to a "conditional GET" if the request message includes an If-Modified-Since, If-Unmodified-Since,
         If-Match, If-None-Match, or If-Range header field. A conditional GET method requests that the entity be transferred only under
         the circumstances described by the conditional header field(s). The conditional GET method is intended to reduce unnecessary
         network usage by allowing cached entities to be refreshed without requiring multiple requests or transferring data already
         held by the client.
      </p>
      <p id="rfc.section.9.3.p.3">The semantics of the GET method change to a "partial GET" if the request message includes a Range header field. A partial
         GET requests that only part of the entity be transferred, as described in <a href="#header.range" id="rfc.xref.header.range.3" title="Range">Section&nbsp;14.35</a>. The partial GET method is intended to reduce unnecessary network usage by allowing partially-retrieved entities to be completed
         without transferring data already held by the client.
      </p>
      <p id="rfc.section.9.3.p.4">The response to a GET request is cacheable if and only if it meets the requirements for HTTP caching described in <a href="#caching" title="Caching in HTTP">Section&nbsp;13</a>.
      </p>
      <p id="rfc.section.9.3.p.5">See <a href="#encoding.sensitive.information.in.uris" title="Encoding Sensitive Information in URI's">Section&nbsp;15.1.3</a> for security considerations when used for forms.
      </p>
      <div id="rfc.iref.h.2"></div>
      <div id="rfc.iref.m.4"></div>
      <h2 id="rfc.section.9.4"><a href="#rfc.section.9.4">9.4</a>&nbsp;<a id="HEAD" href="#HEAD">HEAD</a></h2>
      <p id="rfc.section.9.4.p.1">The HEAD method is identical to GET except that the server <em class="bcp14">MUST NOT</em> return a message-body in the response. The metainformation contained in the HTTP headers in response to a HEAD request <em class="bcp14">SHOULD</em> be identical to the information sent in response to a GET request. This method can be used for obtaining metainformation about
         the entity implied by the request without transferring the entity-body itself. This method is often used for testing hypertext
         links for validity, accessibility, and recent modification.
      </p>
      <p id="rfc.section.9.4.p.2">The response to a HEAD request <em class="bcp14">MAY</em> be cacheable in the sense that the information contained in the response <em class="bcp14">MAY</em> be used to update a previously cached entity from that resource. If the new field values indicate that the cached entity differs
         from the current entity (as would be indicated by a change in Content-Length, Content-MD5, ETag or Last-Modified), then the
         cache <em class="bcp14">MUST</em> treat the cache entry as stale.
      </p>
      <div id="rfc.iref.p.2"></div>
      <div id="rfc.iref.m.5"></div>
      <h2 id="rfc.section.9.5"><a href="#rfc.section.9.5">9.5</a>&nbsp;<a id="POST" href="#POST">POST</a></h2>
      <p id="rfc.section.9.5.p.1">The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of
         the resource identified by the Request-URI in the Request-Line. POST is designed to allow a uniform method to cover the following
         functions: 
      </p>
      <ul>
         <li>Annotation of existing resources;</li>
         <li>Posting a message to a bulletin board, newsgroup, mailing list, or similar group of articles;</li>
         <li>Providing a block of data, such as the result of submitting a form, to a data-handling process;</li>
         <li>Extending a database through an append operation.</li>
      </ul>
      <p id="rfc.section.9.5.p.2">The actual function performed by the POST method is determined by the server and is usually dependent on the Request-URI.
         The posted entity is subordinate to that URI in the same way that a file is subordinate to a directory containing it, a news
         article is subordinate to a newsgroup to which it is posted, or a record is subordinate to a database.
      </p>
      <p id="rfc.section.9.5.p.3">The action performed by the POST method might not result in a resource that can be identified by a URI. In this case, either
         200 (OK) or 204 (No Content) is the appropriate response status, depending on whether or not the response includes an entity
         that describes the result.
      </p>
      <p id="rfc.section.9.5.p.4">If a resource has been created on the origin server, the response <em class="bcp14">SHOULD</em> be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location
         header (see <a href="#header.location" id="rfc.xref.header.location.2" title="Location">Section&nbsp;14.30</a>).
      </p>
      <p id="rfc.section.9.5.p.5">Responses to this method are not cacheable, unless the response includes appropriate Cache-Control or Expires header fields.
         However, the 303 (See Other) response can be used to direct the user agent to retrieve a cacheable resource.
      </p>
      <p id="rfc.section.9.5.p.6">POST requests <em class="bcp14">MUST</em> obey the message transmission requirements set out in <a href="#message.transmission.requirements" title="Message Transmission Requirements">Section&nbsp;8.2</a>.
      </p>
      <p id="rfc.section.9.5.p.7">See <a href="#encoding.sensitive.information.in.uris" title="Encoding Sensitive Information in URI's">Section&nbsp;15.1.3</a> for security considerations.
      </p>
      <div id="rfc.iref.p.3"></div>
      <div id="rfc.iref.m.6"></div>
      <h2 id="rfc.section.9.6"><a href="#rfc.section.9.6">9.6</a>&nbsp;<a id="PUT" href="#PUT">PUT</a></h2>
      <p id="rfc.section.9.6.p.1">The PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an
         already existing resource, the enclosed entity <em class="bcp14">SHOULD</em> be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing
         resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create
         the resource with that URI. If a new resource is created, the origin server <em class="bcp14">MUST</em> inform the user agent via the 201 (Created) response. If an existing resource is modified, either the 200 (OK) or 204 (No
         Content) response codes <em class="bcp14">SHOULD</em> be sent to indicate successful completion of the request. If the resource could not be created or modified with the Request-URI,
         an appropriate error response <em class="bcp14">SHOULD</em> be given that reflects the nature of the problem. The recipient of the entity <em class="bcp14">MUST NOT</em> ignore any Content-* (e.g. Content-Range) headers that it does not understand or implement and <em class="bcp14">MUST</em> return a 501 (Not Implemented) response in such cases.
      </p>
      <p id="rfc.section.9.6.p.2">If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries <em class="bcp14">SHOULD</em> be treated as stale. Responses to this method are not cacheable.
      </p>
      <p id="rfc.section.9.6.p.3">The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI. The
         URI in a POST request identifies the resource that will handle the enclosed entity. That resource might be a data-accepting
         process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a PUT request
         identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server <em class="bcp14">MUST NOT</em> attempt to apply the request to some other resource. If the server desires that the request be applied to a different URI,
         it <em class="bcp14">MUST</em> send a 301 (Moved Permanently) response; the user agent <em class="bcp14">MAY</em> then make its own decision regarding whether or not to redirect the request.
      </p>
      <p id="rfc.section.9.6.p.4">A single resource <em class="bcp14">MAY</em> be identified by many different URIs. For example, an article might have a URI for identifying "the current version" which
         is separate from the URI identifying each particular version. In this case, a PUT request on a general URI might result in
         several other URIs being defined by the origin server.
      </p>
      <p id="rfc.section.9.6.p.5">HTTP/1.1 does not define how a PUT method affects the state of an origin server.</p>
      <p id="rfc.section.9.6.p.6">PUT requests <em class="bcp14">MUST</em> obey the message transmission requirements set out in <a href="#message.transmission.requirements" title="Message Transmission Requirements">Section&nbsp;8.2</a>.
      </p>
      <p id="rfc.section.9.6.p.7">Unless otherwise specified for a particular entity-header, the entity-headers in the PUT request <em class="bcp14">SHOULD</em> be applied to the resource created or modified by the PUT.
      </p>
      <div id="rfc.iref.d.3"></div>
      <div id="rfc.iref.m.7"></div>
      <h2 id="rfc.section.9.7"><a href="#rfc.section.9.7">9.7</a>&nbsp;<a id="DELETE" href="#DELETE">DELETE</a></h2>
      <p id="rfc.section.9.7.p.1">The DELETE method requests that the origin server delete the resource identified by the Request-URI. This method <em class="bcp14">MAY</em> be overridden by human intervention (or other means) on the origin server. The client cannot be guaranteed that the operation
         has been carried out, even if the status code returned from the origin server indicates that the action has been completed
         successfully. However, the server <em class="bcp14">SHOULD NOT</em> indicate success unless, at the time the response is given, it intends to delete the resource or move it to an inaccessible
         location.
      </p>
      <p id="rfc.section.9.7.p.2">A successful response <em class="bcp14">SHOULD</em> be 200 (OK) if the response includes an entity describing the status, 202 (Accepted) if the action has not yet been enacted,
         or 204 (No Content) if the action has been enacted but the response does not include an entity.
      </p>
      <p id="rfc.section.9.7.p.3">If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries <em class="bcp14">SHOULD</em> be treated as stale. Responses to this method are not cacheable.
      </p>
      <div id="rfc.iref.t.2"></div>
      <div id="rfc.iref.m.8"></div>
      <h2 id="rfc.section.9.8"><a href="#rfc.section.9.8">9.8</a>&nbsp;<a id="TRACE" href="#TRACE">TRACE</a></h2>
      <p id="rfc.section.9.8.p.1">The TRACE method is used to invoke a remote, application-layer loop-back of the request message. The final recipient of the
         request <em class="bcp14">SHOULD</em> reflect the message received back to the client as the entity-body of a 200 (OK) response. The final recipient is either the
         origin server or the first proxy or gateway to receive a Max-Forwards value of zero (0) in the request (see <a href="#header.max-forwards" id="rfc.xref.header.max-forwards.2" title="Max-Forwards">Section&nbsp;14.31</a>). A TRACE request <em class="bcp14">MUST NOT</em> include an entity.
      </p>
      <p id="rfc.section.9.8.p.2">TRACE allows the client to see what is being received at the other end of the request chain and use that data for testing
         or diagnostic information. The value of the Via header field (<a href="#header.via" id="rfc.xref.header.via.2" title="Via">Section&nbsp;14.45</a>) is of particular interest, since it acts as a trace of the request chain. Use of the Max-Forwards header field allows the
         client to limit the length of the request chain, which is useful for testing a chain of proxies forwarding messages in an
         infinite loop.
      </p>
      <p id="rfc.section.9.8.p.3">If the request is valid, the response <em class="bcp14">SHOULD</em> contain the entire request message in the entity-body, with a Content-Type of "message/http". Responses to this method <em class="bcp14">MUST NOT</em> be cached.
      </p>
      <div id="rfc.iref.c.7"></div>
      <div id="rfc.iref.m.9"></div>
      <h2 id="rfc.section.9.9"><a href="#rfc.section.9.9">9.9</a>&nbsp;<a id="CONNECT" href="#CONNECT">CONNECT</a></h2>
      <p id="rfc.section.9.9.p.1">This specification reserves the method name CONNECT for use with a proxy that can dynamically switch to being a tunnel (e.g.
         SSL tunneling <a href="#Luo1998" id="rfc.xref.Luo1998.1"><cite title="Tunneling TCP based protocols through Web proxy servers">[Luo1998]</cite></a>).
      </p>
      <h1 id="rfc.section.10"><a href="#rfc.section.10">10.</a>&nbsp;<a id="status.codes" href="#status.codes">Status Code Definitions</a></h1>
      <p id="rfc.section.10.p.1">Each Status-Code is described below, including a description of which method(s) it can follow and any metainformation required
         in the response.
      </p>
      <h2 id="rfc.section.10.1"><a href="#rfc.section.10.1">10.1</a>&nbsp;<a id="status.1xx" href="#status.1xx">Informational 1xx</a></h2>
      <p id="rfc.section.10.1.p.1">This class of status code indicates a provisional response, consisting only of the Status-Line and optional headers, and is
         terminated by an empty line. There are no required headers for this class of status code. Since HTTP/1.0 did not define any
         1xx status codes, servers <em class="bcp14">MUST NOT</em> send a 1xx response to an HTTP/1.0 client except under experimental conditions.
      </p>
      <p id="rfc.section.10.1.p.2">A client <em class="bcp14">MUST</em> be prepared to accept one or more 1xx status responses prior to a regular response, even if the client does not expect a 100
         (Continue) status message. Unexpected 1xx status responses <em class="bcp14">MAY</em> be ignored by a user agent.
      </p>
      <p id="rfc.section.10.1.p.3">Proxies <em class="bcp14">MUST</em> forward 1xx responses, unless the connection between the proxy and its client has been closed, or unless the proxy itself
         requested the generation of the 1xx response. (For example, if a proxy adds a "Expect: 100-continue" field when it forwards
         a request, then it need not forward the corresponding 100 (Continue) response(s).)
      </p>
      <div id="rfc.iref.142"></div>
      <div id="rfc.iref.s.4"></div>
      <h3 id="rfc.section.10.1.1"><a href="#rfc.section.10.1.1">10.1.1</a>&nbsp;<a id="status.100" href="#status.100">100 Continue</a></h3>
      <p id="rfc.section.10.1.1.p.1">The client <em class="bcp14">SHOULD</em> continue with its request. This interim response is used to inform the client that the initial part of the request has been
         received and has not yet been rejected by the server. The client <em class="bcp14">SHOULD</em> continue by sending the remainder of the request or, if the request has already been completed, ignore this response. The
         server <em class="bcp14">MUST</em> send a final response after the request has been completed. See <a href="#use.of.the.100.status" title="Use of the 100 (Continue) Status">Section&nbsp;8.2.3</a> for detailed discussion of the use and handling of this status code.
      </p>
      <div id="rfc.iref.143"></div>
      <div id="rfc.iref.s.5"></div>
      <h3 id="rfc.section.10.1.2"><a href="#rfc.section.10.1.2">10.1.2</a>&nbsp;<a id="status.101" href="#status.101">101 Switching Protocols</a></h3>
      <p id="rfc.section.10.1.2.p.1">The server understands and is willing to comply with the client's request, via the Upgrade message header field (<a href="#header.upgrade" id="rfc.xref.header.upgrade.2" title="Upgrade">Section&nbsp;14.42</a>), for a change in the application protocol being used on this connection. The server will switch protocols to those defined
         by the response's Upgrade header field immediately after the empty line which terminates the 101 response.
      </p>
      <p id="rfc.section.10.1.2.p.2">The protocol <em class="bcp14">SHOULD</em> be switched only when it is advantageous to do so. For example, switching to a newer version of HTTP is advantageous over
         older versions, and switching to a real-time, synchronous protocol might be advantageous when delivering resources that use
         such features.
      </p>
      <h2 id="rfc.section.10.2"><a href="#rfc.section.10.2">10.2</a>&nbsp;<a id="status.2xx" href="#status.2xx">Successful 2xx</a></h2>
      <p id="rfc.section.10.2.p.1">This class of status code indicates that the client's request was successfully received, understood, and accepted.</p>
      <div id="rfc.iref.144"></div>
      <div id="rfc.iref.s.6"></div>
      <h3 id="rfc.section.10.2.1"><a href="#rfc.section.10.2.1">10.2.1</a>&nbsp;<a id="status.200" href="#status.200">200 OK</a></h3>
      <p id="rfc.section.10.2.1.p.1">The request has succeeded. The information returned with the response is dependent on the method used in the request, for
         example: 
      </p>
      <dl>
         <dt>GET</dt>
         <dd>an entity corresponding to the requested resource is sent in the response;</dd>
         <dt>HEAD</dt>
         <dd>the entity-header fields corresponding to the requested resource are sent in the response without any message-body;</dd>
         <dt>POST</dt>
         <dd>an entity describing or containing the result of the action;</dd>
         <dt>TRACE</dt>
         <dd>an entity containing the request message as received by the end server.</dd>
      </dl>
      <div id="rfc.iref.145"></div>
      <div id="rfc.iref.s.7"></div>
      <h3 id="rfc.section.10.2.2"><a href="#rfc.section.10.2.2">10.2.2</a>&nbsp;<a id="status.201" href="#status.201">201 Created</a></h3>
      <p id="rfc.section.10.2.2.p.1">The request has been fulfilled and resulted in a new resource being created. The newly created resource can be referenced
         by the URI(s) returned in the entity of the response, with the most specific URI for the resource given by a Location header
         field. The response <em class="bcp14">SHOULD</em> include an entity containing a list of resource characteristics and location(s) from which the user or user agent can choose
         the one most appropriate. The entity format is specified by the media type given in the Content-Type header field. The origin
         server <em class="bcp14">MUST</em> create the resource before returning the 201 status code. If the action cannot be carried out immediately, the server <em class="bcp14">SHOULD</em> respond with 202 (Accepted) response instead.
      </p>
      <p id="rfc.section.10.2.2.p.2">A 201 response <em class="bcp14">MAY</em> contain an ETag response header field indicating the current value of the entity tag for the requested variant just created,
         see <a href="#header.etag" id="rfc.xref.header.etag.3" title="ETag">Section&nbsp;14.19</a>.
      </p>
      <div id="rfc.iref.146"></div>
      <div id="rfc.iref.s.8"></div>
      <h3 id="rfc.section.10.2.3"><a href="#rfc.section.10.2.3">10.2.3</a>&nbsp;<a id="status.202" href="#status.202">202 Accepted</a></h3>
      <p id="rfc.section.10.2.3.p.1">The request has been accepted for processing, but the processing has not been completed. The request might or might not eventually
         be acted upon, as it might be disallowed when processing actually takes place. There is no facility for re-sending a status
         code from an asynchronous operation such as this.
      </p>
      <p id="rfc.section.10.2.3.p.2">The 202 response is intentionally non-committal. Its purpose is to allow a server to accept a request for some other process
         (perhaps a batch-oriented process that is only run once per day) without requiring that the user agent's connection to the
         server persist until the process is completed. The entity returned with this response <em class="bcp14">SHOULD</em> include an indication of the request's current status and either a pointer to a status monitor or some estimate of when the
         user can expect the request to be fulfilled.
      </p>
      <div id="rfc.iref.147"></div>
      <div id="rfc.iref.s.9"></div>
      <h3 id="rfc.section.10.2.4"><a href="#rfc.section.10.2.4">10.2.4</a>&nbsp;<a id="status.203" href="#status.203">203 Non-Authoritative Information</a></h3>
      <p id="rfc.section.10.2.4.p.1">The returned metainformation in the entity-header is not the definitive set as available from the origin server, but is gathered
         from a local or a third-party copy. The set presented <em class="bcp14">MAY</em> be a subset or superset of the original version. For example, including local annotation information about the resource might
         result in a superset of the metainformation known by the origin server. Use of this response code is not required and is only
         appropriate when the response would otherwise be 200 (OK).
      </p>
      <div id="rfc.iref.148"></div>
      <div id="rfc.iref.s.10"></div>
      <h3 id="rfc.section.10.2.5"><a href="#rfc.section.10.2.5">10.2.5</a>&nbsp;<a id="status.204" href="#status.204">204 No Content</a></h3>
      <p id="rfc.section.10.2.5.p.1">The server has fulfilled the request but does not need to return an entity-body, and might want to return updated metainformation.
         The response <em class="bcp14">MAY</em> include new or updated metainformation in the form of entity-headers, which if present <em class="bcp14">SHOULD</em> be associated with the requested variant.
      </p>
      <p id="rfc.section.10.2.5.p.2">If the client is a user agent, it <em class="bcp14">SHOULD NOT</em> change its document view from that which caused the request to be sent. This response is primarily intended to allow input
         for actions to take place without causing a change to the user agent's active document view, although any new or updated metainformation <em class="bcp14">SHOULD</em> be applied to the document currently in the user agent's active view.
      </p>
      <p id="rfc.section.10.2.5.p.3">The 204 response <em class="bcp14">MUST NOT</em> include a message-body, and thus is always terminated by the first empty line after the header fields.
      </p>
      <div id="rfc.iref.149"></div>
      <div id="rfc.iref.s.11"></div>
      <h3 id="rfc.section.10.2.6"><a href="#rfc.section.10.2.6">10.2.6</a>&nbsp;<a id="status.205" href="#status.205">205 Reset Content</a></h3>
      <p id="rfc.section.10.2.6.p.1">The server has fulfilled the request and the user agent <em class="bcp14">SHOULD</em> reset the document view which caused the request to be sent. This response is primarily intended to allow input for actions
         to take place via user input, followed by a clearing of the form in which the input is given so that the user can easily initiate
         another input action. The response <em class="bcp14">MUST NOT</em> include an entity.
      </p>
      <div id="rfc.iref.150"></div>
      <div id="rfc.iref.s.12"></div>
      <h3 id="rfc.section.10.2.7"><a href="#rfc.section.10.2.7">10.2.7</a>&nbsp;<a id="status.206" href="#status.206">206 Partial Content</a></h3>
      <p id="rfc.section.10.2.7.p.1">The server has fulfilled the partial GET request for the resource. The request <em class="bcp14">MUST</em> have included a Range header field (<a href="#header.range" id="rfc.xref.header.range.4" title="Range">Section&nbsp;14.35</a>) indicating the desired range, and <em class="bcp14">MAY</em> have included an If-Range header field (<a href="#header.if-range" id="rfc.xref.header.if-range.3" title="If-Range">Section&nbsp;14.27</a>) to make the request conditional.
      </p>
      <p id="rfc.section.10.2.7.p.2">The response <em class="bcp14">MUST</em> include the following header fields: 
      </p>
      <ul>
         <li>Either a Content-Range header field (<a href="#header.content-range" id="rfc.xref.header.content-range.4" title="Content-Range">Section&nbsp;14.16</a>) indicating the range included with this response, or a multipart/byteranges Content-Type including Content-Range fields
            for each part. If a Content-Length header field is present in the response, its value <em class="bcp14">MUST</em> match the actual number of OCTETs transmitted in the message-body.
         </li>
         <li>Date</li>
         <li>ETag and/or Content-Location, if the header would have been sent in a 200 response to the same request</li>
         <li>Expires, Cache-Control, and/or Vary, if the field-value might differ from that sent in any previous response for the same
            variant
         </li>
      </ul>
      <p id="rfc.section.10.2.7.p.3">If the 206 response is the result of an If-Range request that used a strong cache validator (see <a href="#weak.and.strong.validators" title="Weak and Strong Validators">Section&nbsp;13.3.3</a>), the response <em class="bcp14">SHOULD NOT</em> include other entity-headers. If the response is the result of an If-Range request that used a weak validator, the response <em class="bcp14">MUST NOT</em> include other entity-headers; this prevents inconsistencies between cached entity-bodies and updated headers. Otherwise, the
         response <em class="bcp14">MUST</em> include all of the entity-headers that would have been returned with a 200 (OK) response to the same request.
      </p>
      <p id="rfc.section.10.2.7.p.4">A cache <em class="bcp14">MUST NOT</em> combine a 206 response with other previously cached content if the ETag or Last-Modified headers do not match exactly, see <a href="#combining.byte.ranges" title="Combining Byte Ranges">13.5.4</a>.
      </p>
      <p id="rfc.section.10.2.7.p.5">A cache that does not support the Range and Content-Range headers <em class="bcp14">MUST NOT</em> cache 206 (Partial) responses.
      </p>
      <h2 id="rfc.section.10.3"><a href="#rfc.section.10.3">10.3</a>&nbsp;<a id="status.3xx" href="#status.3xx">Redirection 3xx</a></h2>
      <p id="rfc.section.10.3.p.1">This class of status code indicates that further action needs to be taken by the user agent in order to fulfill the request.
         The action required <em class="bcp14">MAY</em> be carried out by the user agent without interaction with the user if and only if the method used in the second request is
         GET or HEAD. A client <em class="bcp14">SHOULD</em> detect infinite redirection loops, since such loops generate network traffic for each redirection. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> previous versions of this specification recommended a maximum of five redirections. Content developers should be aware that
            there might be clients that implement such a fixed limitation.
         </dd>
      </dl>
      <div id="rfc.iref.151"></div>
      <div id="rfc.iref.s.13"></div>
      <h3 id="rfc.section.10.3.1"><a href="#rfc.section.10.3.1">10.3.1</a>&nbsp;<a id="status.300" href="#status.300">300 Multiple Choices</a></h3>
      <p id="rfc.section.10.3.1.p.1">The requested resource corresponds to any one of a set of representations, each with its own specific location, and agent-driven
         negotiation information (<a href="#content.negotiation" title="Content Negotiation">Section&nbsp;12</a>) is being provided so that the user (or user agent) can select a preferred representation and redirect its request to that
         location.
      </p>
      <p id="rfc.section.10.3.1.p.2">Unless it was a HEAD request, the response <em class="bcp14">SHOULD</em> include an entity containing a list of resource characteristics and location(s) from which the user or user agent can choose
         the one most appropriate. The entity format is specified by the media type given in the Content-Type header field. Depending
         upon the format and the capabilities of the user agent, selection of the most appropriate choice <em class="bcp14">MAY</em> be performed automatically. However, this specification does not define any standard for such automatic selection.
      </p>
      <p id="rfc.section.10.3.1.p.3">If the server has a preferred choice of representation, it <em class="bcp14">SHOULD</em> include the specific URI for that representation in the Location field; user agents <em class="bcp14">MAY</em> use the Location field value for automatic redirection. This response is cacheable unless indicated otherwise.
      </p>
      <div id="rfc.iref.152"></div>
      <div id="rfc.iref.s.14"></div>
      <h3 id="rfc.section.10.3.2"><a href="#rfc.section.10.3.2">10.3.2</a>&nbsp;<a id="status.301" href="#status.301">301 Moved Permanently</a></h3>
      <p id="rfc.section.10.3.2.p.1">The requested resource has been assigned a new permanent URI and any future references to this resource <em class="bcp14">SHOULD</em> use one of the returned URIs. Clients with link editing capabilities ought to automatically re-link references to the Request-URI
         to one or more of the new references returned by the server, where possible. This response is cacheable unless indicated otherwise.
      </p>
      <p id="rfc.section.10.3.2.p.2">The new permanent URI <em class="bcp14">SHOULD</em> be given by the Location field in the response. Unless the request method was HEAD, the entity of the response <em class="bcp14">SHOULD</em> contain a short hypertext note with a hyperlink to the new URI(s).
      </p>
      <p id="rfc.section.10.3.2.p.3">If the 301 status code is received in response to a request other than GET or HEAD, the user agent <em class="bcp14">MUST NOT</em> automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which
         the request was issued. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> When automatically redirecting a POST request after receiving a 301 status code, some existing HTTP/1.0 user agents will erroneously
            change it into a GET request.
         </dd>
      </dl>
      <div id="rfc.iref.153"></div>
      <div id="rfc.iref.s.15"></div>
      <h3 id="rfc.section.10.3.3"><a href="#rfc.section.10.3.3">10.3.3</a>&nbsp;<a id="status.302" href="#status.302">302 Found</a></h3>
      <p id="rfc.section.10.3.3.p.1">The requested resource resides temporarily under a different URI. Since the redirection might be altered on occasion, the
         client <em class="bcp14">SHOULD</em> continue to use the Request-URI for future requests. This response is only cacheable if indicated by a Cache-Control or Expires
         header field.
      </p>
      <p id="rfc.section.10.3.3.p.2">The temporary URI <em class="bcp14">SHOULD</em> be given by the Location field in the response. Unless the request method was HEAD, the entity of the response <em class="bcp14">SHOULD</em> contain a short hypertext note with a hyperlink to the new URI(s).
      </p>
      <p id="rfc.section.10.3.3.p.3">If the 302 status code is received in response to a request other than GET or HEAD, the user agent <em class="bcp14">MUST NOT</em> automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which
         the request was issued. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> RFC 1945 and RFC 2068 specify that the client is not allowed to change the method on the redirected request. However, most
            existing user agent implementations treat 302 as if it were a 303 response, performing a GET on the Location field-value regardless
            of the original request method. The status codes 303 and 307 have been added for servers that wish to make unambiguously clear
            which kind of reaction is expected of the client.
         </dd>
      </dl>
      <div id="rfc.iref.154"></div>
      <div id="rfc.iref.s.16"></div>
      <h3 id="rfc.section.10.3.4"><a href="#rfc.section.10.3.4">10.3.4</a>&nbsp;<a id="status.303" href="#status.303">303 See Other</a></h3>
      <p id="rfc.section.10.3.4.p.1">The response to the request can be found under a different URI and <em class="bcp14">SHOULD</em> be retrieved using a GET method on that resource. This method exists primarily to allow the output of a POST-activated script
         to redirect the user agent to a selected resource. The new URI is not a substitute reference for the originally requested
         resource. The 303 response <em class="bcp14">MUST NOT</em> be cached, but the response to the second (redirected) request might be cacheable.
      </p>
      <p id="rfc.section.10.3.4.p.2">The different URI <em class="bcp14">SHOULD</em> be given by the Location field in the response. Unless the request method was HEAD, the entity of the response <em class="bcp14">SHOULD</em> contain a short hypertext note with a hyperlink to the new URI(s). 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> Many pre-HTTP/1.1 user agents do not understand the 303 status. When interoperability with such clients is a concern, the
            302 status code may be used instead, since most user agents react to a 302 response as described here for 303.
         </dd>
      </dl>
      <div id="rfc.iref.155"></div>
      <div id="rfc.iref.s.17"></div>
      <h3 id="rfc.section.10.3.5"><a href="#rfc.section.10.3.5">10.3.5</a>&nbsp;<a id="status.304" href="#status.304">304 Not Modified</a></h3>
      <p id="rfc.section.10.3.5.p.1">If the client has performed a conditional GET request and access is allowed, but the document has not been modified, the server <em class="bcp14">SHOULD</em> respond with this status code. The 304 response <em class="bcp14">MUST NOT</em> contain a message-body, and thus is always terminated by the first empty line after the header fields.
      </p>
      <p id="rfc.section.10.3.5.p.2">The response <em class="bcp14">MUST</em> include the following header fields: 
      </p>
      <ul>
         <li>Date, unless its omission is required by <a href="#clockless.origin.server.operation" title="Clockless Origin Server Operation">Section&nbsp;14.18.1</a></li>
      </ul>
      <p id="rfc.section.10.3.5.p.3">If a clockless origin server obeys these rules, and proxies and clients add their own Date to any response received without
         one (as already specified by [RFC 2068], section <a href="http://tools.ietf.org/html/rfc2068#section-14.19" id="rfc.xref.RFC2068.4">14.19</a>), caches will operate correctly. 
      </p>
      <ul>
         <li>ETag and/or Content-Location, if the header would have been sent in a 200 response to the same request</li>
         <li>Expires, Cache-Control, and/or Vary, if the field-value might differ from that sent in any previous response for the same
            variant
         </li>
      </ul>
      <p id="rfc.section.10.3.5.p.4">If the conditional GET used a strong cache validator (see <a href="#weak.and.strong.validators" title="Weak and Strong Validators">Section&nbsp;13.3.3</a>), the response <em class="bcp14">SHOULD NOT</em> include other entity-headers. Otherwise (i.e., the conditional GET used a weak validator), the response <em class="bcp14">MUST NOT</em> include other entity-headers; this prevents inconsistencies between cached entity-bodies and updated headers.
      </p>
      <p id="rfc.section.10.3.5.p.5">If a 304 response indicates an entity not currently cached, then the cache <em class="bcp14">MUST</em> disregard the response and repeat the request without the conditional.
      </p>
      <p id="rfc.section.10.3.5.p.6">If a cache uses a received 304 response to update a cache entry, the cache <em class="bcp14">MUST</em> update the entry to reflect any new field values given in the response.
      </p>
      <div id="rfc.iref.156"></div>
      <div id="rfc.iref.s.18"></div>
      <h3 id="rfc.section.10.3.6"><a href="#rfc.section.10.3.6">10.3.6</a>&nbsp;<a id="status.305" href="#status.305">305 Use Proxy</a></h3>
      <p id="rfc.section.10.3.6.p.1">The requested resource <em class="bcp14">MUST</em> be accessed through the proxy given by the Location field. The Location field gives the URI of the proxy. The recipient is
         expected to repeat this single request via the proxy. 305 responses <em class="bcp14">MUST</em> only be generated by origin servers. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> RFC 2068 was not clear that 305 was intended to redirect a single request, and to be generated by origin servers only. Not
            observing these limitations has significant security consequences.
         </dd>
      </dl>
      <div id="rfc.iref.157"></div>
      <div id="rfc.iref.s.19"></div>
      <h3 id="rfc.section.10.3.7"><a href="#rfc.section.10.3.7">10.3.7</a>&nbsp;<a id="status.306" href="#status.306">306 (Unused)</a></h3>
      <p id="rfc.section.10.3.7.p.1">The 306 status code was used in a previous version of the specification, is no longer used, and the code is reserved.</p>
      <div id="rfc.iref.158"></div>
      <div id="rfc.iref.s.20"></div>
      <h3 id="rfc.section.10.3.8"><a href="#rfc.section.10.3.8">10.3.8</a>&nbsp;<a id="status.307" href="#status.307">307 Temporary Redirect</a></h3>
      <p id="rfc.section.10.3.8.p.1">The requested resource resides temporarily under a different URI. Since the redirection <em class="bcp14">MAY</em> be altered on occasion, the client <em class="bcp14">SHOULD</em> continue to use the Request-URI for future requests. This response is only cacheable if indicated by a Cache-Control or Expires
         header field.
      </p>
      <p id="rfc.section.10.3.8.p.2">The temporary URI <em class="bcp14">SHOULD</em> be given by the Location field in the response. Unless the request method was HEAD, the entity of the response <em class="bcp14">SHOULD</em> contain a short hypertext note with a hyperlink to the new URI(s) , since many pre-HTTP/1.1 user agents do not understand
         the 307 status. Therefore, the note <em class="bcp14">SHOULD</em> contain the information necessary for a user to repeat the original request on the new URI.
      </p>
      <p id="rfc.section.10.3.8.p.3">If the 307 status code is received in response to a request other than GET or HEAD, the user agent <em class="bcp14">MUST NOT</em> automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which
         the request was issued.
      </p>
      <h2 id="rfc.section.10.4"><a href="#rfc.section.10.4">10.4</a>&nbsp;<a id="status.4xx" href="#status.4xx">Client Error 4xx</a></h2>
      <p id="rfc.section.10.4.p.1">The 4xx class of status code is intended for cases in which the client seems to have erred. Except when responding to a HEAD
         request, the server <em class="bcp14">SHOULD</em> include an entity containing an explanation of the error situation, and whether it is a temporary or permanent condition.
         These status codes are applicable to any request method. User agents <em class="bcp14">SHOULD</em> display any included entity to the user.
      </p>
      <p id="rfc.section.10.4.p.2">If the client is sending data, a server implementation using TCP <em class="bcp14">SHOULD</em> be careful to ensure that the client acknowledges receipt of the packet(s) containing the response, before the server closes
         the input connection. If the client continues sending data to the server after the close, the server's TCP stack will send
         a reset packet to the client, which may erase the client's unacknowledged input buffers before they can be read and interpreted
         by the HTTP application.
      </p>
      <div id="rfc.iref.159"></div>
      <div id="rfc.iref.s.21"></div>
      <h3 id="rfc.section.10.4.1"><a href="#rfc.section.10.4.1">10.4.1</a>&nbsp;<a id="status.400" href="#status.400">400 Bad Request</a></h3>
      <p id="rfc.section.10.4.1.p.1">The request could not be understood by the server due to malformed syntax. The client <em class="bcp14">SHOULD NOT</em> repeat the request without modifications.
      </p>
      <div id="rfc.iref.160"></div>
      <div id="rfc.iref.s.22"></div>
      <h3 id="rfc.section.10.4.2"><a href="#rfc.section.10.4.2">10.4.2</a>&nbsp;<a id="status.401" href="#status.401">401 Unauthorized</a></h3>
      <p id="rfc.section.10.4.2.p.1">The request requires user authentication. The response <em class="bcp14">MUST</em> include a WWW-Authenticate header field (<a href="#header.www-authenticate" id="rfc.xref.header.www-authenticate.2" title="WWW-Authenticate">Section&nbsp;14.47</a>) containing a challenge applicable to the requested resource. The client <em class="bcp14">MAY</em> repeat the request with a suitable Authorization header field (<a href="#header.authorization" id="rfc.xref.header.authorization.2" title="Authorization">Section&nbsp;14.8</a>). If the request already included Authorization credentials, then the 401 response indicates that authorization has been
         refused for those credentials. If the 401 response contains the same challenge as the prior response, and the user agent has
         already attempted authentication at least once, then the user <em class="bcp14">SHOULD</em> be presented the entity that was given in the response, since that entity might include relevant diagnostic information. HTTP
         access authentication is explained in "HTTP Authentication: Basic and Digest Access Authentication" <a href="#RFC2617" id="rfc.xref.RFC2617.1"><cite title="HTTP Authentication: Basic and Digest Access Authentication">[RFC2617]</cite></a>.
      </p>
      <div id="rfc.iref.161"></div>
      <div id="rfc.iref.s.23"></div>
      <h3 id="rfc.section.10.4.3"><a href="#rfc.section.10.4.3">10.4.3</a>&nbsp;<a id="status.402" href="#status.402">402 Payment Required</a></h3>
      <p id="rfc.section.10.4.3.p.1">This code is reserved for future use.</p>
      <div id="rfc.iref.162"></div>
      <div id="rfc.iref.s.24"></div>
      <h3 id="rfc.section.10.4.4"><a href="#rfc.section.10.4.4">10.4.4</a>&nbsp;<a id="status.403" href="#status.403">403 Forbidden</a></h3>
      <p id="rfc.section.10.4.4.p.1">The server understood the request, but is refusing to fulfill it. Authorization will not help and the request <em class="bcp14">SHOULD NOT</em> be repeated. If the request method was not HEAD and the server wishes to make public why the request has not been fulfilled,
         it <em class="bcp14">SHOULD</em> describe the reason for the refusal in the entity. If the server does not wish to make this information available to the client,
         the status code 404 (Not Found) can be used instead.
      </p>
      <div id="rfc.iref.163"></div>
      <div id="rfc.iref.s.25"></div>
      <h3 id="rfc.section.10.4.5"><a href="#rfc.section.10.4.5">10.4.5</a>&nbsp;<a id="status.404" href="#status.404">404 Not Found</a></h3>
      <p id="rfc.section.10.4.5.p.1">The server has not found anything matching the Request-URI. No indication is given of whether the condition is temporary or
         permanent. The 410 (Gone) status code <em class="bcp14">SHOULD</em> be used if the server knows, through some internally configurable mechanism, that an old resource is permanently unavailable
         and has no forwarding address. This status code is commonly used when the server does not wish to reveal exactly why the request
         has been refused, or when no other response is applicable.
      </p>
      <div id="rfc.iref.164"></div>
      <div id="rfc.iref.s.26"></div>
      <h3 id="rfc.section.10.4.6"><a href="#rfc.section.10.4.6">10.4.6</a>&nbsp;<a id="status.405" href="#status.405">405 Method Not Allowed</a></h3>
      <p id="rfc.section.10.4.6.p.1">The method specified in the Request-Line is not allowed for the resource identified by the Request-URI. The response <em class="bcp14">MUST</em> include an Allow header containing a list of valid methods for the requested resource.
      </p>
      <div id="rfc.iref.165"></div>
      <div id="rfc.iref.s.27"></div>
      <h3 id="rfc.section.10.4.7"><a href="#rfc.section.10.4.7">10.4.7</a>&nbsp;<a id="status.406" href="#status.406">406 Not Acceptable</a></h3>
      <p id="rfc.section.10.4.7.p.1">The resource identified by the request is only capable of generating response entities which have content characteristics
         not acceptable according to the accept headers sent in the request.
      </p>
      <p id="rfc.section.10.4.7.p.2">Unless it was a HEAD request, the response <em class="bcp14">SHOULD</em> include an entity containing a list of available entity characteristics and location(s) from which the user or user agent
         can choose the one most appropriate. The entity format is specified by the media type given in the Content-Type header field.
         Depending upon the format and the capabilities of the user agent, selection of the most appropriate choice <em class="bcp14">MAY</em> be performed automatically. However, this specification does not define any standard for such automatic selection. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> HTTP/1.1 servers are allowed to return responses which are not acceptable according to the accept headers sent in the request.
            In some cases, this may even be preferable to sending a 406 response. User agents are encouraged to inspect the headers of
            an incoming response to determine if it is acceptable.
         </dd>
      </dl>
      <p id="rfc.section.10.4.7.p.3">If the response could be unacceptable, a user agent <em class="bcp14">SHOULD</em> temporarily stop receipt of more data and query the user for a decision on further actions.
      </p>
      <div id="rfc.iref.166"></div>
      <div id="rfc.iref.s.28"></div>
      <h3 id="rfc.section.10.4.8"><a href="#rfc.section.10.4.8">10.4.8</a>&nbsp;<a id="status.407" href="#status.407">407 Proxy Authentication Required</a></h3>
      <p id="rfc.section.10.4.8.p.1">This code is similar to 401 (Unauthorized), but indicates that the client must first authenticate itself with the proxy. The
         proxy <em class="bcp14">MUST</em> return a Proxy-Authenticate header field (<a href="#header.proxy-authenticate" id="rfc.xref.header.proxy-authenticate.2" title="Proxy-Authenticate">Section&nbsp;14.33</a>) containing a challenge applicable to the proxy for the requested resource. The client <em class="bcp14">MAY</em> repeat the request with a suitable Proxy-Authorization header field (<a href="#header.proxy-authorization" id="rfc.xref.header.proxy-authorization.2" title="Proxy-Authorization">Section&nbsp;14.34</a>). HTTP access authentication is explained in "HTTP Authentication: Basic and Digest Access Authentication" <a href="#RFC2617" id="rfc.xref.RFC2617.2"><cite title="HTTP Authentication: Basic and Digest Access Authentication">[RFC2617]</cite></a>.
      </p>
      <div id="rfc.iref.167"></div>
      <div id="rfc.iref.s.29"></div>
      <h3 id="rfc.section.10.4.9"><a href="#rfc.section.10.4.9">10.4.9</a>&nbsp;<a id="status.408" href="#status.408">408 Request Timeout</a></h3>
      <p id="rfc.section.10.4.9.p.1">The client did not produce a request within the time that the server was prepared to wait. The client <em class="bcp14">MAY</em> repeat the request without modifications at any later time.
      </p>
      <div id="rfc.iref.168"></div>
      <div id="rfc.iref.s.30"></div>
      <h3 id="rfc.section.10.4.10"><a href="#rfc.section.10.4.10">10.4.10</a>&nbsp;<a id="status.409" href="#status.409">409 Conflict</a></h3>
      <p id="rfc.section.10.4.10.p.1">The request could not be completed due to a conflict with the current state of the resource. This code is only allowed in
         situations where it is expected that the user might be able to resolve the conflict and resubmit the request. The response
         body <em class="bcp14">SHOULD</em> include enough information for the user to recognize the source of the conflict. Ideally, the response entity would include
         enough information for the user or user agent to fix the problem; however, that might not be possible and is not required.
      </p>
      <p id="rfc.section.10.4.10.p.2">Conflicts are most likely to occur in response to a PUT request. For example, if versioning were being used and the entity
         being PUT included changes to a resource which conflict with those made by an earlier (third-party) request, the server might
         use the 409 response to indicate that it can't complete the request. In this case, the response entity would likely contain
         a list of the differences between the two versions in a format defined by the response Content-Type.
      </p>
      <div id="rfc.iref.169"></div>
      <div id="rfc.iref.s.31"></div>
      <h3 id="rfc.section.10.4.11"><a href="#rfc.section.10.4.11">10.4.11</a>&nbsp;<a id="status.410" href="#status.410">410 Gone</a></h3>
      <p id="rfc.section.10.4.11.p.1">The requested resource is no longer available at the server and no forwarding address is known. This condition is expected
         to be considered permanent. Clients with link editing capabilities <em class="bcp14">SHOULD</em> delete references to the Request-URI after user approval. If the server does not know, or has no facility to determine, whether
         or not the condition is permanent, the status code 404 (Not Found) <em class="bcp14">SHOULD</em> be used instead. This response is cacheable unless indicated otherwise.
      </p>
      <p id="rfc.section.10.4.11.p.2">The 410 response is primarily intended to assist the task of web maintenance by notifying the recipient that the resource
         is intentionally unavailable and that the server owners desire that remote links to that resource be removed. Such an event
         is common for limited-time, promotional services and for resources belonging to individuals no longer working at the server's
         site. It is not necessary to mark all permanently unavailable resources as "gone" or to keep the mark for any length of time
         -- that is left to the discretion of the server owner.
      </p>
      <div id="rfc.iref.170"></div>
      <div id="rfc.iref.s.32"></div>
      <h3 id="rfc.section.10.4.12"><a href="#rfc.section.10.4.12">10.4.12</a>&nbsp;<a id="status.411" href="#status.411">411 Length Required</a></h3>
      <p id="rfc.section.10.4.12.p.1">The server refuses to accept the request without a defined Content-Length. The client <em class="bcp14">MAY</em> repeat the request if it adds a valid Content-Length header field containing the length of the message-body in the request
         message.
      </p>
      <div id="rfc.iref.171"></div>
      <div id="rfc.iref.s.33"></div>
      <h3 id="rfc.section.10.4.13"><a href="#rfc.section.10.4.13">10.4.13</a>&nbsp;<a id="status.412" href="#status.412">412 Precondition Failed</a></h3>
      <p id="rfc.section.10.4.13.p.1">The precondition given in one or more of the request-header fields evaluated to false when it was tested on the server. This
         response code allows the client to place preconditions on the current resource metainformation (header field data) and thus
         prevent the requested method from being applied to a resource other than the one intended.
      </p>
      <div id="rfc.iref.172"></div>
      <div id="rfc.iref.s.34"></div>
      <h3 id="rfc.section.10.4.14"><a href="#rfc.section.10.4.14">10.4.14</a>&nbsp;<a id="status.413" href="#status.413">413 Request Entity Too Large</a></h3>
      <p id="rfc.section.10.4.14.p.1">The server is refusing to process a request because the request entity is larger than the server is willing or able to process.
         The server <em class="bcp14">MAY</em> close the connection to prevent the client from continuing the request.
      </p>
      <p id="rfc.section.10.4.14.p.2">If the condition is temporary, the server <em class="bcp14">SHOULD</em> include a Retry-After header field to indicate that it is temporary and after what time the client <em class="bcp14">MAY</em> try again.
      </p>
      <div id="rfc.iref.173"></div>
      <div id="rfc.iref.s.35"></div>
      <h3 id="rfc.section.10.4.15"><a href="#rfc.section.10.4.15">10.4.15</a>&nbsp;<a id="status.414" href="#status.414">414 Request-URI Too Long</a></h3>
      <p id="rfc.section.10.4.15.p.1">The server is refusing to service the request because the Request-URI is longer than the server is willing to interpret. This
         rare condition is only likely to occur when a client has improperly converted a POST request to a GET request with long query
         information, when the client has descended into a URI "black hole" of redirection (e.g., a redirected URI prefix that points
         to a suffix of itself), or when the server is under attack by a client attempting to exploit security holes present in some
         servers using fixed-length buffers for reading or manipulating the Request-URI.
      </p>
      <div id="rfc.iref.174"></div>
      <div id="rfc.iref.s.36"></div>
      <h3 id="rfc.section.10.4.16"><a href="#rfc.section.10.4.16">10.4.16</a>&nbsp;<a id="status.415" href="#status.415">415 Unsupported Media Type</a></h3>
      <p id="rfc.section.10.4.16.p.1">The server is refusing to service the request because the entity of the request is in a format not supported by the requested
         resource for the requested method.
      </p>
      <div id="rfc.iref.175"></div>
      <div id="rfc.iref.s.37"></div>
      <h3 id="rfc.section.10.4.17"><a href="#rfc.section.10.4.17">10.4.17</a>&nbsp;<a id="status.416" href="#status.416">416 Requested Range Not Satisfiable</a></h3>
      <p id="rfc.section.10.4.17.p.1">A server <em class="bcp14">SHOULD</em> return a response with this status code if a request included a Range request-header field (<a href="#header.range" id="rfc.xref.header.range.5" title="Range">Section&nbsp;14.35</a>), and none of the range-specifier values in this field overlap the current extent of the selected resource, and the request
         did not include an If-Range request-header field. (For byte-ranges, this means that the first-byte-pos of all of the byte-range-spec
         values were greater than the current length of the selected resource.)
      </p>
      <p id="rfc.section.10.4.17.p.2">When this status code is returned for a byte-range request, the response <em class="bcp14">SHOULD</em> include a Content-Range entity-header field specifying the current length of the selected resource (see <a href="#header.content-range" id="rfc.xref.header.content-range.5" title="Content-Range">Section&nbsp;14.16</a>). This response <em class="bcp14">MUST NOT</em> use the multipart/byteranges content-type.
      </p>
      <div id="rfc.iref.176"></div>
      <div id="rfc.iref.s.38"></div>
      <h3 id="rfc.section.10.4.18"><a href="#rfc.section.10.4.18">10.4.18</a>&nbsp;<a id="status.417" href="#status.417">417 Expectation Failed</a></h3>
      <p id="rfc.section.10.4.18.p.1">The expectation given in an Expect request-header field (see <a href="#header.expect" id="rfc.xref.header.expect.4" title="Expect">Section&nbsp;14.20</a>) could not be met by this server, or, if the server is a proxy, the server has unambiguous evidence that the request could
         not be met by the next-hop server.
      </p>
      <h2 id="rfc.section.10.5"><a href="#rfc.section.10.5">10.5</a>&nbsp;<a id="status.5xx" href="#status.5xx">Server Error 5xx</a></h2>
      <p id="rfc.section.10.5.p.1">Response status codes beginning with the digit "5" indicate cases in which the server is aware that it has erred or is incapable
         of performing the request. Except when responding to a HEAD request, the server <em class="bcp14">SHOULD</em> include an entity containing an explanation of the error situation, and whether it is a temporary or permanent condition.
         User agents <em class="bcp14">SHOULD</em> display any included entity to the user. These response codes are applicable to any request method.
      </p>
      <div id="rfc.iref.177"></div>
      <div id="rfc.iref.s.39"></div>
      <h3 id="rfc.section.10.5.1"><a href="#rfc.section.10.5.1">10.5.1</a>&nbsp;<a id="status.500" href="#status.500">500 Internal Server Error</a></h3>
      <p id="rfc.section.10.5.1.p.1">The server encountered an unexpected condition which prevented it from fulfilling the request.</p>
      <div id="rfc.iref.178"></div>
      <div id="rfc.iref.s.40"></div>
      <h3 id="rfc.section.10.5.2"><a href="#rfc.section.10.5.2">10.5.2</a>&nbsp;<a id="status.501" href="#status.501">501 Not Implemented</a></h3>
      <p id="rfc.section.10.5.2.p.1">The server does not support the functionality required to fulfill the request. This is the appropriate response when the server
         does not recognize the request method and is not capable of supporting it for any resource.
      </p>
      <div id="rfc.iref.179"></div>
      <div id="rfc.iref.s.41"></div>
      <h3 id="rfc.section.10.5.3"><a href="#rfc.section.10.5.3">10.5.3</a>&nbsp;<a id="status.502" href="#status.502">502 Bad Gateway</a></h3>
      <p id="rfc.section.10.5.3.p.1">The server, while acting as a gateway or proxy, received an invalid response from the upstream server it accessed in attempting
         to fulfill the request.
      </p>
      <div id="rfc.iref.180"></div>
      <div id="rfc.iref.s.42"></div>
      <h3 id="rfc.section.10.5.4"><a href="#rfc.section.10.5.4">10.5.4</a>&nbsp;<a id="status.503" href="#status.503">503 Service Unavailable</a></h3>
      <p id="rfc.section.10.5.4.p.1">The server is currently unable to handle the request due to a temporary overloading or maintenance of the server. The implication
         is that this is a temporary condition which will be alleviated after some delay. If known, the length of the delay <em class="bcp14">MAY</em> be indicated in a Retry-After header. If no Retry-After is given, the client <em class="bcp14">SHOULD</em> handle the response as it would for a 500 response. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> The existence of the 503 status code does not imply that a server must use it when becoming overloaded. Some servers may wish
            to simply refuse the connection.
         </dd>
      </dl>
      <div id="rfc.iref.181"></div>
      <div id="rfc.iref.s.43"></div>
      <h3 id="rfc.section.10.5.5"><a href="#rfc.section.10.5.5">10.5.5</a>&nbsp;<a id="status.504" href="#status.504">504 Gateway Timeout</a></h3>
      <p id="rfc.section.10.5.5.p.1">The server, while acting as a gateway or proxy, did not receive a timely response from the upstream server specified by the
         URI (e.g. HTTP, FTP, LDAP) or some other auxiliary server (e.g. DNS) it needed to access in attempting to complete the request. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> Note to implementors: some deployed proxies are known to return 400 or 500 when DNS lookups time out.
         </dd>
      </dl>
      <div id="rfc.iref.182"></div>
      <div id="rfc.iref.s.44"></div>
      <h3 id="rfc.section.10.5.6"><a href="#rfc.section.10.5.6">10.5.6</a>&nbsp;<a id="status.505" href="#status.505">505 HTTP Version Not Supported</a></h3>
      <p id="rfc.section.10.5.6.p.1">The server does not support, or refuses to support, the HTTP protocol version that was used in the request message. The server
         is indicating that it is unable or unwilling to complete the request using the same major version as the client, as described
         in <a href="#http.version" title="HTTP Version">Section&nbsp;3.1</a>, other than with this error message. The response <em class="bcp14">SHOULD</em> contain an entity describing why that version is not supported and what other protocols are supported by that server.
      </p>
      <h1 id="rfc.section.11"><a href="#rfc.section.11">11.</a>&nbsp;<a id="access.authentication" href="#access.authentication">Access Authentication</a></h1>
      <p id="rfc.section.11.p.1">HTTP provides several <em class="bcp14">OPTIONAL</em> challenge-response authentication mechanisms which can be used by a server to challenge a client request and by a client to
         provide authentication information. The general framework for access authentication, and the specification of "basic" and
         "digest" authentication, are specified in "HTTP Authentication: Basic and Digest Access Authentication" <a href="#RFC2617" id="rfc.xref.RFC2617.3"><cite title="HTTP Authentication: Basic and Digest Access Authentication">[RFC2617]</cite></a>. This specification adopts the definitions of "challenge" and "credentials" from that specification.
      </p>
      <h1 id="rfc.section.12"><a href="#rfc.section.12">12.</a>&nbsp;<a id="content.negotiation" href="#content.negotiation">Content Negotiation</a></h1>
      <p id="rfc.section.12.p.1">Most HTTP responses include an entity which contains information for interpretation by a human user. Naturally, it is desirable
         to supply the user with the "best available" entity corresponding to the request. Unfortunately for servers and caches, not
         all users have the same preferences for what is "best," and not all user agents are equally capable of rendering all entity
         types. For that reason, HTTP has provisions for several mechanisms for "content negotiation" -- the process of selecting the
         best representation for a given response when there are multiple representations available. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> This is not called "format negotiation" because the alternate representations may be of the same media type, but use different
            capabilities of that type, be in different languages, etc.
         </dd>
      </dl>
      <p id="rfc.section.12.p.2">Any response containing an entity-body <em class="bcp14">MAY</em> be subject to negotiation, including error responses.
      </p>
      <p id="rfc.section.12.p.3">There are two kinds of content negotiation which are possible in HTTP: server-driven and agent-driven negotiation. These two
         kinds of negotiation are orthogonal and thus may be used separately or in combination. One method of combination, referred
         to as transparent negotiation, occurs when a cache uses the agent-driven negotiation information provided by the origin server
         in order to provide server-driven negotiation for subsequent requests.
      </p>
      <h2 id="rfc.section.12.1"><a href="#rfc.section.12.1">12.1</a>&nbsp;<a id="server-driven.negotiation" href="#server-driven.negotiation">Server-driven Negotiation</a></h2>
      <p id="rfc.section.12.1.p.1">If the selection of the best representation for a response is made by an algorithm located at the server, it is called server-driven
         negotiation. Selection is based on the available representations of the response (the dimensions over which it can vary; e.g.
         language, content-coding, etc.) and the contents of particular header fields in the request message or on other information
         pertaining to the request (such as the network address of the client).
      </p>
      <p id="rfc.section.12.1.p.2">Server-driven negotiation is advantageous when the algorithm for selecting from among the available representations is difficult
         to describe to the user agent, or when the server desires to send its "best guess" to the client along with the first response
         (hoping to avoid the round-trip delay of a subsequent request if the "best guess" is good enough for the user). In order to
         improve the server's guess, the user agent <em class="bcp14">MAY</em> include request header fields (Accept, Accept-Language, Accept-Encoding, etc.) which describe its preferences for such a response.
      </p>
      <p id="rfc.section.12.1.p.3">Server-driven negotiation has disadvantages: </p>
      <ol>
         <li>It is impossible for the server to accurately determine what might be "best" for any given user, since that would require
            complete knowledge of both the capabilities of the user agent and the intended use for the response (e.g., does the user want
            to view it on screen or print it on paper?).
         </li>
         <li>Having the user agent describe its capabilities in every request can be both very inefficient (given that only a small percentage
            of responses have multiple representations) and a potential violation of the user's privacy.
         </li>
         <li>It complicates the implementation of an origin server and the algorithms for generating responses to a request.</li>
         <li>It may limit a public cache's ability to use the same response for multiple user's requests.</li>
      </ol>
      <p id="rfc.section.12.1.p.4">HTTP/1.1 includes the following request-header fields for enabling server-driven negotiation through description of user agent
         capabilities and user preferences: Accept (<a href="#header.accept" id="rfc.xref.header.accept.3" title="Accept">Section&nbsp;14.1</a>), Accept-Charset (<a href="#header.accept-charset" id="rfc.xref.header.accept-charset.2" title="Accept-Charset">Section&nbsp;14.2</a>), Accept-Encoding (<a href="#header.accept-encoding" id="rfc.xref.header.accept-encoding.3" title="Accept-Encoding">Section&nbsp;14.3</a>), Accept-Language (<a href="#header.accept-language" id="rfc.xref.header.accept-language.2" title="Accept-Language">Section&nbsp;14.4</a>), and User-Agent (<a href="#header.user-agent" id="rfc.xref.header.user-agent.2" title="User-Agent">Section&nbsp;14.43</a>). However, an origin server is not limited to these dimensions and <em class="bcp14">MAY</em> vary the response based on any aspect of the request, including information outside the request-header fields or within extension
         header fields not defined by this specification.
      </p>
      <p id="rfc.section.12.1.p.5">The Vary header field can be used to express the parameters the server uses to select a representation that is subject to
         server-driven negotiation. See <a href="#caching.negotiated.responses" title="Caching Negotiated Responses">Section&nbsp;13.6</a> for use of the Vary header field by caches and <a href="#header.vary" id="rfc.xref.header.vary.2" title="Vary">Section&nbsp;14.44</a> for use of the Vary header field by servers.
      </p>
      <h2 id="rfc.section.12.2"><a href="#rfc.section.12.2">12.2</a>&nbsp;<a id="agent-driven.negotiation" href="#agent-driven.negotiation">Agent-driven Negotiation</a></h2>
      <p id="rfc.section.12.2.p.1">With agent-driven negotiation, selection of the best representation for a response is performed by the user agent after receiving
         an initial response from the origin server. Selection is based on a list of the available representations of the response
         included within the header fields or entity-body of the initial response, with each representation identified by its own URI.
         Selection from among the representations may be performed automatically (if the user agent is capable of doing so) or manually
         by the user selecting from a generated (possibly hypertext) menu.
      </p>
      <p id="rfc.section.12.2.p.2">Agent-driven negotiation is advantageous when the response would vary over commonly-used dimensions (such as type, language,
         or encoding), when the origin server is unable to determine a user agent's capabilities from examining the request, and generally
         when public caches are used to distribute server load and reduce network usage.
      </p>
      <p id="rfc.section.12.2.p.3">Agent-driven negotiation suffers from the disadvantage of needing a second request to obtain the best alternate representation.
         This second request is only efficient when caching is used. In addition, this specification does not define any mechanism
         for supporting automatic selection, though it also does not prevent any such mechanism from being developed as an extension
         and used within HTTP/1.1.
      </p>
      <p id="rfc.section.12.2.p.4">HTTP/1.1 defines the 300 (Multiple Choices) and 406 (Not Acceptable) status codes for enabling agent-driven negotiation when
         the server is unwilling or unable to provide a varying response using server-driven negotiation.
      </p>
      <h2 id="rfc.section.12.3"><a href="#rfc.section.12.3">12.3</a>&nbsp;<a id="transparent.negotiation" href="#transparent.negotiation">Transparent Negotiation</a></h2>
      <p id="rfc.section.12.3.p.1">Transparent negotiation is a combination of both server-driven and agent-driven negotiation. When a cache is supplied with
         a form of the list of available representations of the response (as in agent-driven negotiation) and the dimensions of variance
         are completely understood by the cache, then the cache becomes capable of performing server-driven negotiation on behalf of
         the origin server for subsequent requests on that resource.
      </p>
      <p id="rfc.section.12.3.p.2">Transparent negotiation has the advantage of distributing the negotiation work that would otherwise be required of the origin
         server and also removing the second request delay of agent-driven negotiation when the cache is able to correctly guess the
         right response.
      </p>
      <p id="rfc.section.12.3.p.3">This specification does not define any mechanism for transparent negotiation, though it also does not prevent any such mechanism
         from being developed as an extension that could be used within HTTP/1.1.
      </p>
      <h1 id="rfc.section.13"><a href="#rfc.section.13">13.</a>&nbsp;<a id="caching" href="#caching">Caching in HTTP</a></h1>
      <p id="rfc.section.13.p.1">HTTP is typically used for distributed information systems, where performance can be improved by the use of response caches.
         The HTTP/1.1 protocol includes a number of elements intended to make caching work as well as possible. Because these elements
         are inextricable from other aspects of the protocol, and because they interact with each other, it is useful to describe the
         basic caching design of HTTP separately from the detailed descriptions of methods, headers, response codes, etc.
      </p>
      <p id="rfc.section.13.p.2">Caching would be useless if it did not significantly improve performance. The goal of caching in HTTP/1.1 is to eliminate
         the need to send requests in many cases, and to eliminate the need to send full responses in many other cases. The former
         reduces the number of network round-trips required for many operations; we use an "expiration" mechanism for this purpose
         (see <a href="#expiration.model" title="Expiration Model">Section&nbsp;13.2</a>). The latter reduces network bandwidth requirements; we use a "validation" mechanism for this purpose (see <a href="#validation.model" title="Validation Model">Section&nbsp;13.3</a>).
      </p>
      <p id="rfc.section.13.p.3">Requirements for performance, availability, and disconnected operation require us to be able to relax the goal of semantic
         transparency. The HTTP/1.1 protocol allows origin servers, caches, and clients to explicitly reduce transparency when necessary.
         However, because non-transparent operation may confuse non-expert users, and might be incompatible with certain server applications
         (such as those for ordering merchandise), the protocol requires that transparency be relaxed 
      </p>
      <ul>
         <li>only by an explicit protocol-level request when relaxed by client or origin server</li>
         <li>only with an explicit warning to the end user when relaxed by cache or client</li>
      </ul>
      <p id="rfc.section.13.p.4">Therefore, the HTTP/1.1 protocol provides these important elements: </p>
      <ol>
         <li>Protocol features that provide full semantic transparency when this is required by all parties.</li>
         <li>Protocol features that allow an origin server or user agent to explicitly request and control non-transparent operation.</li>
         <li>Protocol features that allow a cache to attach warnings to responses that do not preserve the requested approximation of semantic
            transparency.
         </li>
      </ol>
      <p id="rfc.section.13.p.5">A basic principle is that it must be possible for the clients to detect any potential relaxation of semantic transparency. </p>
      <dl class="empty">
         <dd> <b>Note:</b> The server, cache, or client implementor might be faced with design decisions not explicitly discussed in this specification.
            If a decision might affect semantic transparency, the implementor ought to err on the side of maintaining transparency unless
            a careful and complete analysis shows significant benefits in breaking transparency.
         </dd>
      </dl>
      <h2 id="rfc.section.13.1"><a href="#rfc.section.13.1">13.1</a>&nbsp;
      </h2>
      <h3 id="rfc.section.13.1.1"><a href="#rfc.section.13.1.1">13.1.1</a>&nbsp;<a id="cache.correctness" href="#cache.correctness">Cache Correctness</a></h3>
      <p id="rfc.section.13.1.1.p.1">A correct cache <em class="bcp14">MUST</em> respond to a request with the most up-to-date response held by the cache that is appropriate to the request (see sections <a href="#disambiguating.expiration.values" title="Disambiguating Expiration Values">13.2.5</a>, <a href="#disambiguating.multiple.responses" title="Disambiguating Multiple Responses">13.2.6</a>, and <a href="#cache.replacement" title="Cache Replacement">13.12</a>) which meets one of the following conditions: 
      </p>
      <ol>
         <li>It has been checked for equivalence with what the origin server would have returned by revalidating the response with the
            origin server (<a href="#validation.model" title="Validation Model">Section&nbsp;13.3</a>);
         </li>
         <li>It is "fresh enough" (see <a href="#expiration.model" title="Expiration Model">Section&nbsp;13.2</a>). In the default case, this means it meets the least restrictive freshness requirement of the client, origin server, and
            cache (see <a href="#header.cache-control" id="rfc.xref.header.cache-control.2" title="Cache-Control">Section&nbsp;14.9</a>); if the origin server so specifies, it is the freshness requirement of the origin server alone. If a stored response is
            not "fresh enough" by the most restrictive freshness requirement of both the client and the origin server, in carefully considered
            circumstances the cache <em class="bcp14">MAY</em> still return the response with the appropriate Warning header (see section <a href="#exceptions.to.the.rules.and.warnings" title="Exceptions to the Rules and Warnings">13.1.5</a> and <a href="#header.warning" id="rfc.xref.header.warning.2" title="Warning">14.46</a>), unless such a response is prohibited (e.g., by a "no-store" cache-directive, or by a "no-cache" cache-request-directive;
            see <a href="#header.cache-control" id="rfc.xref.header.cache-control.3" title="Cache-Control">Section&nbsp;14.9</a>).
         </li>
         <li>It is an appropriate 304 (Not Modified), 305 (Proxy Redirect), or error (4xx or 5xx) response message.</li>
      </ol>
      <p id="rfc.section.13.1.1.p.2">If the cache can not communicate with the origin server, then a correct cache <em class="bcp14">SHOULD</em> respond as above if the response can be correctly served from the cache; if not it <em class="bcp14">MUST</em> return an error or warning indicating that there was a communication failure.
      </p>
      <p id="rfc.section.13.1.1.p.3">If a cache receives a response (either an entire response, or a 304 (Not Modified) response) that it would normally forward
         to the requesting client, and the received response is no longer fresh, the cache <em class="bcp14">SHOULD</em> forward it to the requesting client without adding a new Warning (but without removing any existing Warning headers). A cache <em class="bcp14">SHOULD NOT</em> attempt to revalidate a response simply because that response became stale in transit; this might lead to an infinite loop.
         A user agent that receives a stale response without a Warning <em class="bcp14">MAY</em> display a warning indication to the user.
      </p>
      <h3 id="rfc.section.13.1.2"><a href="#rfc.section.13.1.2">13.1.2</a>&nbsp;<a id="warnings" href="#warnings">Warnings</a></h3>
      <p id="rfc.section.13.1.2.p.1">Whenever a cache returns a response that is neither first-hand nor "fresh enough" (in the sense of condition 2 in <a href="#cache.correctness" title="Cache Correctness">Section&nbsp;13.1.1</a>), it <em class="bcp14">MUST</em> attach a warning to that effect, using a Warning general-header. The Warning header and the currently defined warnings are
         described in <a href="#header.warning" id="rfc.xref.header.warning.3" title="Warning">Section&nbsp;14.46</a>. The warning allows clients to take appropriate action.
      </p>
      <p id="rfc.section.13.1.2.p.2">Warnings <em class="bcp14">MAY</em> be used for other purposes, both cache-related and otherwise. The use of a warning, rather than an error status code, distinguish
         these responses from true failures.
      </p>
      <p id="rfc.section.13.1.2.p.3">Warnings are assigned three digit warn-codes. The first digit indicates whether the Warning <em class="bcp14">MUST</em> or <em class="bcp14">MUST NOT</em> be deleted from a stored cache entry after a successful revalidation:
      </p>
      <p id="rfc.section.13.1.2.p.4"> </p>
      <dl>
         <dt>1xx</dt>
         <dd>Warnings that describe the freshness or revalidation status of the response, and so <em class="bcp14">MUST</em> be deleted after a successful revalidation. 1XX warn-codes <em class="bcp14">MAY</em> be generated by a cache only when validating a cached entry. It <em class="bcp14">MUST NOT</em> be generated by clients.
         </dd>
         <dt>2xx</dt>
         <dd>Warnings that describe some aspect of the entity body or entity headers that is not rectified by a revalidation (for example,
            a lossy compression of the entity bodies) and which <em class="bcp14">MUST NOT</em> be deleted after a successful revalidation.
         </dd>
      </dl>
      <p id="rfc.section.13.1.2.p.5">See <a href="#header.warning" id="rfc.xref.header.warning.4" title="Warning">Section&nbsp;14.46</a> for the definitions of the codes themselves.
      </p>
      <p id="rfc.section.13.1.2.p.6">HTTP/1.0 caches will cache all Warnings in responses, without deleting the ones in the first category. Warnings in responses
         that are passed to HTTP/1.0 caches carry an extra warning-date field, which prevents a future HTTP/1.1 recipient from believing
         an erroneously cached Warning.
      </p>
      <p id="rfc.section.13.1.2.p.7">Warnings also carry a warning text. The text <em class="bcp14">MAY</em> be in any appropriate natural language (perhaps based on the client's Accept headers), and include an <em class="bcp14">OPTIONAL</em> indication of what character set is used.
      </p>
      <p id="rfc.section.13.1.2.p.8">Multiple warnings <em class="bcp14">MAY</em> be attached to a response (either by the origin server or by a cache), including multiple warnings with the same code number.
         For example, a server might provide the same warning with texts in both English and Basque.
      </p>
      <p id="rfc.section.13.1.2.p.9">When multiple warnings are attached to a response, it might not be practical or reasonable to display all of them to the user.
         This version of HTTP does not specify strict priority rules for deciding which warnings to display and in what order, but
         does suggest some heuristics.
      </p>
      <h3 id="rfc.section.13.1.3"><a href="#rfc.section.13.1.3">13.1.3</a>&nbsp;<a id="cache-control.mechanisms" href="#cache-control.mechanisms">Cache-control Mechanisms</a></h3>
      <p id="rfc.section.13.1.3.p.1">The basic cache mechanisms in HTTP/1.1 (server-specified expiration times and validators) are implicit directives to caches.
         In some cases, a server or client might need to provide explicit directives to the HTTP caches. We use the Cache-Control header
         for this purpose.
      </p>
      <p id="rfc.section.13.1.3.p.2">The Cache-Control header allows a client or server to transmit a variety of directives in either requests or responses. These
         directives typically override the default caching algorithms. As a general rule, if there is any apparent conflict between
         header values, the most restrictive interpretation is applied (that is, the one that is most likely to preserve semantic transparency).
         However, in some cases, cache-control directives are explicitly specified as weakening the approximation of semantic transparency
         (for example, "max-stale" or "public").
      </p>
      <p id="rfc.section.13.1.3.p.3">The cache-control directives are described in detail in <a href="#header.cache-control" id="rfc.xref.header.cache-control.4" title="Cache-Control">Section&nbsp;14.9</a>.
      </p>
      <h3 id="rfc.section.13.1.4"><a href="#rfc.section.13.1.4">13.1.4</a>&nbsp;<a id="explicit.ua.warnings" href="#explicit.ua.warnings">Explicit User Agent Warnings</a></h3>
      <p id="rfc.section.13.1.4.p.1">Many user agents make it possible for users to override the basic caching mechanisms. For example, the user agent might allow
         the user to specify that cached entities (even explicitly stale ones) are never validated. Or the user agent might habitually
         add "Cache-Control: max-stale=3600" to every request. The user agent <em class="bcp14">SHOULD NOT</em> default to either non-transparent behavior, or behavior that results in abnormally ineffective caching, but <em class="bcp14">MAY</em> be explicitly configured to do so by an explicit action of the user.
      </p>
      <p id="rfc.section.13.1.4.p.2">If the user has overridden the basic caching mechanisms, the user agent <em class="bcp14">SHOULD</em> explicitly indicate to the user whenever this results in the display of information that might not meet the server's transparency
         requirements (in particular, if the displayed entity is known to be stale). Since the protocol normally allows the user agent
         to determine if responses are stale or not, this indication need only be displayed when this actually happens. The indication
         need not be a dialog box; it could be an icon (for example, a picture of a rotting fish) or some other indicator.
      </p>
      <p id="rfc.section.13.1.4.p.3">If the user has overridden the caching mechanisms in a way that would abnormally reduce the effectiveness of caches, the user
         agent <em class="bcp14">SHOULD</em> continually indicate this state to the user (for example, by a display of a picture of currency in flames) so that the user
         does not inadvertently consume excess resources or suffer from excessive latency.
      </p>
      <h3 id="rfc.section.13.1.5"><a href="#rfc.section.13.1.5">13.1.5</a>&nbsp;<a id="exceptions.to.the.rules.and.warnings" href="#exceptions.to.the.rules.and.warnings">Exceptions to the Rules and Warnings</a></h3>
      <p id="rfc.section.13.1.5.p.1">In some cases, the operator of a cache <em class="bcp14">MAY</em> choose to configure it to return stale responses even when not requested by clients. This decision ought not be made lightly,
         but may be necessary for reasons of availability or performance, especially when the cache is poorly connected to the origin
         server. Whenever a cache returns a stale response, it <em class="bcp14">MUST</em> mark it as such (using a Warning header) enabling the client software to alert the user that there might be a potential problem.
      </p>
      <p id="rfc.section.13.1.5.p.2">It also allows the user agent to take steps to obtain a first-hand or fresh response. For this reason, a cache <em class="bcp14">SHOULD NOT</em> return a stale response if the client explicitly requests a first-hand or fresh one, unless it is impossible to comply for
         technical or policy reasons.
      </p>
      <h3 id="rfc.section.13.1.6"><a href="#rfc.section.13.1.6">13.1.6</a>&nbsp;<a id="client-controlled.behavior" href="#client-controlled.behavior">Client-controlled Behavior</a></h3>
      <p id="rfc.section.13.1.6.p.1">While the origin server (and to a lesser extent, intermediate caches, by their contribution to the age of a response) are
         the primary source of expiration information, in some cases the client might need to control a cache's decision about whether
         to return a cached response without validating it. Clients do this using several directives of the Cache-Control header.
      </p>
      <p id="rfc.section.13.1.6.p.2">A client's request <em class="bcp14">MAY</em> specify the maximum age it is willing to accept of an unvalidated response; specifying a value of zero forces the cache(s)
         to revalidate all responses. A client <em class="bcp14">MAY</em> also specify the minimum time remaining before a response expires. Both of these options increase constraints on the behavior
         of caches, and so cannot further relax the cache's approximation of semantic transparency.
      </p>
      <p id="rfc.section.13.1.6.p.3">A client <em class="bcp14">MAY</em> also specify that it will accept stale responses, up to some maximum amount of staleness. This loosens the constraints on
         the caches, and so might violate the origin server's specified constraints on semantic transparency, but might be necessary
         to support disconnected operation, or high availability in the face of poor connectivity.
      </p>
      <h2 id="rfc.section.13.2"><a href="#rfc.section.13.2">13.2</a>&nbsp;<a id="expiration.model" href="#expiration.model">Expiration Model</a></h2>
      <h3 id="rfc.section.13.2.1"><a href="#rfc.section.13.2.1">13.2.1</a>&nbsp;<a id="server-specified.expiration" href="#server-specified.expiration">Server-Specified Expiration</a></h3>
      <p id="rfc.section.13.2.1.p.1">HTTP caching works best when caches can entirely avoid making requests to the origin server. The primary mechanism for avoiding
         requests is for an origin server to provide an explicit expiration time in the future, indicating that a response <em class="bcp14">MAY</em> be used to satisfy subsequent requests. In other words, a cache can return a fresh response without first contacting the server.
      </p>
      <p id="rfc.section.13.2.1.p.2">Our expectation is that servers will assign future explicit expiration times to responses in the belief that the entity is
         not likely to change, in a semantically significant way, before the expiration time is reached. This normally preserves semantic
         transparency, as long as the server's expiration times are carefully chosen.
      </p>
      <p id="rfc.section.13.2.1.p.3">The expiration mechanism applies only to responses taken from a cache and not to first-hand responses forwarded immediately
         to the requesting client.
      </p>
      <p id="rfc.section.13.2.1.p.4">If an origin server wishes to force a semantically transparent cache to validate every request, it <em class="bcp14">MAY</em> assign an explicit expiration time in the past. This means that the response is always stale, and so the cache <em class="bcp14">SHOULD</em> validate it before using it for subsequent requests. See <a href="#cache.revalidation.and.reload.controls" title="Cache Revalidation and Reload Controls">Section&nbsp;14.9.4</a> for a more restrictive way to force revalidation.
      </p>
      <p id="rfc.section.13.2.1.p.5">If an origin server wishes to force any HTTP/1.1 cache, no matter how it is configured, to validate every request, it <em class="bcp14">SHOULD</em> use the "must-revalidate" cache-control directive (see <a href="#header.cache-control" id="rfc.xref.header.cache-control.5" title="Cache-Control">Section&nbsp;14.9</a>).
      </p>
      <p id="rfc.section.13.2.1.p.6">Servers specify explicit expiration times using either the Expires header, or the max-age directive of the Cache-Control header.</p>
      <p id="rfc.section.13.2.1.p.7">An expiration time cannot be used to force a user agent to refresh its display or reload a resource; its semantics apply only
         to caching mechanisms, and such mechanisms need only check a resource's expiration status when a new request for that resource
         is initiated. See <a href="#history.lists" title="History Lists">Section&nbsp;13.13</a> for an explanation of the difference between caches and history mechanisms.
      </p>
      <h3 id="rfc.section.13.2.2"><a href="#rfc.section.13.2.2">13.2.2</a>&nbsp;<a id="heuristic.expiration" href="#heuristic.expiration">Heuristic Expiration</a></h3>
      <p id="rfc.section.13.2.2.p.1">Since origin servers do not always provide explicit expiration times, HTTP caches typically assign heuristic expiration times,
         employing algorithms that use other header values (such as the Last-Modified time) to estimate a plausible expiration time.
         The HTTP/1.1 specification does not provide specific algorithms, but does impose worst-case constraints on their results.
         Since heuristic expiration times might compromise semantic transparency, they ought to used cautiously, and we encourage origin
         servers to provide explicit expiration times as much as possible.
      </p>
      <h3 id="rfc.section.13.2.3"><a href="#rfc.section.13.2.3">13.2.3</a>&nbsp;<a id="age.calculations" href="#age.calculations">Age Calculations</a></h3>
      <p id="rfc.section.13.2.3.p.1">In order to know if a cached entry is fresh, a cache needs to know if its age exceeds its freshness lifetime. We discuss how
         to calculate the latter in <a href="#expiration.calculations" title="Expiration Calculations">Section&nbsp;13.2.4</a>; this section describes how to calculate the age of a response or cache entry.
      </p>
      <p id="rfc.section.13.2.3.p.2">In this discussion, we use the term "now" to mean "the current value of the clock at the host performing the calculation."
         Hosts that use HTTP, but especially hosts running origin servers and caches, <em class="bcp14">SHOULD</em> use NTP <a href="#RFC1305" id="rfc.xref.RFC1305.1"><cite title="Network Time Protocol (Version 3) Specification, Implementation">[RFC1305]</cite></a> or some similar protocol to synchronize their clocks to a globally accurate time standard.
      </p>
      <p id="rfc.section.13.2.3.p.3">HTTP/1.1 requires origin servers to send a Date header, if possible, with every response, giving the time at which the response
         was generated (see <a href="#header.date" id="rfc.xref.header.date.2" title="Date">Section&nbsp;14.18</a>). We use the term "date_value" to denote the value of the Date header, in a form appropriate for arithmetic operations.
      </p>
      <p id="rfc.section.13.2.3.p.4">HTTP/1.1 uses the Age response-header to convey the estimated age of the response message when obtained from a cache. The
         Age field value is the cache's estimate of the amount of time since the response was generated or revalidated by the origin
         server.
      </p>
      <p id="rfc.section.13.2.3.p.5">In essence, the Age value is the sum of the time that the response has been resident in each of the caches along the path
         from the origin server, plus the amount of time it has been in transit along network paths.
      </p>
      <p id="rfc.section.13.2.3.p.6">We use the term "age_value" to denote the value of the Age header, in a form appropriate for arithmetic operations.</p>
      <p id="rfc.section.13.2.3.p.7">A response's age can be calculated in two entirely independent ways: </p>
      <ol>
         <li>now minus date_value, if the local clock is reasonably well synchronized to the origin server's clock. If the result is negative,
            the result is replaced by zero.
         </li>
         <li>age_value, if all of the caches along the response path implement HTTP/1.1.</li>
      </ol>
      <p id="rfc.section.13.2.3.p.8">Given that we have two independent ways to compute the age of a response when it is received, we can combine these as</p>
      <div id="rfc.figure.u.52"></div><pre class="text">    corrected_received_age = max(now - date_value, age_value)
</pre><p id="rfc.section.13.2.3.p.10">and as long as we have either nearly synchronized clocks or all-HTTP/1.1 paths, one gets a reliable (conservative) result.</p>
      <p id="rfc.section.13.2.3.p.11">Because of network-imposed delays, some significant interval might pass between the time that a server generates a response
         and the time it is received at the next outbound cache or client. If uncorrected, this delay could result in improperly low
         ages.
      </p>
      <p id="rfc.section.13.2.3.p.12">Because the request that resulted in the returned Age value must have been initiated prior to that Age value's generation,
         we can correct for delays imposed by the network by recording the time at which the request was initiated. Then, when an Age
         value is received, it <em class="bcp14">MUST</em> be interpreted relative to the time the request was initiated, not the time that the response was received. This algorithm
         results in conservative behavior no matter how much delay is experienced. So, we compute:
      </p>
      <div id="rfc.figure.u.53"></div><pre class="text">   corrected_initial_age = corrected_received_age
                         + (now - request_time)
</pre><p id="rfc.section.13.2.3.p.14">where "request_time" is the time (according to the local clock) when the request that elicited this response was sent.</p>
      <p id="rfc.section.13.2.3.p.15">Summary of age calculation algorithm, when a cache receives a response:</p>
      <div id="rfc.figure.u.54"></div><pre class="text">   /*
    * age_value
    *      is the value of Age: header received by the cache with
    *              this response.
    * date_value
    *      is the value of the origin server's Date: header
    * request_time
    *      is the (local) time when the cache made the request
    *              that resulted in this cached response
    * response_time
    *      is the (local) time when the cache received the
    *              response
    * now
    *      is the current (local) time
    */

   apparent_age = max(0, response_time - date_value);
   corrected_received_age = max(apparent_age, age_value);
   response_delay = response_time - request_time;
   corrected_initial_age = corrected_received_age + response_delay;
   resident_time = now - response_time;
   current_age   = corrected_initial_age + resident_time;
</pre><p id="rfc.section.13.2.3.p.17">The current_age of a cache entry is calculated by adding the amount of time (in seconds) since the cache entry was last validated
         by the origin server to the corrected_initial_age. When a response is generated from a cache entry, the cache <em class="bcp14">MUST</em> include a single Age header field in the response with a value equal to the cache entry's current_age.
      </p>
      <p id="rfc.section.13.2.3.p.18">The presence of an Age header field in a response implies that a response is not first-hand. However, the converse is not
         true, since the lack of an Age header field in a response does not imply that the response is first-hand unless all caches
         along the request path are compliant with HTTP/1.1 (i.e., older HTTP caches did not implement the Age header field).
      </p>
      <h3 id="rfc.section.13.2.4"><a href="#rfc.section.13.2.4">13.2.4</a>&nbsp;<a id="expiration.calculations" href="#expiration.calculations">Expiration Calculations</a></h3>
      <p id="rfc.section.13.2.4.p.1">In order to decide whether a response is fresh or stale, we need to compare its freshness lifetime to its age. The age is
         calculated as described in <a href="#age.calculations" title="Age Calculations">Section&nbsp;13.2.3</a>; this section describes how to calculate the freshness lifetime, and to determine if a response has expired. In the discussion
         below, the values can be represented in any form appropriate for arithmetic operations.
      </p>
      <p id="rfc.section.13.2.4.p.2">We use the term "expires_value" to denote the value of the Expires header. We use the term "max_age_value" to denote an appropriate
         value of the number of seconds carried by the "max-age" directive of the Cache-Control header in a response (see <a href="#modifications.of.the.basic.expiration.mechanism" title="Modifications of the Basic Expiration Mechanism">Section&nbsp;14.9.3</a>).
      </p>
      <p id="rfc.section.13.2.4.p.3">The max-age directive takes priority over Expires, so if max-age is present in a response, the calculation is simply:</p>
      <div id="rfc.figure.u.55"></div><pre class="text">   freshness_lifetime = max_age_value
</pre><p id="rfc.section.13.2.4.p.5">Otherwise, if Expires is present in the response, the calculation is:</p>
      <div id="rfc.figure.u.56"></div><pre class="text">   freshness_lifetime = expires_value - date_value
</pre><p id="rfc.section.13.2.4.p.7">Note that neither of these calculations is vulnerable to clock skew, since all of the information comes from the origin server.</p>
      <p id="rfc.section.13.2.4.p.8">If none of Expires, Cache-Control: max-age, or Cache-Control: s-maxage (see <a href="#modifications.of.the.basic.expiration.mechanism" title="Modifications of the Basic Expiration Mechanism">Section&nbsp;14.9.3</a>) appears in the response, and the response does not include other restrictions on caching, the cache <em class="bcp14">MAY</em> compute a freshness lifetime using a heuristic. The cache <em class="bcp14">MUST</em> attach Warning 113 to any response whose age is more than 24 hours if such warning has not already been added.
      </p>
      <p id="rfc.section.13.2.4.p.9">Also, if the response does have a Last-Modified time, the heuristic expiration value <em class="bcp14">SHOULD</em> be no more than some fraction of the interval since that time. A typical setting of this fraction might be 10%.
      </p>
      <p id="rfc.section.13.2.4.p.10">The calculation to determine if a response has expired is quite simple:</p>
      <div id="rfc.figure.u.57"></div><pre class="text">   response_is_fresh = (freshness_lifetime &gt; current_age)
</pre><h3 id="rfc.section.13.2.5"><a href="#rfc.section.13.2.5">13.2.5</a>&nbsp;<a id="disambiguating.expiration.values" href="#disambiguating.expiration.values">Disambiguating Expiration Values</a></h3>
      <p id="rfc.section.13.2.5.p.1">Because expiration values are assigned optimistically, it is possible for two caches to contain fresh values for the same
         resource that are different.
      </p>
      <p id="rfc.section.13.2.5.p.2">If a client performing a retrieval receives a non-first-hand response for a request that was already fresh in its own cache,
         and the Date header in its existing cache entry is newer than the Date on the new response, then the client <em class="bcp14">MAY</em> ignore the response. If so, it <em class="bcp14">MAY</em> retry the request with a "Cache-Control: max-age=0" directive (see <a href="#header.cache-control" id="rfc.xref.header.cache-control.6" title="Cache-Control">Section&nbsp;14.9</a>), to force a check with the origin server.
      </p>
      <p id="rfc.section.13.2.5.p.3">If a cache has two fresh responses for the same representation with different validators, it <em class="bcp14">MUST</em> use the one with the more recent Date header. This situation might arise because the cache is pooling responses from other
         caches, or because a client has asked for a reload or a revalidation of an apparently fresh cache entry.
      </p>
      <h3 id="rfc.section.13.2.6"><a href="#rfc.section.13.2.6">13.2.6</a>&nbsp;<a id="disambiguating.multiple.responses" href="#disambiguating.multiple.responses">Disambiguating Multiple Responses</a></h3>
      <p id="rfc.section.13.2.6.p.1">Because a client might be receiving responses via multiple paths, so that some responses flow through one set of caches and
         other responses flow through a different set of caches, a client might receive responses in an order different from that in
         which the origin server sent them. We would like the client to use the most recently generated response, even if older responses
         are still apparently fresh.
      </p>
      <p id="rfc.section.13.2.6.p.2">Neither the entity tag nor the expiration value can impose an ordering on responses, since it is possible that a later response
         intentionally carries an earlier expiration time. The Date values are ordered to a granularity of one second.
      </p>
      <p id="rfc.section.13.2.6.p.3">When a client tries to revalidate a cache entry, and the response it receives contains a Date header that appears to be older
         than the one for the existing entry, then the client <em class="bcp14">SHOULD</em> repeat the request unconditionally, and include
      </p>
      <div id="rfc.figure.u.58"></div><pre class="text">    Cache-Control: max-age=0
</pre><p id="rfc.section.13.2.6.p.5">to force any intermediate caches to validate their copies directly with the origin server, or</p>
      <div id="rfc.figure.u.59"></div><pre class="text">    Cache-Control: no-cache
</pre><p id="rfc.section.13.2.6.p.7">to force any intermediate caches to obtain a new copy from the origin server.</p>
      <p id="rfc.section.13.2.6.p.8">If the Date values are equal, then the client <em class="bcp14">MAY</em> use either response (or <em class="bcp14">MAY</em>, if it is being extremely prudent, request a new response). Servers <em class="bcp14">MUST NOT</em> depend on clients being able to choose deterministically between responses generated during the same second, if their expiration
         times overlap.
      </p>
      <h2 id="rfc.section.13.3"><a href="#rfc.section.13.3">13.3</a>&nbsp;<a id="validation.model" href="#validation.model">Validation Model</a></h2>
      <p id="rfc.section.13.3.p.1">When a cache has a stale entry that it would like to use as a response to a client's request, it first has to check with the
         origin server (or possibly an intermediate cache with a fresh response) to see if its cached entry is still usable. We call
         this "validating" the cache entry. Since we do not want to have to pay the overhead of retransmitting the full response if
         the cached entry is good, and we do not want to pay the overhead of an extra round trip if the cached entry is invalid, the
         HTTP/1.1 protocol supports the use of conditional methods.
      </p>
      <p id="rfc.section.13.3.p.2">The key protocol features for supporting conditional methods are those concerned with "cache validators." When an origin server
         generates a full response, it attaches some sort of validator to it, which is kept with the cache entry. When a client (user
         agent or proxy cache) makes a conditional request for a resource for which it has a cache entry, it includes the associated
         validator in the request.
      </p>
      <p id="rfc.section.13.3.p.3">The server then checks that validator against the current validator for the entity, and, if they match (see <a href="#weak.and.strong.validators" title="Weak and Strong Validators">Section&nbsp;13.3.3</a>), it responds with a special status code (usually, 304 (Not Modified)) and no entity-body. Otherwise, it returns a full response
         (including entity-body). Thus, we avoid transmitting the full response if the validator matches, and we avoid an extra round
         trip if it does not match.
      </p>
      <p id="rfc.section.13.3.p.4">In HTTP/1.1, a conditional request looks exactly the same as a normal request for the same resource, except that it carries
         a special header (which includes the validator) that implicitly turns the method (usually, GET) into a conditional.
      </p>
      <p id="rfc.section.13.3.p.5">The protocol includes both positive and negative senses of cache-validating conditions. That is, it is possible to request
         either that a method be performed if and only if a validator matches or if and only if no validators match. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> a response that lacks a validator may still be cached, and served from cache until it expires, unless this is explicitly prohibited
            by a cache-control directive. However, a cache cannot do a conditional retrieval if it does not have a validator for the entity,
            which means it will not be refreshable after it expires.
         </dd>
      </dl>
      <h3 id="rfc.section.13.3.1"><a href="#rfc.section.13.3.1">13.3.1</a>&nbsp;<a id="last-modified.dates" href="#last-modified.dates">Last-Modified Dates</a></h3>
      <p id="rfc.section.13.3.1.p.1">The Last-Modified entity-header field value is often used as a cache validator. In simple terms, a cache entry is considered
         to be valid if the entity has not been modified since the Last-Modified value.
      </p>
      <h3 id="rfc.section.13.3.2"><a href="#rfc.section.13.3.2">13.3.2</a>&nbsp;<a id="entity.tag.cache.validators" href="#entity.tag.cache.validators">Entity Tag Cache Validators</a></h3>
      <p id="rfc.section.13.3.2.p.1">The ETag response-header field value, an entity tag, provides for an "opaque" cache validator. This might allow more reliable
         validation in situations where it is inconvenient to store modification dates, where the one-second resolution of HTTP date
         values is not sufficient, or where the origin server wishes to avoid certain paradoxes that might arise from the use of modification
         dates.
      </p>
      <p id="rfc.section.13.3.2.p.2">Entity Tags are described in <a href="#entity.tags" title="Entity Tags">Section&nbsp;3.11</a>. The headers used with entity tags are described in sections <a href="#header.etag" id="rfc.xref.header.etag.4" title="ETag">14.19</a>, <a href="#header.if-match" id="rfc.xref.header.if-match.3" title="If-Match">14.24</a>, <a href="#header.if-none-match" id="rfc.xref.header.if-none-match.3" title="If-None-Match">14.26</a> and <a href="#header.vary" id="rfc.xref.header.vary.3" title="Vary">14.44</a>.
      </p>
      <h3 id="rfc.section.13.3.3"><a href="#rfc.section.13.3.3">13.3.3</a>&nbsp;<a id="weak.and.strong.validators" href="#weak.and.strong.validators">Weak and Strong Validators</a></h3>
      <p id="rfc.section.13.3.3.p.1">Since both origin servers and caches will compare two validators to decide if they represent the same or different entities,
         one normally would expect that if the entity (the entity-body or any entity-headers) changes in any way, then the associated
         validator would change as well. If this is true, then we call this validator a "strong validator."
      </p>
      <p id="rfc.section.13.3.3.p.2">However, there might be cases when a server prefers to change the validator only on semantically significant changes, and
         not when insignificant aspects of the entity change. A validator that does not always change when the resource changes is
         a "weak validator."
      </p>
      <p id="rfc.section.13.3.3.p.3">Entity tags are normally "strong validators," but the protocol provides a mechanism to tag an entity tag as "weak." One can
         think of a strong validator as one that changes whenever the bits of an entity changes, while a weak value changes whenever
         the meaning of an entity changes. Alternatively, one can think of a strong validator as part of an identifier for a specific
         entity, while a weak validator is part of an identifier for a set of semantically equivalent entities. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> One example of a strong validator is an integer that is incremented in stable storage every time an entity is changed.
         </dd>
         <dd>An entity's modification time, if represented with one-second resolution, could be a weak validator, since it is possible
            that the resource might be modified twice during a single second.
         </dd>
         <dd>Support for weak validators is optional. However, weak validators allow for more efficient caching of equivalent objects;
            for example, a hit counter on a site is probably good enough if it is updated every few days or weeks, and any value during
            that period is likely "good enough" to be equivalent.
         </dd>
      </dl>
      <p id="rfc.section.13.3.3.p.4">A "use" of a validator is either when a client generates a request and includes the validator in a validating header field,
         or when a server compares two validators.
      </p>
      <p id="rfc.section.13.3.3.p.5">Strong validators are usable in any context. Weak validators are only usable in contexts that do not depend on exact equality
         of an entity. For example, either kind is usable for a conditional GET of a full entity. However, only a strong validator
         is usable for a sub-range retrieval, since otherwise the client might end up with an internally inconsistent entity.
      </p>
      <p id="rfc.section.13.3.3.p.6">Clients <em class="bcp14">MAY</em> issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients <em class="bcp14">MUST NOT</em> use weak validators in other forms of request.
      </p>
      <p id="rfc.section.13.3.3.p.7">The only function that the HTTP/1.1 protocol defines on validators is comparison. There are two validator comparison functions,
         depending on whether the comparison context allows the use of weak validators or not: 
      </p>
      <ul>
         <li>The strong comparison function: in order to be considered equal, both validators <em class="bcp14">MUST</em> be identical in every way, and both <em class="bcp14">MUST NOT</em> be weak.
         </li>
         <li>The weak comparison function: in order to be considered equal, both validators <em class="bcp14">MUST</em> be identical in every way, but either or both of them <em class="bcp14">MAY</em> be tagged as "weak" without affecting the result.
         </li>
      </ul>
      <p id="rfc.section.13.3.3.p.8">An entity tag is strong unless it is explicitly tagged as weak. <a href="#entity.tags" title="Entity Tags">Section&nbsp;3.11</a> gives the syntax for entity tags.
      </p>
      <p id="rfc.section.13.3.3.p.9">A Last-Modified time, when used as a validator in a request, is implicitly weak unless it is possible to deduce that it is
         strong, using the following rules: 
      </p>
      <ul>
         <li>The validator is being compared by an origin server to the actual current validator for the entity and,</li>
         <li>That origin server reliably knows that the associated entity did not change twice during the second covered by the presented
            validator.
         </li>
      </ul>
      <p id="rfc.section.13.3.3.p.10">or </p>
      <ul>
         <li>The validator is about to be used by a client in an If-Modified-Since or If-Unmodified-Since header, because the client has
            a cache entry for the associated entity, and
         </li>
         <li>That cache entry includes a Date value, which gives the time when the origin server sent the original response, and</li>
         <li>The presented Last-Modified time is at least 60 seconds before the Date value.</li>
      </ul>
      <p id="rfc.section.13.3.3.p.11">or </p>
      <ul>
         <li>The validator is being compared by an intermediate cache to the validator stored in its cache entry for the entity, and</li>
         <li>That cache entry includes a Date value, which gives the time when the origin server sent the original response, and</li>
         <li>The presented Last-Modified time is at least 60 seconds before the Date value.</li>
      </ul>
      <p id="rfc.section.13.3.3.p.12">This method relies on the fact that if two different responses were sent by the origin server during the same second, but
         both had the same Last-Modified time, then at least one of those responses would have a Date value equal to its Last-Modified
         time. The arbitrary 60-second limit guards against the possibility that the Date and Last-Modified values are generated from
         different clocks, or at somewhat different times during the preparation of the response. An implementation <em class="bcp14">MAY</em> use a value larger than 60 seconds, if it is believed that 60 seconds is too short.
      </p>
      <p id="rfc.section.13.3.3.p.13">If a client wishes to perform a sub-range retrieval on a value for which it has only a Last-Modified time and no opaque validator,
         it <em class="bcp14">MAY</em> do this only if the Last-Modified time is strong in the sense described here.
      </p>
      <p id="rfc.section.13.3.3.p.14">A cache or origin server receiving a conditional request, other than a full-body GET request, <em class="bcp14">MUST</em> use the strong comparison function to evaluate the condition.
      </p>
      <p id="rfc.section.13.3.3.p.15">These rules allow HTTP/1.1 caches and clients to safely perform sub-range retrievals on values that have been obtained from
         HTTP/1.0 servers.
      </p>
      <h3 id="rfc.section.13.3.4"><a href="#rfc.section.13.3.4">13.3.4</a>&nbsp;<a id="rules.for.when.to.use.entity.tags.and.last-modified.dates" href="#rules.for.when.to.use.entity.tags.and.last-modified.dates">Rules for When to Use Entity Tags and Last-Modified Dates</a></h3>
      <p id="rfc.section.13.3.4.p.1">We adopt a set of rules and recommendations for origin servers, clients, and caches regarding when various validator types
         ought to be used, and for what purposes.
      </p>
      <p id="rfc.section.13.3.4.p.2">HTTP/1.1 origin servers: </p>
      <ul>
         <li><em class="bcp14">SHOULD</em> send an entity tag validator unless it is not feasible to generate one.
         </li>
         <li><em class="bcp14">MAY</em> send a weak entity tag instead of a strong entity tag, if performance considerations support the use of weak entity tags,
            or if it is unfeasible to send a strong entity tag.
         </li>
         <li><em class="bcp14">SHOULD</em> send a Last-Modified value if it is feasible to send one, unless the risk of a breakdown in semantic transparency that could
            result from using this date in an If-Modified-Since header would lead to serious problems.
         </li>
      </ul>
      <p id="rfc.section.13.3.4.p.3">In other words, the preferred behavior for an HTTP/1.1 origin server is to send both a strong entity tag and a Last-Modified
         value.
      </p>
      <p id="rfc.section.13.3.4.p.4">In order to be legal, a strong entity tag <em class="bcp14">MUST</em> change whenever the associated entity value changes in any way. A weak entity tag <em class="bcp14">SHOULD</em> change whenever the associated entity changes in a semantically significant way. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> in order to provide semantically transparent caching, an origin server must avoid reusing a specific strong entity tag value
            for two different entities, or reusing a specific weak entity tag value for two semantically different entities. Cache entries
            might persist for arbitrarily long periods, regardless of expiration times, so it might be inappropriate to expect that a
            cache will never again attempt to validate an entry using a validator that it obtained at some point in the past.
         </dd>
      </dl>
      <p id="rfc.section.13.3.4.p.5">HTTP/1.1 clients: </p>
      <ul>
         <li>If an entity tag has been provided by the origin server, <em class="bcp14">MUST</em> use that entity tag in any cache-conditional request (using If-Match or If-None-Match).
         </li>
         <li>If only a Last-Modified value has been provided by the origin server, <em class="bcp14">SHOULD</em> use that value in non-subrange cache-conditional requests (using If-Modified-Since).
         </li>
         <li>If only a Last-Modified value has been provided by an HTTP/1.0 origin server, <em class="bcp14">MAY</em> use that value in subrange cache-conditional requests (using If-Unmodified-Since:). The user agent <em class="bcp14">SHOULD</em> provide a way to disable this, in case of difficulty.
         </li>
         <li>If both an entity tag and a Last-Modified value have been provided by the origin server, <em class="bcp14">SHOULD</em> use both validators in cache-conditional requests. This allows both HTTP/1.0 and HTTP/1.1 caches to respond appropriately.
         </li>
      </ul>
      <p id="rfc.section.13.3.4.p.6">An HTTP/1.1 origin server, upon receiving a conditional request that includes both a Last-Modified date (e.g., in an If-Modified-Since
         or If-Unmodified-Since header field) and one or more entity tags (e.g., in an If-Match, If-None-Match, or If-Range header
         field) as cache validators, <em class="bcp14">MUST NOT</em> return a response status of 304 (Not Modified) unless doing so is consistent with all of the conditional header fields in
         the request.
      </p>
      <p id="rfc.section.13.3.4.p.7">An HTTP/1.1 caching proxy, upon receiving a conditional request that includes both a Last-Modified date and one or more entity
         tags as cache validators, <em class="bcp14">MUST NOT</em> return a locally cached response to the client unless that cached response is consistent with all of the conditional header
         fields in the request. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> The general principle behind these rules is that HTTP/1.1 servers and clients should transmit as much non-redundant information
            as is available in their responses and requests. HTTP/1.1 systems receiving this information will make the most conservative
            assumptions about the validators they receive.
         </dd>
         <dd>HTTP/1.0 clients and caches will ignore entity tags. Generally, last-modified values received or used by these systems will
            support transparent and efficient caching, and so HTTP/1.1 origin servers should provide Last-Modified values. In those rare
            cases where the use of a Last-Modified value as a validator by an HTTP/1.0 system could result in a serious problem, then
            HTTP/1.1 origin servers should not provide one.
         </dd>
      </dl>
      <h3 id="rfc.section.13.3.5"><a href="#rfc.section.13.3.5">13.3.5</a>&nbsp;<a id="non-validating.conditionals" href="#non-validating.conditionals">Non-validating Conditionals</a></h3>
      <p id="rfc.section.13.3.5.p.1">The principle behind entity tags is that only the service author knows the semantics of a resource well enough to select an
         appropriate cache validation mechanism, and the specification of any validator comparison function more complex than byte-equality
         would open up a can of worms. Thus, comparisons of any other headers (except Last-Modified, for compatibility with HTTP/1.0)
         are never used for purposes of validating a cache entry.
      </p>
      <h2 id="rfc.section.13.4"><a href="#rfc.section.13.4">13.4</a>&nbsp;<a id="response.cacheability" href="#response.cacheability">Response Cacheability</a></h2>
      <p id="rfc.section.13.4.p.1">Unless specifically constrained by a cache-control (<a href="#header.cache-control" id="rfc.xref.header.cache-control.7" title="Cache-Control">Section&nbsp;14.9</a>) directive, a caching system <em class="bcp14">MAY</em> always store a successful response (see <a href="#errors.or.incomplete.response.cache.behavior" title="Errors or Incomplete Response Cache Behavior">Section&nbsp;13.8</a>) as a cache entry, <em class="bcp14">MAY</em> return it without validation if it is fresh, and <em class="bcp14">MAY</em> return it after successful validation. If there is neither a cache validator nor an explicit expiration time associated with
         a response, we do not expect it to be cached, but certain caches <em class="bcp14">MAY</em> violate this expectation (for example, when little or no network connectivity is available). A client can usually detect that
         such a response was taken from a cache by comparing the Date header to the current time. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> some HTTP/1.0 caches are known to violate this expectation without providing any Warning.
         </dd>
      </dl>
      <p id="rfc.section.13.4.p.2">However, in some cases it might be inappropriate for a cache to retain an entity, or to return it in response to a subsequent
         request. This might be because absolute semantic transparency is deemed necessary by the service author, or because of security
         or privacy considerations. Certain cache-control directives are therefore provided so that the server can indicate that certain
         resource entities, or portions thereof, are not to be cached regardless of other considerations.
      </p>
      <p id="rfc.section.13.4.p.3">Note that <a href="#header.authorization" id="rfc.xref.header.authorization.3" title="Authorization">Section&nbsp;14.8</a> normally prevents a shared cache from saving and returning a response to a previous request if that request included an Authorization
         header.
      </p>
      <p id="rfc.section.13.4.p.4">A response received with a status code of 200, 203, 206, 300, 301 or 410 <em class="bcp14">MAY</em> be stored by a cache and used in reply to a subsequent request, subject to the expiration mechanism, unless a cache-control
         directive prohibits caching. However, a cache that does not support the Range and Content-Range headers <em class="bcp14">MUST NOT</em> cache 206 (Partial Content) responses.
      </p>
      <p id="rfc.section.13.4.p.5">A response received with any other status code (e.g. status codes 302 and 307) <em class="bcp14">MUST NOT</em> be returned in a reply to a subsequent request unless there are cache-control directives or another header(s) that explicitly
         allow it. For example, these include the following: an Expires header (<a href="#header.expires" id="rfc.xref.header.expires.2" title="Expires">Section&nbsp;14.21</a>); a "max-age", "s-maxage", "must-revalidate", "proxy-revalidate", "public" or "private" cache-control directive (<a href="#header.cache-control" id="rfc.xref.header.cache-control.8" title="Cache-Control">Section&nbsp;14.9</a>).
      </p>
      <h2 id="rfc.section.13.5"><a href="#rfc.section.13.5">13.5</a>&nbsp;<a id="constructing.responses.from.caches" href="#constructing.responses.from.caches">Constructing Responses From Caches</a></h2>
      <p id="rfc.section.13.5.p.1">The purpose of an HTTP cache is to store information received in response to requests for use in responding to future requests.
         In many cases, a cache simply returns the appropriate parts of a response to the requester. However, if the cache holds a
         cache entry based on a previous response, it might have to combine parts of a new response with what is held in the cache
         entry.
      </p>
      <h3 id="rfc.section.13.5.1"><a href="#rfc.section.13.5.1">13.5.1</a>&nbsp;<a id="end-to-end.and.hop-by-hop.headers" href="#end-to-end.and.hop-by-hop.headers">End-to-end and Hop-by-hop Headers</a></h3>
      <p id="rfc.section.13.5.1.p.1">For the purpose of defining the behavior of caches and non-caching proxies, we divide HTTP headers into two categories: </p>
      <ul>
         <li>End-to-end headers, which are transmitted to the ultimate recipient of a request or response. End-to-end headers in responses <em class="bcp14">MUST</em> be stored as part of a cache entry and <em class="bcp14">MUST</em> be transmitted in any response formed from a cache entry.
         </li>
         <li>Hop-by-hop headers, which are meaningful only for a single transport-level connection, and are not stored by caches or forwarded
            by proxies.
         </li>
      </ul>
      <p id="rfc.section.13.5.1.p.2">The following HTTP/1.1 headers are hop-by-hop headers: </p>
      <ul>
         <li>Connection</li>
         <li>Keep-Alive</li>
         <li>Proxy-Authenticate</li>
         <li>Proxy-Authorization</li>
         <li>TE</li>
         <li>Trailers</li>
         <li>Transfer-Encoding</li>
         <li>Upgrade</li>
      </ul>
      <p id="rfc.section.13.5.1.p.3">All other headers defined by HTTP/1.1 are end-to-end headers.</p>
      <p id="rfc.section.13.5.1.p.4">Other hop-by-hop headers <em class="bcp14">MUST</em> be listed in a Connection header, (<a href="#header.connection" id="rfc.xref.header.connection.4" title="Connection">Section&nbsp;14.10</a>) to be introduced into HTTP/1.1 (or later).
      </p>
      <h3 id="rfc.section.13.5.2"><a href="#rfc.section.13.5.2">13.5.2</a>&nbsp;<a id="non-modifiable.headers" href="#non-modifiable.headers">Non-modifiable Headers</a></h3>
      <p id="rfc.section.13.5.2.p.1">Some features of the HTTP/1.1 protocol, such as Digest Authentication, depend on the value of certain end-to-end headers.
         A transparent proxy <em class="bcp14">SHOULD NOT</em> modify an end-to-end header unless the definition of that header requires or specifically allows that.
      </p>
      <p id="rfc.section.13.5.2.p.2">A transparent proxy <em class="bcp14">MUST NOT</em> modify any of the following fields in a request or response, and it <em class="bcp14">MUST NOT</em> add any of these fields if not already present: 
      </p>
      <ul>
         <li>Content-Location</li>
         <li>Content-MD5</li>
         <li>ETag</li>
         <li>Last-Modified</li>
      </ul>
      <p id="rfc.section.13.5.2.p.3">A transparent proxy <em class="bcp14">MUST NOT</em> modify any of the following fields in a response: 
      </p>
      <ul>
         <li>Expires</li>
      </ul>
      <p id="rfc.section.13.5.2.p.4">but it <em class="bcp14">MAY</em> add any of these fields if not already present. If an Expires header is added, it <em class="bcp14">MUST</em> be given a field-value identical to that of the Date header in that response.
      </p>
      <p id="rfc.section.13.5.2.p.5">A proxy <em class="bcp14">MUST NOT</em> modify or add any of the following fields in a message that contains the no-transform cache-control directive, or in any request: 
      </p>
      <ul>
         <li>Content-Encoding</li>
         <li>Content-Range</li>
         <li>Content-Type</li>
      </ul>
      <p id="rfc.section.13.5.2.p.6">A non-transparent proxy <em class="bcp14">MAY</em> modify or add these fields to a message that does not include no-transform, but if it does so, it <em class="bcp14">MUST</em> add a Warning 214 (Transformation applied) if one does not already appear in the message (see <a href="#header.warning" id="rfc.xref.header.warning.5" title="Warning">Section&nbsp;14.46</a>). 
      </p>
      <dl class="empty">
         <dd>Warning: unnecessary modification of end-to-end headers might cause authentication failures if stronger authentication mechanisms
            are introduced in later versions of HTTP. Such authentication mechanisms <em class="bcp14">MAY</em> rely on the values of header fields not listed here.
         </dd>
      </dl>
      <p id="rfc.section.13.5.2.p.7">The Content-Length field of a request or response is added or deleted according to the rules in <a href="#message.length" title="Message Length">Section&nbsp;4.4</a>. A transparent proxy <em class="bcp14">MUST</em> preserve the entity-length (<a href="#entity.length" title="Entity Length">Section&nbsp;7.2.2</a>) of the entity-body, although it <em class="bcp14">MAY</em> change the transfer-length (<a href="#message.length" title="Message Length">Section&nbsp;4.4</a>).
      </p>
      <h3 id="rfc.section.13.5.3"><a href="#rfc.section.13.5.3">13.5.3</a>&nbsp;<a id="combining.headers" href="#combining.headers">Combining Headers</a></h3>
      <p id="rfc.section.13.5.3.p.1">When a cache makes a validating request to a server, and the server provides a 304 (Not Modified) response or a 206 (Partial
         Content) response, the cache then constructs a response to send to the requesting client.
      </p>
      <p id="rfc.section.13.5.3.p.2">If the status code is 304 (Not Modified), the cache uses the entity-body stored in the cache entry as the entity-body of this
         outgoing response. If the status code is 206 (Partial Content) and the ETag or Last-Modified headers match exactly, the cache <em class="bcp14">MAY</em> combine the contents stored in the cache entry with the new contents received in the response and use the result as the entity-body
         of this outgoing response, (see <a href="#combining.byte.ranges" title="Combining Byte Ranges">13.5.4</a>).
      </p>
      <p id="rfc.section.13.5.3.p.3">The end-to-end headers stored in the cache entry are used for the constructed response, except that </p>
      <ul>
         <li>any stored Warning headers with warn-code 1xx (see <a href="#header.warning" id="rfc.xref.header.warning.6" title="Warning">Section&nbsp;14.46</a>) <em class="bcp14">MUST</em> be deleted from the cache entry and the forwarded response.
         </li>
         <li>any stored Warning headers with warn-code 2xx <em class="bcp14">MUST</em> be retained in the cache entry and the forwarded response.
         </li>
         <li>any end-to-end headers provided in the 304 or 206 response <em class="bcp14">MUST</em> replace the corresponding headers from the cache entry.
         </li>
      </ul>
      <p id="rfc.section.13.5.3.p.4">Unless the cache decides to remove the cache entry, it <em class="bcp14">MUST</em> also replace the end-to-end headers stored with the cache entry with corresponding headers received in the incoming response,
         except for Warning headers as described immediately above. If a header field-name in the incoming response matches more than
         one header in the cache entry, all such old headers <em class="bcp14">MUST</em> be replaced.
      </p>
      <p id="rfc.section.13.5.3.p.5">In other words, the set of end-to-end headers received in the incoming response overrides all corresponding end-to-end headers
         stored with the cache entry (except for stored Warning headers with warn-code 1xx, which are deleted even if not overridden). 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> this rule allows an origin server to use a 304 (Not Modified) or a 206 (Partial Content) response to update any header associated
            with a previous response for the same entity or sub-ranges thereof, although it might not always be meaningful or correct
            to do so. This rule does not allow an origin server to use a 304 (Not Modified) or a 206 (Partial Content) response to entirely
            delete a header that it had provided with a previous response.
         </dd>
      </dl>
      <h3 id="rfc.section.13.5.4"><a href="#rfc.section.13.5.4">13.5.4</a>&nbsp;<a id="combining.byte.ranges" href="#combining.byte.ranges">Combining Byte Ranges</a></h3>
      <p id="rfc.section.13.5.4.p.1">A response might transfer only a subrange of the bytes of an entity-body, either because the request included one or more
         Range specifications, or because a connection was broken prematurely. After several such transfers, a cache might have received
         several ranges of the same entity-body.
      </p>
      <p id="rfc.section.13.5.4.p.2">If a cache has a stored non-empty set of subranges for an entity, and an incoming response transfers another subrange, the
         cache <em class="bcp14">MAY</em> combine the new subrange with the existing set if both the following conditions are met: 
      </p>
      <ul>
         <li>Both the incoming response and the cache entry have a cache validator.</li>
         <li>The two cache validators match using the strong comparison function (see <a href="#weak.and.strong.validators" title="Weak and Strong Validators">Section&nbsp;13.3.3</a>).
         </li>
      </ul>
      <p id="rfc.section.13.5.4.p.3">If either requirement is not met, the cache <em class="bcp14">MUST</em> use only the most recent partial response (based on the Date values transmitted with every response, and using the incoming
         response if these values are equal or missing), and <em class="bcp14">MUST</em> discard the other partial information.
      </p>
      <h2 id="rfc.section.13.6"><a href="#rfc.section.13.6">13.6</a>&nbsp;<a id="caching.negotiated.responses" href="#caching.negotiated.responses">Caching Negotiated Responses</a></h2>
      <p id="rfc.section.13.6.p.1">Use of server-driven content negotiation (<a href="#server-driven.negotiation" title="Server-driven Negotiation">Section&nbsp;12.1</a>), as indicated by the presence of a Vary header field in a response, alters the conditions and procedure by which a cache
         can use the response for subsequent requests. See <a href="#header.vary" id="rfc.xref.header.vary.4" title="Vary">Section&nbsp;14.44</a> for use of the Vary header field by servers.
      </p>
      <p id="rfc.section.13.6.p.2">A server <em class="bcp14">SHOULD</em> use the Vary header field to inform a cache of what request-header fields were used to select among multiple representations
         of a cacheable response subject to server-driven negotiation. The set of header fields named by the Vary field value is known
         as the "selecting" request-headers.
      </p>
      <p id="rfc.section.13.6.p.3">When the cache receives a subsequent request whose Request-URI specifies one or more cache entries including a Vary header
         field, the cache <em class="bcp14">MUST NOT</em> use such a cache entry to construct a response to the new request unless all of the selecting request-headers present in the
         new request match the corresponding stored request-headers in the original request.
      </p>
      <p id="rfc.section.13.6.p.4">The selecting request-headers from two requests are defined to match if and only if the selecting request-headers in the first
         request can be transformed to the selecting request-headers in the second request by adding or removing linear white space
         (LWS) at places where this is allowed by the corresponding BNF, and/or combining multiple message-header fields with the same
         field name following the rules about message headers in <a href="#message.headers" title="Message Headers">Section&nbsp;4.2</a>.
      </p>
      <p id="rfc.section.13.6.p.5">A Vary header field-value of "*" always fails to match and subsequent requests on that resource can only be properly interpreted
         by the origin server.
      </p>
      <p id="rfc.section.13.6.p.6">If the selecting request header fields for the cached entry do not match the selecting request header fields of the new request,
         then the cache <em class="bcp14">MUST NOT</em> use a cached entry to satisfy the request unless it first relays the new request to the origin server in a conditional request
         and the server responds with 304 (Not Modified), including an entity tag or Content-Location that indicates the entity to
         be used.
      </p>
      <p id="rfc.section.13.6.p.7">If an entity tag was assigned to a cached representation, the forwarded request <em class="bcp14">SHOULD</em> be conditional and include the entity tags in an If-None-Match header field from all its cache entries for the resource. This
         conveys to the server the set of entities currently held by the cache, so that if any one of these entities matches the requested
         entity, the server can use the ETag header field in its 304 (Not Modified) response to tell the cache which entry is appropriate.
         If the entity-tag of the new response matches that of an existing entry, the new response <em class="bcp14">SHOULD</em> be used to update the header fields of the existing entry, and the result <em class="bcp14">MUST</em> be returned to the client.
      </p>
      <p id="rfc.section.13.6.p.8">If any of the existing cache entries contains only partial content for the associated entity, its entity-tag <em class="bcp14">SHOULD NOT</em> be included in the If-None-Match header field unless the request is for a range that would be fully satisfied by that entry.
      </p>
      <p id="rfc.section.13.6.p.9">If a cache receives a successful response whose Content-Location field matches that of an existing cache entry for the same
         Request-URI, whose entity-tag differs from that of the existing entry, and whose Date is more recent than that of the existing
         entry, the existing entry <em class="bcp14">SHOULD NOT</em> be returned in response to future requests and <em class="bcp14">SHOULD</em> be deleted from the cache.
      </p>
      <h2 id="rfc.section.13.7"><a href="#rfc.section.13.7">13.7</a>&nbsp;<a id="shared.and.non-shared.caches" href="#shared.and.non-shared.caches">Shared and Non-Shared Caches</a></h2>
      <p id="rfc.section.13.7.p.1">For reasons of security and privacy, it is necessary to make a distinction between "shared" and "non-shared" caches. A non-shared
         cache is one that is accessible only to a single user. Accessibility in this case <em class="bcp14">SHOULD</em> be enforced by appropriate security mechanisms. All other caches are considered to be "shared." Other sections of this specification
         place certain constraints on the operation of shared caches in order to prevent loss of privacy or failure of access controls.
      </p>
      <h2 id="rfc.section.13.8"><a href="#rfc.section.13.8">13.8</a>&nbsp;<a id="errors.or.incomplete.response.cache.behavior" href="#errors.or.incomplete.response.cache.behavior">Errors or Incomplete Response Cache Behavior</a></h2>
      <p id="rfc.section.13.8.p.1">A cache that receives an incomplete response (for example, with fewer bytes of data than specified in a Content-Length header) <em class="bcp14">MAY</em> store the response. However, the cache <em class="bcp14">MUST</em> treat this as a partial response. Partial responses <em class="bcp14">MAY</em> be combined as described in <a href="#combining.byte.ranges" title="Combining Byte Ranges">Section&nbsp;13.5.4</a>; the result might be a full response or might still be partial. A cache <em class="bcp14">MUST NOT</em> return a partial response to a client without explicitly marking it as such, using the 206 (Partial Content) status code.
         A cache <em class="bcp14">MUST NOT</em> return a partial response using a status code of 200 (OK).
      </p>
      <p id="rfc.section.13.8.p.2">If a cache receives a 5xx response while attempting to revalidate an entry, it <em class="bcp14">MAY</em> either forward this response to the requesting client, or act as if the server failed to respond. In the latter case, it <em class="bcp14">MAY</em> return a previously received response unless the cached entry includes the "must-revalidate" cache-control directive (see <a href="#header.cache-control" id="rfc.xref.header.cache-control.9" title="Cache-Control">Section&nbsp;14.9</a>).
      </p>
      <h2 id="rfc.section.13.9"><a href="#rfc.section.13.9">13.9</a>&nbsp;<a id="side.effects.of.get.and.head" href="#side.effects.of.get.and.head">Side Effects of GET and HEAD</a></h2>
      <p id="rfc.section.13.9.p.1">Unless the origin server explicitly prohibits the caching of their responses, the application of GET and HEAD methods to any
         resources <em class="bcp14">SHOULD NOT</em> have side effects that would lead to erroneous behavior if these responses are taken from a cache. They <em class="bcp14">MAY</em> still have side effects, but a cache is not required to consider such side effects in its caching decisions. Caches are always
         expected to observe an origin server's explicit restrictions on caching.
      </p>
      <p id="rfc.section.13.9.p.2">We note one exception to this rule: since some applications have traditionally used GETs and HEADs with query URLs (those
         containing a "?" in the rel_path part) to perform operations with significant side effects, caches <em class="bcp14">MUST NOT</em> treat responses to such URIs as fresh unless the server provides an explicit expiration time. This specifically means that
         responses from HTTP/1.0 servers for such URIs <em class="bcp14">SHOULD NOT</em> be taken from a cache. See <a href="#safe.methods" title="Safe Methods">Section&nbsp;9.1.1</a> for related information.
      </p>
      <h2 id="rfc.section.13.10"><a href="#rfc.section.13.10">13.10</a>&nbsp;<a id="invalidation.after.updates.or.deletions" href="#invalidation.after.updates.or.deletions">Invalidation After Updates or Deletions</a></h2>
      <p id="rfc.section.13.10.p.1">The effect of certain methods performed on a resource at the origin server might cause one or more existing cache entries
         to become non-transparently invalid. That is, although they might continue to be "fresh," they do not accurately reflect what
         the origin server would return for a new request on that resource.
      </p>
      <p id="rfc.section.13.10.p.2">There is no way for the HTTP protocol to guarantee that all such cache entries are marked invalid. For example, the request
         that caused the change at the origin server might not have gone through the proxy where a cache entry is stored. However,
         several rules help reduce the likelihood of erroneous behavior.
      </p>
      <p id="rfc.section.13.10.p.3">In this section, the phrase "invalidate an entity" means that the cache will either remove all instances of that entity from
         its storage, or will mark these as "invalid" and in need of a mandatory revalidation before they can be returned in response
         to a subsequent request.
      </p>
      <p id="rfc.section.13.10.p.4">Some HTTP methods <em class="bcp14">MUST</em> cause a cache to invalidate an entity. This is either the entity referred to by the Request-URI, or by the Location or Content-Location
         headers (if present). These methods are: 
      </p>
      <ul>
         <li>PUT</li>
         <li>DELETE</li>
         <li>POST</li>
      </ul>
      <p id="rfc.section.13.10.p.5">In order to prevent denial of service attacks, an invalidation based on the URI in a Location or Content-Location header <em class="bcp14">MUST</em> only be performed if the host part is the same as in the Request-URI.
      </p>
      <p id="rfc.section.13.10.p.6">A cache that passes through requests for methods it does not understand <em class="bcp14">SHOULD</em> invalidate any entities referred to by the Request-URI.
      </p>
      <h2 id="rfc.section.13.11"><a href="#rfc.section.13.11">13.11</a>&nbsp;<a id="write-through.mandatory" href="#write-through.mandatory">Write-Through Mandatory</a></h2>
      <p id="rfc.section.13.11.p.1">All methods that might be expected to cause modifications to the origin server's resources <em class="bcp14">MUST</em> be written through to the origin server. This currently includes all methods except for GET and HEAD. A cache <em class="bcp14">MUST NOT</em> reply to such a request from a client before having transmitted the request to the inbound server, and having received a corresponding
         response from the inbound server. This does not prevent a proxy cache from sending a 100 (Continue) response before the inbound
         server has sent its final reply.
      </p>
      <p id="rfc.section.13.11.p.2">The alternative (known as "write-back" or "copy-back" caching) is not allowed in HTTP/1.1, due to the difficulty of providing
         consistent updates and the problems arising from server, cache, or network failure prior to write-back.
      </p>
      <h2 id="rfc.section.13.12"><a href="#rfc.section.13.12">13.12</a>&nbsp;<a id="cache.replacement" href="#cache.replacement">Cache Replacement</a></h2>
      <p id="rfc.section.13.12.p.1">If a new cacheable (see sections <a href="#what.may.be.stored.by.caches" title="What May be Stored by Caches">14.9.2</a>, <a href="#disambiguating.expiration.values" title="Disambiguating Expiration Values">13.2.5</a>, <a href="#disambiguating.multiple.responses" title="Disambiguating Multiple Responses">13.2.6</a> and <a href="#errors.or.incomplete.response.cache.behavior" title="Errors or Incomplete Response Cache Behavior">13.8</a>) response is received from a resource while any existing responses for the same resource are cached, the cache <em class="bcp14">SHOULD</em> use the new response to reply to the current request. It <em class="bcp14">MAY</em> insert it into cache storage and <em class="bcp14">MAY</em>, if it meets all other requirements, use it to respond to any future requests that would previously have caused the old response
         to be returned. If it inserts the new response into cache storage the rules in <a href="#combining.headers" title="Combining Headers">Section&nbsp;13.5.3</a> apply. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> a new response that has an older Date header value than existing cached responses is not cacheable.
         </dd>
      </dl>
      <h2 id="rfc.section.13.13"><a href="#rfc.section.13.13">13.13</a>&nbsp;<a id="history.lists" href="#history.lists">History Lists</a></h2>
      <p id="rfc.section.13.13.p.1">User agents often have history mechanisms, such as "Back" buttons and history lists, which can be used to redisplay an entity
         retrieved earlier in a session.
      </p>
      <p id="rfc.section.13.13.p.2">History mechanisms and caches are different. In particular history mechanisms <em class="bcp14">SHOULD NOT</em> try to show a semantically transparent view of the current state of a resource. Rather, a history mechanism is meant to show
         exactly what the user saw at the time when the resource was retrieved.
      </p>
      <p id="rfc.section.13.13.p.3">By default, an expiration time does not apply to history mechanisms. If the entity is still in storage, a history mechanism <em class="bcp14">SHOULD</em> display it even if the entity has expired, unless the user has specifically configured the agent to refresh expired history
         documents.
      </p>
      <p id="rfc.section.13.13.p.4">This is not to be construed to prohibit the history mechanism from telling the user that a view might be stale. </p>
      <dl class="empty">
         <dd> <b>Note:</b> if history list mechanisms unnecessarily prevent users from viewing stale resources, this will tend to force service authors
            to avoid using HTTP expiration controls and cache controls when they would otherwise like to. Service authors may consider
            it important that users not be presented with error messages or warning messages when they use navigation controls (such as
            BACK) to view previously fetched resources. Even though sometimes such resources ought not to cached, or ought to expire quickly,
            user interface considerations may force service authors to resort to other means of preventing caching (e.g. "once-only" URLs)
            in order not to suffer the effects of improperly functioning history mechanisms.
         </dd>
      </dl>
      <h1 id="rfc.section.14"><a href="#rfc.section.14">14.</a>&nbsp;<a id="header.fields" href="#header.fields">Header Field Definitions</a></h1>
      <p id="rfc.section.14.p.1">This section defines the syntax and semantics of all standard HTTP/1.1 header fields. For entity-header fields, both sender
         and recipient refer to either the client or the server, depending on who sends and who receives the entity.
      </p>
      <div id="rfc.iref.a.2"></div>
      <div id="rfc.iref.h.3"></div>
      <h2 id="rfc.section.14.1"><a href="#rfc.section.14.1">14.1</a>&nbsp;<a id="header.accept" href="#header.accept">Accept</a></h2>
      <p id="rfc.section.14.1.p.1">The Accept request-header field can be used to specify certain media types which are acceptable for the response. Accept headers
         can be used to indicate that the request is specifically limited to a small set of desired types, as in the case of a request
         for an in-line image.
      </p>
      <div id="rfc.figure.u.60"></div><pre class="inline"><span id="rfc.iref.g.95"></span><span id="rfc.iref.g.96"></span><span id="rfc.iref.g.97"></span><span id="rfc.iref.g.98"></span>    Accept         = "Accept" ":"
                     #( media-range [ accept-params ] )

    media-range    = ( "*/*"
                     | ( type "/" "*" )
                     | ( type "/" subtype )
                     ) *( ";" parameter )
    accept-params  = ";" "q" "=" qvalue *( accept-extension )
    accept-extension = ";" token [ "=" ( token | quoted-string ) ]
</pre><p id="rfc.section.14.1.p.3">The asterisk "*" character is used to group media types into ranges, with "*/*" indicating all media types and "type/*" indicating
         all subtypes of that type. The media-range <em class="bcp14">MAY</em> include media type parameters that are applicable to that range.
      </p>
      <p id="rfc.section.14.1.p.4">Each media-range <em class="bcp14">MAY</em> be followed by one or more accept-params, beginning with the "q" parameter for indicating a relative quality factor. The first
         "q" parameter (if any) separates the media-range parameter(s) from the accept-params. Quality factors allow the user or user
         agent to indicate the relative degree of preference for that media-range, using the qvalue scale from 0 to 1 (<a href="#quality.values" title="Quality Values">Section&nbsp;3.9</a>). The default value is q=1. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> Use of the "q" parameter name to separate media type parameters from Accept extension parameters is due to historical practice.
            Although this prevents any media type parameter named "q" from being used with a media range, such an event is believed to
            be unlikely given the lack of any "q" parameters in the IANA media type registry and the rare usage of any media type parameters
            in Accept. Future media types are discouraged from registering any parameter named "q".
         </dd>
      </dl>
      <p id="rfc.section.14.1.p.5">The example</p>
      <div id="rfc.figure.u.61"></div><pre class="text">    Accept: audio/*; q=0.2, audio/basic
</pre><p id="rfc.section.14.1.p.7"> <em class="bcp14">SHOULD</em> be interpreted as "I prefer audio/basic, but send me any audio type if it is the best available after an 80% mark-down in
         quality."
      </p>
      <p id="rfc.section.14.1.p.8">If no Accept header field is present, then it is assumed that the client accepts all media types. If an Accept header field
         is present, and if the server cannot send a response which is acceptable according to the combined Accept field value, then
         the server <em class="bcp14">SHOULD</em> send a 406 (not acceptable) response.
      </p>
      <p id="rfc.section.14.1.p.9">A more elaborate example is</p>
      <div id="rfc.figure.u.62"></div><pre class="text">    Accept: text/plain; q=0.5, text/html,
            text/x-dvi; q=0.8, text/x-c
</pre><p id="rfc.section.14.1.p.11">Verbally, this would be interpreted as "text/html and text/x-c are the preferred media types, but if they do not exist, then
         send the text/x-dvi entity, and if that does not exist, send the text/plain entity."
      </p>
      <p id="rfc.section.14.1.p.12">Media ranges can be overridden by more specific media ranges or specific media types. If more than one media range applies
         to a given type, the most specific reference has precedence. For example,
      </p>
      <div id="rfc.figure.u.63"></div><pre class="text">    Accept: text/*, text/html, text/html;level=1, */*
</pre><p id="rfc.section.14.1.p.14">have the following precedence:</p>
      <div id="rfc.figure.u.64"></div><pre class="text">    1) text/html;level=1
    2) text/html
    3) text/*
    4) */*
</pre><p id="rfc.section.14.1.p.16">The media type quality factor associated with a given type is determined by finding the media range with the highest precedence
         which matches that type. For example,
      </p>
      <div id="rfc.figure.u.65"></div><pre class="text">    Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
            text/html;level=2;q=0.4, */*;q=0.5
</pre><p id="rfc.section.14.1.p.18">would cause the following values to be associated:</p>
      <div id="rfc.figure.u.66"></div><pre class="text">    text/html;level=1         = 1
    text/html                 = 0.7
    text/plain                = 0.3
    image/jpeg                = 0.5
    text/html;level=2         = 0.4
    text/html;level=3         = 0.7
</pre><p id="rfc.section.14.1.p.20"> <b>Note:</b> A user agent might be provided with a default set of quality values for certain media ranges. However, unless the user agent
         is a closed system which cannot interact with other rendering agents, this default set ought to be configurable by the user.
      </p>
      <div id="rfc.iref.a.3"></div>
      <div id="rfc.iref.h.4"></div>
      <h2 id="rfc.section.14.2"><a href="#rfc.section.14.2">14.2</a>&nbsp;<a id="header.accept-charset" href="#header.accept-charset">Accept-Charset</a></h2>
      <p id="rfc.section.14.2.p.1">The Accept-Charset request-header field can be used to indicate what character sets are acceptable for the response. This
         field allows clients capable of understanding more comprehensive or special-purpose character sets to signal that capability
         to a server which is capable of representing documents in those character sets.
      </p>
      <div id="rfc.figure.u.67"></div><pre class="inline"><span id="rfc.iref.g.99"></span>   Accept-Charset = "Accept-Charset" ":"
           1#( ( charset | "*" )[ ";" "q" "=" qvalue ] )
</pre><p id="rfc.section.14.2.p.3">Character set values are described in <a href="#character.sets" title="Character Sets">Section&nbsp;3.4</a>. Each charset <em class="bcp14">MAY</em> be given an associated quality value which represents the user's preference for that charset. The default value is q=1. An
         example is
      </p>
      <div id="rfc.figure.u.68"></div><pre class="text">   Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
</pre><p id="rfc.section.14.2.p.5">The special value "*", if present in the Accept-Charset field, matches every character set (including ISO-8859-1) which is
         not mentioned elsewhere in the Accept-Charset field. If no "*" is present in an Accept-Charset field, then all character sets
         not explicitly mentioned get a quality value of 0, except for ISO-8859-1, which gets a quality value of 1 if not explicitly
         mentioned.
      </p>
      <p id="rfc.section.14.2.p.6">If no Accept-Charset header is present, the default is that any character set is acceptable. If an Accept-Charset header is
         present, and if the server cannot send a response which is acceptable according to the Accept-Charset header, then the server <em class="bcp14">SHOULD</em> send an error response with the 406 (not acceptable) status code, though the sending of an unacceptable response is also allowed.
      </p>
      <div id="rfc.iref.a.4"></div>
      <div id="rfc.iref.h.5"></div>
      <h2 id="rfc.section.14.3"><a href="#rfc.section.14.3">14.3</a>&nbsp;<a id="header.accept-encoding" href="#header.accept-encoding">Accept-Encoding</a></h2>
      <p id="rfc.section.14.3.p.1">The Accept-Encoding request-header field is similar to Accept, but restricts the content-codings (<a href="#content.codings" title="Content Codings">Section&nbsp;3.5</a>) that are acceptable in the response.
      </p>
      <div id="rfc.figure.u.69"></div><pre class="inline"><span id="rfc.iref.g.100"></span><span id="rfc.iref.g.101"></span>    Accept-Encoding  = "Accept-Encoding" ":"
                       1#( codings [ ";" "q" "=" qvalue ] )
    codings          = ( content-coding | "*" )
</pre><p id="rfc.section.14.3.p.3">Examples of its use are:</p>
      <div id="rfc.figure.u.70"></div><pre class="text">    Accept-Encoding: compress, gzip
    Accept-Encoding:
    Accept-Encoding: *
    Accept-Encoding: compress;q=0.5, gzip;q=1.0
    Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
</pre><p id="rfc.section.14.3.p.5">A server tests whether a content-coding is acceptable, according to an Accept-Encoding field, using these rules: </p>
      <ol>
         <li>If the content-coding is one of the content-codings listed in the Accept-Encoding field, then it is acceptable, unless it
            is accompanied by a qvalue of 0. (As defined in <a href="#quality.values" title="Quality Values">Section&nbsp;3.9</a>, a qvalue of 0 means "not acceptable.")
         </li>
         <li>The special "*" symbol in an Accept-Encoding field matches any available content-coding not explicitly listed in the header
            field.
         </li>
         <li>If multiple content-codings are acceptable, then the acceptable content-coding with the highest non-zero qvalue is preferred.</li>
         <li>The "identity" content-coding is always acceptable, unless specifically refused because the Accept-Encoding field includes
            "identity;q=0", or because the field includes "*;q=0" and does not explicitly include the "identity" content-coding. If the
            Accept-Encoding field-value is empty, then only the "identity" encoding is acceptable.
         </li>
      </ol>
      <p id="rfc.section.14.3.p.6">If an Accept-Encoding field is present in a request, and if the server cannot send a response which is acceptable according
         to the Accept-Encoding header, then the server <em class="bcp14">SHOULD</em> send an error response with the 406 (Not Acceptable) status code.
      </p>
      <p id="rfc.section.14.3.p.7">If no Accept-Encoding field is present in a request, the server <em class="bcp14">MAY</em> assume that the client will accept any content coding. In this case, if "identity" is one of the available content-codings,
         then the server <em class="bcp14">SHOULD</em> use the "identity" content-coding, unless it has additional information that a different content-coding is meaningful to the
         client. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> If the request does not include an Accept-Encoding field, and if the "identity" content-coding is unavailable, then content-codings
            commonly understood by HTTP/1.0 clients (i.e., "gzip" and "compress") are preferred; some older clients improperly display
            messages sent with other content-codings. The server might also make this decision based on information about the particular
            user-agent or client.
         </dd>
         <dd> <b>Note:</b> Most HTTP/1.0 applications do not recognize or obey qvalues associated with content-codings. This means that qvalues will
            not work and are not permitted with x-gzip or x-compress.
         </dd>
      </dl>
      <div id="rfc.iref.a.5"></div>
      <div id="rfc.iref.h.6"></div>
      <h2 id="rfc.section.14.4"><a href="#rfc.section.14.4">14.4</a>&nbsp;<a id="header.accept-language" href="#header.accept-language">Accept-Language</a></h2>
      <p id="rfc.section.14.4.p.1">The Accept-Language request-header field is similar to Accept, but restricts the set of natural languages that are preferred
         as a response to the request. Language tags are defined in <a href="#language.tags" title="Language Tags">Section&nbsp;3.10</a>.
      </p>
      <div id="rfc.figure.u.71"></div><pre class="inline"><span id="rfc.iref.g.102"></span><span id="rfc.iref.g.103"></span>    Accept-Language = "Accept-Language" ":"
                      1#( language-range [ ";" "q" "=" qvalue ] )
    language-range  = ( ( 1*8ALPHA *( "-" 1*8ALPHA ) ) | "*" )
</pre><p id="rfc.section.14.4.p.3">Each language-range <em class="bcp14">MAY</em> be given an associated quality value which represents an estimate of the user's preference for the languages specified by
         that range. The quality value defaults to "q=1". For example,
      </p>
      <div id="rfc.figure.u.72"></div><pre class="text">    Accept-Language: da, en-gb;q=0.8, en;q=0.7
</pre><p id="rfc.section.14.4.p.5">would mean: "I prefer Danish, but will accept British English and other types of English." A language-range matches a language-tag
         if it exactly equals the tag, or if it exactly equals a prefix of the tag such that the first tag character following the
         prefix is "-". The special range "*", if present in the Accept-Language field, matches every tag not matched by any other
         range present in the Accept-Language field. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> This use of a prefix matching rule does not imply that language tags are assigned to languages in such a way that it is always
            true that if a user understands a language with a certain tag, then this user will also understand all languages with tags
            for which this tag is a prefix. The prefix rule simply allows the use of prefix tags if this is the case.
         </dd>
      </dl>
      <p id="rfc.section.14.4.p.6">The language quality factor assigned to a language-tag by the Accept-Language field is the quality value of the longest language-range
         in the field that matches the language-tag. If no language-range in the field matches the tag, the language quality factor
         assigned is 0. If no Accept-Language header is present in the request, the server <em class="bcp14">SHOULD</em> assume that all languages are equally acceptable. If an Accept-Language header is present, then all languages which are assigned
         a quality factor greater than 0 are acceptable.
      </p>
      <p id="rfc.section.14.4.p.7">It might be contrary to the privacy expectations of the user to send an Accept-Language header with the complete linguistic
         preferences of the user in every request. For a discussion of this issue, see <a href="#privacy.issues.connected.to.accept.headers" title="Privacy Issues Connected to Accept Headers">Section&nbsp;15.1.4</a>.
      </p>
      <p id="rfc.section.14.4.p.8">As intelligibility is highly dependent on the individual user, it is recommended that client applications make the choice
         of linguistic preference available to the user. If the choice is not made available, then the Accept-Language header field <em class="bcp14">MUST NOT</em> be given in the request. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> When making the choice of linguistic preference available to the user, we remind implementors of the fact that users are not
            familiar with the details of language matching as described above, and should provide appropriate guidance. As an example,
            users might assume that on selecting "en-gb", they will be served any kind of English document if British English is not available.
            A user agent might suggest in such a case to add "en" to get the best matching behavior.
         </dd>
      </dl>
      <div id="rfc.iref.a.6"></div>
      <div id="rfc.iref.h.7"></div>
      <h2 id="rfc.section.14.5"><a href="#rfc.section.14.5">14.5</a>&nbsp;<a id="header.accept-ranges" href="#header.accept-ranges">Accept-Ranges</a></h2>
      <p id="rfc.section.14.5.p.1">The Accept-Ranges response-header field allows the server to indicate its acceptance of range requests for a resource:</p>
      <div id="rfc.figure.u.73"></div><pre class="inline"><span id="rfc.iref.g.104"></span><span id="rfc.iref.g.105"></span>       Accept-Ranges     = "Accept-Ranges" ":" acceptable-ranges
       acceptable-ranges = 1#range-unit | "none"
</pre><p id="rfc.section.14.5.p.3">Origin servers that accept byte-range requests <em class="bcp14">MAY</em> send
      </p>
      <div id="rfc.figure.u.74"></div><pre class="text">       Accept-Ranges: bytes
</pre><p id="rfc.section.14.5.p.5">but are not required to do so. Clients <em class="bcp14">MAY</em> generate byte-range requests without having received this header for the resource involved. Range units are defined in <a href="#range.units" title="Range Units">Section&nbsp;3.12</a>.
      </p>
      <p id="rfc.section.14.5.p.6">Servers that do not accept any kind of range request for a resource <em class="bcp14">MAY</em> send
      </p>
      <div id="rfc.figure.u.75"></div><pre class="text">       Accept-Ranges: none
</pre><p id="rfc.section.14.5.p.8">to advise the client not to attempt a range request.</p>
      <div id="rfc.iref.a.7"></div>
      <div id="rfc.iref.h.8"></div>
      <h2 id="rfc.section.14.6"><a href="#rfc.section.14.6">14.6</a>&nbsp;<a id="header.age" href="#header.age">Age</a></h2>
      <p id="rfc.section.14.6.p.1">The Age response-header field conveys the sender's estimate of the amount of time since the response (or its revalidation)
         was generated at the origin server. A cached response is "fresh" if its age does not exceed its freshness lifetime. Age values
         are calculated as specified in <a href="#age.calculations" title="Age Calculations">Section&nbsp;13.2.3</a>.
      </p>
      <div id="rfc.figure.u.76"></div><pre class="inline"><span id="rfc.iref.g.106"></span><span id="rfc.iref.g.107"></span>        Age = "Age" ":" age-value
        age-value = delta-seconds
</pre><p id="rfc.section.14.6.p.3">Age values are non-negative decimal integers, representing time in seconds.</p>
      <p id="rfc.section.14.6.p.4">If a cache receives a value larger than the largest positive integer it can represent, or if any of its age calculations overflows,
         it <em class="bcp14">MUST</em> transmit an Age header with a value of 2147483648 (2^31). An HTTP/1.1 server that includes a cache <em class="bcp14">MUST</em> include an Age header field in every response generated from its own cache. Caches <em class="bcp14">SHOULD</em> use an arithmetic type of at least 31 bits of range.
      </p>
      <div id="rfc.iref.a.8"></div>
      <div id="rfc.iref.h.9"></div>
      <h2 id="rfc.section.14.7"><a href="#rfc.section.14.7">14.7</a>&nbsp;<a id="header.allow" href="#header.allow">Allow</a></h2>
      <p id="rfc.section.14.7.p.1">The Allow entity-header field lists the set of methods supported by the resource identified by the Request-URI. The purpose
         of this field is strictly to inform the recipient of valid methods associated with the resource. An Allow header field <em class="bcp14">MUST</em> be present in a 405 (Method Not Allowed) response.
      </p>
      <div id="rfc.figure.u.77"></div><pre class="inline"><span id="rfc.iref.g.108"></span>       Allow   = "Allow" ":" #Method
</pre><p id="rfc.section.14.7.p.3">Example of use:</p>
      <div id="rfc.figure.u.78"></div><pre class="text">       Allow: GET, HEAD, PUT
</pre><p id="rfc.section.14.7.p.5">This field cannot prevent a client from trying other methods. However, the indications given by the Allow header field value <em class="bcp14">SHOULD</em> be followed. The actual set of allowed methods is defined by the origin server at the time of each request.
      </p>
      <p id="rfc.section.14.7.p.6">The Allow header field <em class="bcp14">MAY</em> be provided with a PUT request to recommend the methods to be supported by the new or modified resource. The server is not
         required to support these methods and <em class="bcp14">SHOULD</em> include an Allow header in the response giving the actual supported methods.
      </p>
      <p id="rfc.section.14.7.p.7">A proxy <em class="bcp14">MUST NOT</em> modify the Allow header field even if it does not understand all the methods specified, since the user agent might have other
         means of communicating with the origin server.
      </p>
      <div id="rfc.iref.a.9"></div>
      <div id="rfc.iref.h.10"></div>
      <h2 id="rfc.section.14.8"><a href="#rfc.section.14.8">14.8</a>&nbsp;<a id="header.authorization" href="#header.authorization">Authorization</a></h2>
      <p id="rfc.section.14.8.p.1">A user agent that wishes to authenticate itself with a server-- usually, but not necessarily, after receiving a 401 response--does
         so by including an Authorization request-header field with the request. The Authorization field value consists of credentials
         containing the authentication information of the user agent for the realm of the resource being requested.
      </p>
      <div id="rfc.figure.u.79"></div><pre class="inline"><span id="rfc.iref.g.109"></span>       Authorization  = "Authorization" ":" credentials
</pre><p id="rfc.section.14.8.p.3">HTTP access authentication is described in "HTTP Authentication: Basic and Digest Access Authentication" <a href="#RFC2617" id="rfc.xref.RFC2617.4"><cite title="HTTP Authentication: Basic and Digest Access Authentication">[RFC2617]</cite></a>. If a request is authenticated and a realm specified, the same credentials <em class="bcp14">SHOULD</em> be valid for all other requests within this realm (assuming that the authentication scheme itself does not require otherwise,
         such as credentials that vary according to a challenge value or using synchronized clocks).
      </p>
      <p id="rfc.section.14.8.p.4">When a shared cache (see <a href="#shared.and.non-shared.caches" title="Shared and Non-Shared Caches">Section&nbsp;13.7</a>) receives a request containing an Authorization field, it <em class="bcp14">MUST NOT</em> return the corresponding response as a reply to any other request, unless one of the following specific exceptions holds:
      </p>
      <p id="rfc.section.14.8.p.5"> </p>
      <ol>
         <li>If the response includes the "s-maxage" cache-control directive, the cache <em class="bcp14">MAY</em> use that response in replying to a subsequent request. But (if the specified maximum age has passed) a proxy cache <em class="bcp14">MUST</em> first revalidate it with the origin server, using the request-headers from the new request to allow the origin server to authenticate
            the new request. (This is the defined behavior for s-maxage.) If the response includes "s-maxage=0", the proxy <em class="bcp14">MUST</em> always revalidate it before re-using it.
         </li>
         <li>If the response includes the "must-revalidate" cache-control directive, the cache <em class="bcp14">MAY</em> use that response in replying to a subsequent request. But if the response is stale, all caches <em class="bcp14">MUST</em> first revalidate it with the origin server, using the request-headers from the new request to allow the origin server to authenticate
            the new request.
         </li>
         <li>If the response includes the "public" cache-control directive, it <em class="bcp14">MAY</em> be returned in reply to any subsequent request.
         </li>
      </ol>
      <div id="rfc.iref.c.8"></div>
      <div id="rfc.iref.h.11"></div>
      <h2 id="rfc.section.14.9"><a href="#rfc.section.14.9">14.9</a>&nbsp;<a id="header.cache-control" href="#header.cache-control">Cache-Control</a></h2>
      <p id="rfc.section.14.9.p.1">The Cache-Control general-header field is used to specify directives that <em class="bcp14">MUST</em> be obeyed by all caching mechanisms along the request/response chain. The directives specify behavior intended to prevent
         caches from adversely interfering with the request or response. These directives typically override the default caching algorithms.
         Cache directives are unidirectional in that the presence of a directive in a request does not imply that the same directive
         is to be given in the response. 
      </p>
      <dl class="empty">
         <dd>Note that HTTP/1.0 caches might not implement Cache-Control and might only implement Pragma: no-cache (see <a href="#header.pragma" id="rfc.xref.header.pragma.2" title="Pragma">Section&nbsp;14.32</a>).
         </dd>
      </dl>
      <p id="rfc.section.14.9.p.2">Cache directives <em class="bcp14">MUST</em> be passed through by a proxy or gateway application, regardless of their significance to that application, since the directives
         might be applicable to all recipients along the request/response chain. It is not possible to specify a cache-directive for
         a specific cache.
      </p>
      <div id="rfc.figure.u.80"></div><pre class="inline"><span id="rfc.iref.g.110"></span><span id="rfc.iref.g.111"></span><span id="rfc.iref.g.112"></span><span id="rfc.iref.g.113"></span><span id="rfc.iref.g.114"></span>   Cache-Control   = "Cache-Control" ":" 1#cache-directive

   cache-directive = cache-request-directive
        | cache-response-directive

   cache-request-directive =
          "no-cache"                          ; <a href="#what.is.cacheable" title="What is Cacheable">Section&nbsp;14.9.1</a>
        | "no-store"                          ; <a href="#what.may.be.stored.by.caches" title="What May be Stored by Caches">Section&nbsp;14.9.2</a>
        | "max-age" "=" delta-seconds         ; <a href="#modifications.of.the.basic.expiration.mechanism" title="Modifications of the Basic Expiration Mechanism">Section&nbsp;14.9.3</a>, <a href="#cache.revalidation.and.reload.controls" title="Cache Revalidation and Reload Controls">14.9.4</a>
        | "max-stale" [ "=" delta-seconds ]   ; <a href="#modifications.of.the.basic.expiration.mechanism" title="Modifications of the Basic Expiration Mechanism">Section&nbsp;14.9.3</a>
        | "min-fresh" "=" delta-seconds       ; <a href="#modifications.of.the.basic.expiration.mechanism" title="Modifications of the Basic Expiration Mechanism">Section&nbsp;14.9.3</a>
        | "no-transform"                      ; <a href="#no-transform.directive" title="No-Transform Directive">Section&nbsp;14.9.5</a>
        | "only-if-cached"                    ; <a href="#cache.revalidation.and.reload.controls" title="Cache Revalidation and Reload Controls">Section&nbsp;14.9.4</a>
        | cache-extension                     ; <a href="#cache.control.extensions" title="Cache Control Extensions">Section&nbsp;14.9.6</a>

    cache-response-directive =
          "public"                               ; <a href="#what.is.cacheable" title="What is Cacheable">Section&nbsp;14.9.1</a>
        | "private" [ "=" &lt;"&gt; 1#field-name &lt;"&gt; ] ; <a href="#what.is.cacheable" title="What is Cacheable">Section&nbsp;14.9.1</a>
        | "no-cache" [ "=" &lt;"&gt; 1#field-name &lt;"&gt; ]; <a href="#what.is.cacheable" title="What is Cacheable">Section&nbsp;14.9.1</a>
        | "no-store"                             ; <a href="#what.may.be.stored.by.caches" title="What May be Stored by Caches">Section&nbsp;14.9.2</a>
        | "no-transform"                         ; <a href="#no-transform.directive" title="No-Transform Directive">Section&nbsp;14.9.5</a>
        | "must-revalidate"                      ; <a href="#cache.revalidation.and.reload.controls" title="Cache Revalidation and Reload Controls">Section&nbsp;14.9.4</a>
        | "proxy-revalidate"                     ; <a href="#cache.revalidation.and.reload.controls" title="Cache Revalidation and Reload Controls">Section&nbsp;14.9.4</a>
        | "max-age" "=" delta-seconds            ; <a href="#modifications.of.the.basic.expiration.mechanism" title="Modifications of the Basic Expiration Mechanism">Section&nbsp;14.9.3</a>
        | "s-maxage" "=" delta-seconds           ; <a href="#modifications.of.the.basic.expiration.mechanism" title="Modifications of the Basic Expiration Mechanism">Section&nbsp;14.9.3</a>
        | cache-extension                        ; <a href="#cache.control.extensions" title="Cache Control Extensions">Section&nbsp;14.9.6</a>

   cache-extension = token [ "=" ( token | quoted-string ) ]
</pre><p id="rfc.section.14.9.p.4">When a directive appears without any 1#field-name parameter, the directive applies to the entire request or response. When
         such a directive appears with a 1#field-name parameter, it applies only to the named field or fields, and not to the rest
         of the request or response. This mechanism supports extensibility; implementations of future versions of the HTTP protocol
         might apply these directives to header fields not defined in HTTP/1.1.
      </p>
      <p id="rfc.section.14.9.p.5">The cache-control directives can be broken down into these general categories: </p>
      <ul>
         <li>Restrictions on what are cacheable; these may only be imposed by the origin server.</li>
         <li>Restrictions on what may be stored by a cache; these may be imposed by either the origin server or the user agent.</li>
         <li>Modifications of the basic expiration mechanism; these may be imposed by either the origin server or the user agent.</li>
         <li>Controls over cache revalidation and reload; these may only be imposed by a user agent.</li>
         <li>Control over transformation of entities.</li>
         <li>Extensions to the caching system.</li>
      </ul>
      <h3 id="rfc.section.14.9.1"><a href="#rfc.section.14.9.1">14.9.1</a>&nbsp;<a id="what.is.cacheable" href="#what.is.cacheable">What is Cacheable</a></h3>
      <p id="rfc.section.14.9.1.p.1">By default, a response is cacheable if the requirements of the request method, request header fields, and the response status
         indicate that it is cacheable. <a href="#response.cacheability" title="Response Cacheability">Section&nbsp;13.4</a> summarizes these defaults for cacheability. The following Cache-Control response directives allow an origin server to override
         the default cacheability of a response:
      </p>
      <p id="rfc.section.14.9.1.p.2"> <span id="rfc.iref.c.9"></span>  <span id="rfc.iref.p.4"></span> public 
      </p>
      <dl class="empty">
         <dd>Indicates that the response <em class="bcp14">MAY</em> be cached by any cache, even if it would normally be non-cacheable or cacheable only within a non-shared cache. (See also
            Authorization, <a href="#header.authorization" id="rfc.xref.header.authorization.4" title="Authorization">Section&nbsp;14.8</a>, for additional details.)
         </dd>
      </dl>
      <p id="rfc.section.14.9.1.p.3"> <span id="rfc.iref.c.10"></span>  <span id="rfc.iref.p.5"></span> private 
      </p>
      <dl class="empty">
         <dd>Indicates that all or part of the response message is intended for a single user and <em class="bcp14">MUST NOT</em> be cached by a shared cache. This allows an origin server to state that the specified parts of the response are intended for
            only one user and are not a valid response for requests by other users. A private (non-shared) cache <em class="bcp14">MAY</em> cache the response.
         </dd>
         <dd> <b>Note:</b> This usage of the word private only controls where the response may be cached, and cannot ensure the privacy of the message
            content.
         </dd>
      </dl>
      <p id="rfc.section.14.9.1.p.4"> <span id="rfc.iref.c.11"></span>  <span id="rfc.iref.n.1"></span> no-cache 
      </p>
      <dl class="empty">
         <dd>If the no-cache directive does not specify a field-name, then a cache <em class="bcp14">MUST NOT</em> use the response to satisfy a subsequent request without successful revalidation with the origin server. This allows an origin
            server to prevent caching even by caches that have been configured to return stale responses to client requests.
         </dd>
         <dd>If the no-cache directive does specify one or more field-names, then a cache <em class="bcp14">MAY</em> use the response to satisfy a subsequent request, subject to any other restrictions on caching. However, the specified field-name(s) <em class="bcp14">MUST NOT</em> be sent in the response to a subsequent request without successful revalidation with the origin server. This allows an origin
            server to prevent the re-use of certain header fields in a response, while still allowing caching of the rest of the response. 
            <dl class="empty">
               <dd> <b>Note:</b> Most HTTP/1.0 caches will not recognize or obey this directive.
               </dd>
            </dl> 
         </dd>
      </dl>
      <h3 id="rfc.section.14.9.2"><a href="#rfc.section.14.9.2">14.9.2</a>&nbsp;<a id="what.may.be.stored.by.caches" href="#what.may.be.stored.by.caches">What May be Stored by Caches</a></h3>
      <p id="rfc.section.14.9.2.p.1"> <span id="rfc.iref.c.12"></span>  <span id="rfc.iref.n.2"></span> no-store 
      </p>
      <dl class="empty">
         <dd>The purpose of the no-store directive is to prevent the inadvertent release or retention of sensitive information (for example,
            on backup tapes). The no-store directive applies to the entire message, and <em class="bcp14">MAY</em> be sent either in a response or in a request. If sent in a request, a cache <em class="bcp14">MUST NOT</em> store any part of either this request or any response to it. If sent in a response, a cache <em class="bcp14">MUST NOT</em> store any part of either this response or the request that elicited it. This directive applies to both non-shared and shared
            caches. "<em class="bcp14">MUST NOT</em> store" in this context means that the cache <em class="bcp14">MUST NOT</em> intentionally store the information in non-volatile storage, and <em class="bcp14">MUST</em> make a best-effort attempt to remove the information from volatile storage as promptly as possible after forwarding it.
         </dd>
         <dd>Even when this directive is associated with a response, users might explicitly store such a response outside of the caching
            system (e.g., with a "Save As" dialog). History buffers <em class="bcp14">MAY</em> store such responses as part of their normal operation.
         </dd>
         <dd>The purpose of this directive is to meet the stated requirements of certain users and service authors who are concerned about
            accidental releases of information via unanticipated accesses to cache data structures. While the use of this directive might
            improve privacy in some cases, we caution that it is NOT in any way a reliable or sufficient mechanism for ensuring privacy.
            In particular, malicious or compromised caches might not recognize or obey this directive, and communications networks might
            be vulnerable to eavesdropping.
         </dd>
      </dl>
      <h3 id="rfc.section.14.9.3"><a href="#rfc.section.14.9.3">14.9.3</a>&nbsp;<a id="modifications.of.the.basic.expiration.mechanism" href="#modifications.of.the.basic.expiration.mechanism">Modifications of the Basic Expiration Mechanism</a></h3>
      <p id="rfc.section.14.9.3.p.1">The expiration time of an entity <em class="bcp14">MAY</em> be specified by the origin server using the Expires header (see <a href="#header.expires" id="rfc.xref.header.expires.3" title="Expires">Section&nbsp;14.21</a>). Alternatively, it <em class="bcp14">MAY</em> be specified using the max-age directive in a response. When the max-age cache-control directive is present in a cached response,
         the response is stale if its current age is greater than the age value given (in seconds) at the time of a new request for
         that resource. The max-age directive on a response implies that the response is cacheable (i.e., "public") unless some other,
         more restrictive cache directive is also present.
      </p>
      <p id="rfc.section.14.9.3.p.2">If a response includes both an Expires header and a max-age directive, the max-age directive overrides the Expires header,
         even if the Expires header is more restrictive. This rule allows an origin server to provide, for a given response, a longer
         expiration time to an HTTP/1.1 (or later) cache than to an HTTP/1.0 cache. This might be useful if certain HTTP/1.0 caches
         improperly calculate ages or expiration times, perhaps due to desynchronized clocks.
      </p>
      <p id="rfc.section.14.9.3.p.3">Many HTTP/1.0 cache implementations will treat an Expires value that is less than or equal to the response Date value as being
         equivalent to the Cache-Control response directive "no-cache". If an HTTP/1.1 cache receives such a response, and the response
         does not include a Cache-Control header field, it <em class="bcp14">SHOULD</em> consider the response to be non-cacheable in order to retain compatibility with HTTP/1.0 servers. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> An origin server might wish to use a relatively new HTTP cache control feature, such as the "private" directive, on a network
            including older caches that do not understand that feature. The origin server will need to combine the new feature with an
            Expires field whose value is less than or equal to the Date value. This will prevent older caches from improperly caching
            the response.
         </dd>
      </dl>
      <p id="rfc.section.14.9.3.p.4"> <span id="rfc.iref.c.13"></span>  <span id="rfc.iref.s.45"></span> s-maxage 
      </p>
      <dl class="empty">
         <dd>If a response includes an s-maxage directive, then for a shared cache (but not for a private cache), the maximum age specified
            by this directive overrides the maximum age specified by either the max-age directive or the Expires header. The s-maxage
            directive also implies the semantics of the proxy-revalidate directive (see <a href="#cache.revalidation.and.reload.controls" title="Cache Revalidation and Reload Controls">Section&nbsp;14.9.4</a>), i.e., that the shared cache must not use the entry after it becomes stale to respond to a subsequent request without first
            revalidating it with the origin server. The s-maxage directive is always ignored by a private cache.
         </dd>
      </dl>
      <p id="rfc.section.14.9.3.p.5">Note that most older caches, not compliant with this specification, do not implement any cache-control directives. An origin
         server wishing to use a cache-control directive that restricts, but does not prevent, caching by an HTTP/1.1-compliant cache <em class="bcp14">MAY</em> exploit the requirement that the max-age directive overrides the Expires header, and the fact that pre-HTTP/1.1-compliant
         caches do not observe the max-age directive.
      </p>
      <p id="rfc.section.14.9.3.p.6">Other directives allow a user agent to modify the basic expiration mechanism. These directives <em class="bcp14">MAY</em> be specified on a request:
      </p>
      <p id="rfc.section.14.9.3.p.7"> <span id="rfc.iref.c.14"></span>  <span id="rfc.iref.m.10"></span> max-age 
      </p>
      <dl class="empty">
         <dd>Indicates that the client is willing to accept a response whose age is no greater than the specified time in seconds. Unless
            max-stale directive is also included, the client is not willing to accept a stale response.
         </dd>
      </dl>
      <p id="rfc.section.14.9.3.p.8"> <span id="rfc.iref.c.15"></span>  <span id="rfc.iref.m.11"></span> min-fresh 
      </p>
      <dl class="empty">
         <dd>Indicates that the client is willing to accept a response whose freshness lifetime is no less than its current age plus the
            specified time in seconds. That is, the client wants a response that will still be fresh for at least the specified number
            of seconds.
         </dd>
      </dl>
      <p id="rfc.section.14.9.3.p.9"> <span id="rfc.iref.c.16"></span>  <span id="rfc.iref.m.12"></span> max-stale 
      </p>
      <dl class="empty">
         <dd>Indicates that the client is willing to accept a response that has exceeded its expiration time. If max-stale is assigned
            a value, then the client is willing to accept a response that has exceeded its expiration time by no more than the specified
            number of seconds. If no value is assigned to max-stale, then the client is willing to accept a stale response of any age.
         </dd>
      </dl>
      <p id="rfc.section.14.9.3.p.10">If a cache returns a stale response, either because of a max-stale directive on a request, or because the cache is configured
         to override the expiration time of a response, the cache <em class="bcp14">MUST</em> attach a Warning header to the stale response, using Warning 110 (Response is stale).
      </p>
      <p id="rfc.section.14.9.3.p.11">A cache <em class="bcp14">MAY</em> be configured to return stale responses without validation, but only if this does not conflict with any "MUST"-level requirements
         concerning cache validation (e.g., a "must-revalidate" cache-control directive).
      </p>
      <p id="rfc.section.14.9.3.p.12">If both the new request and the cached entry include "max-age" directives, then the lesser of the two values is used for determining
         the freshness of the cached entry for that request.
      </p>
      <h3 id="rfc.section.14.9.4"><a href="#rfc.section.14.9.4">14.9.4</a>&nbsp;<a id="cache.revalidation.and.reload.controls" href="#cache.revalidation.and.reload.controls">Cache Revalidation and Reload Controls</a></h3>
      <p id="rfc.section.14.9.4.p.1">Sometimes a user agent might want or need to insist that a cache revalidate its cache entry with the origin server (and not
         just with the next cache along the path to the origin server), or to reload its cache entry from the origin server. End-to-end
         revalidation might be necessary if either the cache or the origin server has overestimated the expiration time of the cached
         response. End-to-end reload may be necessary if the cache entry has become corrupted for some reason.
      </p>
      <p id="rfc.section.14.9.4.p.2">End-to-end revalidation may be requested either when the client does not have its own local cached copy, in which case we
         call it "unspecified end-to-end revalidation", or when the client does have a local cached copy, in which case we call it
         "specific end-to-end revalidation."
      </p>
      <p id="rfc.section.14.9.4.p.3">The client can specify these three kinds of action using Cache-Control request directives:</p>
      <p id="rfc.section.14.9.4.p.4">End-to-end reload </p>
      <dl class="empty">
         <dd>The request includes a "no-cache" cache-control directive or, for compatibility with HTTP/1.0 clients, "Pragma: no-cache".
            Field names <em class="bcp14">MUST NOT</em> be included with the no-cache directive in a request. The server <em class="bcp14">MUST NOT</em> use a cached copy when responding to such a request.
         </dd>
      </dl>
      <p id="rfc.section.14.9.4.p.5">Specific end-to-end revalidation </p>
      <dl class="empty">
         <dd>The request includes a "max-age=0" cache-control directive, which forces each cache along the path to the origin server to
            revalidate its own entry, if any, with the next cache or server. The initial request includes a cache-validating conditional
            with the client's current validator.
         </dd>
      </dl>
      <p id="rfc.section.14.9.4.p.6">Unspecified end-to-end revalidation </p>
      <dl class="empty">
         <dd>The request includes "max-age=0" cache-control directive, which forces each cache along the path to the origin server to revalidate
            its own entry, if any, with the next cache or server. The initial request does not include a cache-validating conditional;
            the first cache along the path (if any) that holds a cache entry for this resource includes a cache-validating conditional
            with its current validator.
         </dd>
      </dl>
      <p id="rfc.section.14.9.4.p.7"> <span id="rfc.iref.c.17"></span>  <span id="rfc.iref.m.13"></span> max-age 
      </p>
      <dl class="empty">
         <dd>When an intermediate cache is forced, by means of a max-age=0 directive, to revalidate its own cache entry, and the client
            has supplied its own validator in the request, the supplied validator might differ from the validator currently stored with
            the cache entry. In this case, the cache <em class="bcp14">MAY</em> use either validator in making its own request without affecting semantic transparency.
         </dd>
         <dd>However, the choice of validator might affect performance. The best approach is for the intermediate cache to use its own
            validator when making its request. If the server replies with 304 (Not Modified), then the cache can return its now validated
            copy to the client with a 200 (OK) response. If the server replies with a new entity and cache validator, however, the intermediate
            cache can compare the returned validator with the one provided in the client's request, using the strong comparison function.
            If the client's validator is equal to the origin server's, then the intermediate cache simply returns 304 (Not Modified).
            Otherwise, it returns the new entity with a 200 (OK) response.
         </dd>
         <dd>If a request includes the no-cache directive, it <em class="bcp14">SHOULD NOT</em> include min-fresh, max-stale, or max-age.
         </dd>
      </dl>
      <p id="rfc.section.14.9.4.p.8"> <span id="rfc.iref.c.18"></span>  <span id="rfc.iref.o.4"></span> only-if-cached 
      </p>
      <dl class="empty">
         <dd>In some cases, such as times of extremely poor network connectivity, a client may want a cache to return only those responses
            that it currently has stored, and not to reload or revalidate with the origin server. To do this, the client may include the
            only-if-cached directive in a request. If it receives this directive, a cache <em class="bcp14">SHOULD</em> either respond using a cached entry that is consistent with the other constraints of the request, or respond with a 504 (Gateway
            Timeout) status. However, if a group of caches is being operated as a unified system with good internal connectivity, such
            a request <em class="bcp14">MAY</em> be forwarded within that group of caches.
         </dd>
      </dl>
      <p id="rfc.section.14.9.4.p.9"> <span id="rfc.iref.c.19"></span>  <span id="rfc.iref.m.14"></span> must-revalidate 
      </p>
      <dl class="empty">
         <dd>Because a cache <em class="bcp14">MAY</em> be configured to ignore a server's specified expiration time, and because a client request <em class="bcp14">MAY</em> include a max-stale directive (which has a similar effect), the protocol also includes a mechanism for the origin server to
            require revalidation of a cache entry on any subsequent use. When the must-revalidate directive is present in a response received
            by a cache, that cache <em class="bcp14">MUST NOT</em> use the entry after it becomes stale to respond to a subsequent request without first revalidating it with the origin server.
            (I.e., the cache <em class="bcp14">MUST</em> do an end-to-end revalidation every time, if, based solely on the origin server's Expires or max-age value, the cached response
            is stale.)
         </dd>
         <dd>The must-revalidate directive is necessary to support reliable operation for certain protocol features. In all circumstances
            an HTTP/1.1 cache <em class="bcp14">MUST</em> obey the must-revalidate directive; in particular, if the cache cannot reach the origin server for any reason, it <em class="bcp14">MUST</em> generate a 504 (Gateway Timeout) response.
         </dd>
         <dd>Servers <em class="bcp14">SHOULD</em> send the must-revalidate directive if and only if failure to revalidate a request on the entity could result in incorrect
            operation, such as a silently unexecuted financial transaction. Recipients <em class="bcp14">MUST NOT</em> take any automated action that violates this directive, and <em class="bcp14">MUST NOT</em> automatically provide an unvalidated copy of the entity if revalidation fails.
         </dd>
         <dd>Although this is not recommended, user agents operating under severe connectivity constraints <em class="bcp14">MAY</em> violate this directive but, if so, <em class="bcp14">MUST</em> explicitly warn the user that an unvalidated response has been provided. The warning <em class="bcp14">MUST</em> be provided on each unvalidated access, and <em class="bcp14">SHOULD</em> require explicit user confirmation.
         </dd>
      </dl>
      <p id="rfc.section.14.9.4.p.10"> <span id="rfc.iref.c.20"></span>  <span id="rfc.iref.p.6"></span> proxy-revalidate 
      </p>
      <dl class="empty">
         <dd>The proxy-revalidate directive has the same meaning as the must-revalidate directive, except that it does not apply to non-shared
            user agent caches. It can be used on a response to an authenticated request to permit the user's cache to store and later
            return the response without needing to revalidate it (since it has already been authenticated once by that user), while still
            requiring proxies that service many users to revalidate each time (in order to make sure that each user has been authenticated).
            Note that such authenticated responses also need the public cache control directive in order to allow them to be cached at
            all.
         </dd>
      </dl>
      <h3 id="rfc.section.14.9.5"><a href="#rfc.section.14.9.5">14.9.5</a>&nbsp;<a id="no-transform.directive" href="#no-transform.directive">No-Transform Directive</a></h3>
      <p id="rfc.section.14.9.5.p.1"> <span id="rfc.iref.c.21"></span>  <span id="rfc.iref.n.3"></span> no-transform 
      </p>
      <dl class="empty">
         <dd>Implementors of intermediate caches (proxies) have found it useful to convert the media type of certain entity bodies. A non-transparent
            proxy might, for example, convert between image formats in order to save cache space or to reduce the amount of traffic on
            a slow link.
         </dd>
         <dd>Serious operational problems occur, however, when these transformations are applied to entity bodies intended for certain
            kinds of applications. For example, applications for medical imaging, scientific data analysis and those using end-to-end
            authentication, all depend on receiving an entity body that is bit for bit identical to the original entity-body.
         </dd>
         <dd>Therefore, if a message includes the no-transform directive, an intermediate cache or proxy <em class="bcp14">MUST NOT</em> change those headers that are listed in <a href="#non-modifiable.headers" title="Non-modifiable Headers">Section&nbsp;13.5.2</a> as being subject to the no-transform directive. This implies that the cache or proxy <em class="bcp14">MUST NOT</em> change any aspect of the entity-body that is specified by these headers, including the value of the entity-body itself.
         </dd>
      </dl>
      <h3 id="rfc.section.14.9.6"><a href="#rfc.section.14.9.6">14.9.6</a>&nbsp;<a id="cache.control.extensions" href="#cache.control.extensions">Cache Control Extensions</a></h3>
      <p id="rfc.section.14.9.6.p.1">The Cache-Control header field can be extended through the use of one or more cache-extension tokens, each with an optional
         assigned value. Informational extensions (those which do not require a change in cache behavior) <em class="bcp14">MAY</em> be added without changing the semantics of other directives. Behavioral extensions are designed to work by acting as modifiers
         to the existing base of cache directives. Both the new directive and the standard directive are supplied, such that applications
         which do not understand the new directive will default to the behavior specified by the standard directive, and those that
         understand the new directive will recognize it as modifying the requirements associated with the standard directive. In this
         way, extensions to the cache-control directives can be made without requiring changes to the base protocol.
      </p>
      <p id="rfc.section.14.9.6.p.2">This extension mechanism depends on an HTTP cache obeying all of the cache-control directives defined for its native HTTP-version,
         obeying certain extensions, and ignoring all directives that it does not understand.
      </p>
      <p id="rfc.section.14.9.6.p.3">For example, consider a hypothetical new response directive called community which acts as a modifier to the private directive.
         We define this new directive to mean that, in addition to any non-shared cache, any cache which is shared only by members
         of the community named within its value may cache the response. An origin server wishing to allow the UCI community to use
         an otherwise private response in their shared cache(s) could do so by including
      </p>
      <div id="rfc.figure.u.81"></div><pre class="text">    Cache-Control: private, community="UCI"
</pre><p id="rfc.section.14.9.6.p.5">A cache seeing this header field will act correctly even if the cache does not understand the community cache-extension, since
         it will also see and understand the private directive and thus default to the safe behavior.
      </p>
      <p id="rfc.section.14.9.6.p.6">Unrecognized cache-directives <em class="bcp14">MUST</em> be ignored; it is assumed that any cache-directive likely to be unrecognized by an HTTP/1.1 cache will be combined with standard
         directives (or the response's default cacheability) such that the cache behavior will remain minimally correct even if the
         cache does not understand the extension(s).
      </p>
      <div id="rfc.iref.c.22"></div>
      <div id="rfc.iref.h.12"></div>
      <h2 id="rfc.section.14.10"><a href="#rfc.section.14.10">14.10</a>&nbsp;<a id="header.connection" href="#header.connection">Connection</a></h2>
      <p id="rfc.section.14.10.p.1">The Connection general-header field allows the sender to specify options that are desired for that particular connection and <em class="bcp14">MUST NOT</em> be communicated by proxies over further connections.
      </p>
      <p id="rfc.section.14.10.p.2">The Connection header has the following grammar:</p>
      <div id="rfc.figure.u.82"></div><pre class="inline"><span id="rfc.iref.g.115"></span><span id="rfc.iref.g.116"></span>    Connection = "Connection" ":" 1#(connection-token)
    connection-token  = token
</pre><p id="rfc.section.14.10.p.4">HTTP/1.1 proxies <em class="bcp14">MUST</em> parse the Connection header field before a message is forwarded and, for each connection-token in this field, remove any header
         field(s) from the message with the same name as the connection-token. Connection options are signaled by the presence of a
         connection-token in the Connection header field, not by any corresponding additional header field(s), since the additional
         header field may not be sent if there are no parameters associated with that connection option.
      </p>
      <p id="rfc.section.14.10.p.5">Message headers listed in the Connection header <em class="bcp14">MUST NOT</em> include end-to-end headers, such as Cache-Control.
      </p>
      <p id="rfc.section.14.10.p.6">HTTP/1.1 defines the "close" connection option for the sender to signal that the connection will be closed after completion
         of the response. For example,
      </p>
      <div id="rfc.figure.u.83"></div><pre class="text">    Connection: close
</pre><p id="rfc.section.14.10.p.8">in either the request or the response header fields indicates that the connection <em class="bcp14">SHOULD NOT</em> be considered `persistent' (<a href="#persistent.connections" title="Persistent Connections">Section&nbsp;8.1</a>) after the current request/response is complete.
      </p>
      <p id="rfc.section.14.10.p.9">HTTP/1.1 applications that do not support persistent connections <em class="bcp14">MUST</em> include the "close" connection option in every message.
      </p>
      <p id="rfc.section.14.10.p.10">A system receiving an HTTP/1.0 (or lower-version) message that includes a Connection header MUST, for each connection-token
         in this field, remove and ignore any header field(s) from the message with the same name as the connection-token. This protects
         against mistaken forwarding of such header fields by pre-HTTP/1.1 proxies. See <a href="#compatibility.with.http.1.0.persistent.connections" title="Compatibility with HTTP/1.0 Persistent Connections">Appendix&nbsp;19.6.2</a>.
      </p>
      <div id="rfc.iref.c.23"></div>
      <div id="rfc.iref.h.13"></div>
      <h2 id="rfc.section.14.11"><a href="#rfc.section.14.11">14.11</a>&nbsp;<a id="header.content-encoding" href="#header.content-encoding">Content-Encoding</a></h2>
      <p id="rfc.section.14.11.p.1">The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional
         content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain
         the media-type referenced by the Content-Type header field. Content-Encoding is primarily used to allow a document to be compressed
         without losing the identity of its underlying media type.
      </p>
      <div id="rfc.figure.u.84"></div><pre class="inline"><span id="rfc.iref.g.117"></span>    Content-Encoding  = "Content-Encoding" ":" 1#content-coding
</pre><p id="rfc.section.14.11.p.3">Content codings are defined in <a href="#content.codings" title="Content Codings">Section&nbsp;3.5</a>. An example of its use is
      </p>
      <div id="rfc.figure.u.85"></div><pre class="text">    Content-Encoding: gzip
</pre><p id="rfc.section.14.11.p.5">The content-coding is a characteristic of the entity identified by the Request-URI. Typically, the entity-body is stored with
         this encoding and is only decoded before rendering or analogous usage. However, a non-transparent proxy <em class="bcp14">MAY</em> modify the content-coding if the new coding is known to be acceptable to the recipient, unless the "no-transform" cache-control
         directive is present in the message.
      </p>
      <p id="rfc.section.14.11.p.6">If the content-coding of an entity is not "identity", then the response <em class="bcp14">MUST</em> include a Content-Encoding entity-header (<a href="#header.content-encoding" id="rfc.xref.header.content-encoding.3" title="Content-Encoding">Section&nbsp;14.11</a>) that lists the non-identity content-coding(s) used.
      </p>
      <p id="rfc.section.14.11.p.7">If the content-coding of an entity in a request message is not acceptable to the origin server, the server <em class="bcp14">SHOULD</em> respond with a status code of 415 (Unsupported Media Type).
      </p>
      <p id="rfc.section.14.11.p.8">If multiple encodings have been applied to an entity, the content codings <em class="bcp14">MUST</em> be listed in the order in which they were applied. Additional information about the encoding parameters <em class="bcp14">MAY</em> be provided by other entity-header fields not defined by this specification.
      </p>
      <div id="rfc.iref.c.24"></div>
      <div id="rfc.iref.h.14"></div>
      <h2 id="rfc.section.14.12"><a href="#rfc.section.14.12">14.12</a>&nbsp;<a id="header.content-language" href="#header.content-language">Content-Language</a></h2>
      <p id="rfc.section.14.12.p.1">The Content-Language entity-header field describes the natural language(s) of the intended audience for the enclosed entity.
         Note that this might not be equivalent to all the languages used within the entity-body.
      </p>
      <div id="rfc.figure.u.86"></div><pre class="inline"><span id="rfc.iref.g.118"></span>    Content-Language  = "Content-Language" ":" 1#language-tag
</pre><p id="rfc.section.14.12.p.3">Language tags are defined in <a href="#language.tags" title="Language Tags">Section&nbsp;3.10</a>. The primary purpose of Content-Language is to allow a user to identify and differentiate entities according to the user's
         own preferred language. Thus, if the body content is intended only for a Danish-literate audience, the appropriate field is
      </p>
      <div id="rfc.figure.u.87"></div><pre class="text">    Content-Language: da
</pre><p id="rfc.section.14.12.p.5">If no Content-Language is specified, the default is that the content is intended for all language audiences. This might mean
         that the sender does not consider it to be specific to any natural language, or that the sender does not know for which language
         it is intended.
      </p>
      <p id="rfc.section.14.12.p.6">Multiple languages <em class="bcp14">MAY</em> be listed for content that is intended for multiple audiences. For example, a rendition of the "Treaty of Waitangi," presented
         simultaneously in the original Maori and English versions, would call for
      </p>
      <div id="rfc.figure.u.88"></div><pre class="text">    Content-Language: mi, en
</pre><p id="rfc.section.14.12.p.8">However, just because multiple languages are present within an entity does not mean that it is intended for multiple linguistic
         audiences. An example would be a beginner's language primer, such as "A First Lesson in Latin," which is clearly intended
         to be used by an English-literate audience. In this case, the Content-Language would properly only include "en".
      </p>
      <p id="rfc.section.14.12.p.9">Content-Language <em class="bcp14">MAY</em> be applied to any media type -- it is not limited to textual documents.
      </p>
      <div id="rfc.iref.c.25"></div>
      <div id="rfc.iref.h.15"></div>
      <h2 id="rfc.section.14.13"><a href="#rfc.section.14.13">14.13</a>&nbsp;<a id="header.content-length" href="#header.content-length">Content-Length</a></h2>
      <p id="rfc.section.14.13.p.1">The Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient
         or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET.
      </p>
      <div id="rfc.figure.u.89"></div><pre class="inline"><span id="rfc.iref.g.119"></span>    Content-Length    = "Content-Length" ":" 1*DIGIT
</pre><p id="rfc.section.14.13.p.3">An example is</p>
      <div id="rfc.figure.u.90"></div><pre class="text">    Content-Length: 3495
</pre><p id="rfc.section.14.13.p.5">Applications <em class="bcp14">SHOULD</em> use this field to indicate the transfer-length of the message-body, unless this is prohibited by the rules in <a href="#message.length" title="Message Length">Section&nbsp;4.4</a>.
      </p>
      <p id="rfc.section.14.13.p.6">Any Content-Length greater than or equal to zero is a valid value. <a href="#message.length" title="Message Length">Section&nbsp;4.4</a> describes how to determine the length of a message-body if a Content-Length is not given.
      </p>
      <p id="rfc.section.14.13.p.7">Note that the meaning of this field is significantly different from the corresponding definition in MIME, where it is an optional
         field used within the "message/external-body" content-type. In HTTP, it <em class="bcp14">SHOULD</em> be sent whenever the message's length can be determined prior to being transferred, unless this is prohibited by the rules
         in <a href="#message.length" title="Message Length">Section&nbsp;4.4</a>.
      </p>
      <div id="rfc.iref.c.26"></div>
      <div id="rfc.iref.h.16"></div>
      <h2 id="rfc.section.14.14"><a href="#rfc.section.14.14">14.14</a>&nbsp;<a id="header.content-location" href="#header.content-location">Content-Location</a></h2>
      <p id="rfc.section.14.14.p.1">The Content-Location entity-header field <em class="bcp14">MAY</em> be used to supply the resource location for the entity enclosed in the message when that entity is accessible from a location
         separate from the requested resource's URI. A server <em class="bcp14">SHOULD</em> provide a Content-Location for the variant corresponding to the response entity; especially in the case where a resource has
         multiple entities associated with it, and those entities actually have separate locations by which they might be individually
         accessed, the server <em class="bcp14">SHOULD</em> provide a Content-Location for the particular variant which is returned.
      </p>
      <div id="rfc.figure.u.91"></div><pre class="inline"><span id="rfc.iref.g.120"></span>    Content-Location = "Content-Location" ":"
                      ( absoluteURI | relativeURI )
</pre><p id="rfc.section.14.14.p.3">The value of Content-Location also defines the base URI for the entity.</p>
      <p id="rfc.section.14.14.p.4">The Content-Location value is not a replacement for the original requested URI; it is only a statement of the location of
         the resource corresponding to this particular entity at the time of the request. Future requests <em class="bcp14">MAY</em> specify the Content-Location URI as the request-URI if the desire is to identify the source of that particular entity.
      </p>
      <p id="rfc.section.14.14.p.5">A cache cannot assume that an entity with a Content-Location different from the URI used to retrieve it can be used to respond
         to later requests on that Content-Location URI. However, the Content-Location can be used to differentiate between multiple
         entities retrieved from a single requested resource, as described in <a href="#caching.negotiated.responses" title="Caching Negotiated Responses">Section&nbsp;13.6</a>.
      </p>
      <p id="rfc.section.14.14.p.6">If the Content-Location is a relative URI, the relative URI is interpreted relative to the Request-URI.</p>
      <p id="rfc.section.14.14.p.7">The meaning of the Content-Location header in PUT or POST requests is undefined; servers are free to ignore it in those cases.</p>
      <div id="rfc.iref.c.27"></div>
      <div id="rfc.iref.h.17"></div>
      <h2 id="rfc.section.14.15"><a href="#rfc.section.14.15">14.15</a>&nbsp;<a id="header.content-md5" href="#header.content-md5">Content-MD5</a></h2>
      <p id="rfc.section.14.15.p.1">The Content-MD5 entity-header field, as defined in RFC 1864 <a href="#RFC1864" id="rfc.xref.RFC1864.1"><cite title="The Content-MD5 Header Field">[RFC1864]</cite></a>, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body.
         (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious
         attacks.)
      </p>
      <div id="rfc.figure.u.92"></div><pre class="inline"><span id="rfc.iref.g.121"></span><span id="rfc.iref.g.122"></span>     Content-MD5   = "Content-MD5" ":" md5-digest
     md5-digest   = &lt;base64 of 128 bit MD5 digest as per RFC 1864&gt;
</pre><p id="rfc.section.14.15.p.3">The Content-MD5 header field <em class="bcp14">MAY</em> be generated by an origin server or client to function as an integrity check of the entity-body. Only origin servers or clients <em class="bcp14">MAY</em> generate the Content-MD5 header field; proxies and gateways <em class="bcp14">MUST NOT</em> generate it, as this would defeat its value as an end-to-end integrity check. Any recipient of the entity-body, including
         gateways and proxies, <em class="bcp14">MAY</em> check that the digest value in this header field matches that of the entity-body as received.
      </p>
      <p id="rfc.section.14.15.p.4">The MD5 digest is computed based on the content of the entity-body, including any content-coding that has been applied, but
         not including any transfer-encoding applied to the message-body. If the message is received with a transfer-encoding, that
         encoding <em class="bcp14">MUST</em> be removed prior to checking the Content-MD5 value against the received entity.
      </p>
      <p id="rfc.section.14.15.p.5">This has the result that the digest is computed on the octets of the entity-body exactly as, and in the order that, they would
         be sent if no transfer-encoding were being applied.
      </p>
      <p id="rfc.section.14.15.p.6">HTTP extends RFC 1864 to permit the digest to be computed for MIME composite media-types (e.g., multipart/* and message/rfc822),
         but this does not change how the digest is computed as defined in the preceding paragraph.
      </p>
      <p id="rfc.section.14.15.p.7">There are several consequences of this. The entity-body for composite types <em class="bcp14">MAY</em> contain many body-parts, each with its own MIME and HTTP headers (including Content-MD5, Content-Transfer-Encoding, and Content-Encoding
         headers). If a body-part has a Content-Transfer-Encoding or Content-Encoding header, it is assumed that the content of the
         body-part has had the encoding applied, and the body-part is included in the Content-MD5 digest as is -- i.e., after the application.
         The Transfer-Encoding header field is not allowed within body-parts.
      </p>
      <p id="rfc.section.14.15.p.8">Conversion of all line breaks to CRLF <em class="bcp14">MUST NOT</em> be done before computing or checking the digest: the line break convention used in the text actually transmitted <em class="bcp14">MUST</em> be left unaltered when computing the digest. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> while the definition of Content-MD5 is exactly the same for HTTP as in RFC 1864 for MIME entity-bodies, there are several
            ways in which the application of Content-MD5 to HTTP entity-bodies differs from its application to MIME entity-bodies. One
            is that HTTP, unlike MIME, does not use Content-Transfer-Encoding, and does use Transfer-Encoding and Content-Encoding. Another
            is that HTTP more frequently uses binary content types than MIME, so it is worth noting that, in such cases, the byte order
            used to compute the digest is the transmission byte order defined for the type. Lastly, HTTP allows transmission of text types
            with any of several line break conventions and not just the canonical form using CRLF.
         </dd>
      </dl>
      <div id="rfc.iref.c.28"></div>
      <div id="rfc.iref.h.18"></div>
      <h2 id="rfc.section.14.16"><a href="#rfc.section.14.16">14.16</a>&nbsp;<a id="header.content-range" href="#header.content-range">Content-Range</a></h2>
      <p id="rfc.section.14.16.p.1">The Content-Range entity-header is sent with a partial entity-body to specify where in the full entity-body the partial body
         should be applied. Range units are defined in <a href="#range.units" title="Range Units">Section&nbsp;3.12</a>.
      </p>
      <div id="rfc.figure.u.93"></div><pre class="inline"><span id="rfc.iref.g.123"></span><span id="rfc.iref.g.124"></span><span id="rfc.iref.g.125"></span><span id="rfc.iref.g.126"></span><span id="rfc.iref.g.127"></span>    Content-Range = "Content-Range" ":" content-range-spec

    content-range-spec      = byte-content-range-spec
    byte-content-range-spec = bytes-unit SP
                              byte-range-resp-spec "/"
                              ( instance-length | "*" )

    byte-range-resp-spec = (first-byte-pos "-" last-byte-pos)
                                   | "*"
    instance-length           = 1*DIGIT
</pre><p id="rfc.section.14.16.p.3">The header <em class="bcp14">SHOULD</em> indicate the total length of the full entity-body, unless this length is unknown or difficult to determine. The asterisk "*"
         character means that the instance-length is unknown at the time when the response was generated.
      </p>
      <p id="rfc.section.14.16.p.4">Unlike byte-ranges-specifier values (see <a href="#byte.ranges" title="Byte Ranges">Section&nbsp;14.35.1</a>), a byte-range-resp-spec <em class="bcp14">MUST</em> only specify one range, and <em class="bcp14">MUST</em> contain absolute byte positions for both the first and last byte of the range.
      </p>
      <p id="rfc.section.14.16.p.5">A byte-content-range-spec with a byte-range-resp-spec whose last-byte-pos value is less than its first-byte-pos value, or
         whose instance-length value is less than or equal to its last-byte-pos value, is invalid. The recipient of an invalid byte-content-range-spec <em class="bcp14">MUST</em> ignore it and any content transferred along with it.
      </p>
      <p id="rfc.section.14.16.p.6">A server sending a response with status code 416 (Requested range not satisfiable) <em class="bcp14">SHOULD</em> include a Content-Range field with a byte-range-resp-spec of "*". The instance-length specifies the current length of the
         selected resource. A response with status code 206 (Partial Content) <em class="bcp14">MUST NOT</em> include a Content-Range field with a byte-range-resp-spec of "*".
      </p>
      <p id="rfc.section.14.16.p.7">Examples of byte-content-range-spec values, assuming that the entity contains a total of 1234 bytes: </p>
      <ul>
         <li>The first 500 bytes: 
            <div id="rfc.figure.u.94"></div><pre class="text">   bytes 0-499/1234
</pre> </li>
         <li>The second 500 bytes: 
            <div id="rfc.figure.u.95"></div><pre class="text">   bytes 500-999/1234
</pre> </li>
         <li>All except for the first 500 bytes: 
            <div id="rfc.figure.u.96"></div><pre class="text">   bytes 500-1233/1234
</pre> </li>
         <li>The last 500 bytes: 
            <div id="rfc.figure.u.97"></div><pre class="text">   bytes 734-1233/1234
</pre> </li>
      </ul>
      <p id="rfc.section.14.16.p.8">When an HTTP message includes the content of a single range (for example, a response to a request for a single range, or to
         a request for a set of ranges that overlap without any holes), this content is transmitted with a Content-Range header, and
         a Content-Length header showing the number of bytes actually transferred. For example,
      </p>
      <div id="rfc.figure.u.98"></div><pre class="text">    HTTP/1.1 206 Partial content
    Date: Wed, 15 Nov 1995 06:25:24 GMT
    Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
    Content-Range: bytes 21010-47021/47022
    Content-Length: 26012
    Content-Type: image/gif
</pre><p id="rfc.section.14.16.p.10">When an HTTP message includes the content of multiple ranges (for example, a response to a request for multiple non-overlapping
         ranges), these are transmitted as a multipart message. The multipart media type used for this purpose is "multipart/byteranges"
         as defined in <a href="#internet.media.type.multipart.byteranges" title="Internet Media Type multipart/byteranges">Appendix&nbsp;19.2</a>. See <a href="#changes.from.rfc.2068" title="Changes from RFC 2068">Appendix&nbsp;19.6.3</a> for a compatibility issue.
      </p>
      <p id="rfc.section.14.16.p.11">A response to a request for a single range <em class="bcp14">MUST NOT</em> be sent using the multipart/byteranges media type. A response to a request for multiple ranges, whose result is a single range, <em class="bcp14">MAY</em> be sent as a multipart/byteranges media type with one part. A client that cannot decode a multipart/byteranges message <em class="bcp14">MUST NOT</em> ask for multiple byte-ranges in a single request.
      </p>
      <p id="rfc.section.14.16.p.12">When a client requests multiple byte-ranges in one request, the server <em class="bcp14">SHOULD</em> return them in the order that they appeared in the request.
      </p>
      <p id="rfc.section.14.16.p.13">If the server ignores a byte-range-spec because it is syntactically invalid, the server <em class="bcp14">SHOULD</em> treat the request as if the invalid Range header field did not exist. (Normally, this means return a 200 response containing
         the full entity).
      </p>
      <p id="rfc.section.14.16.p.14">If the server receives a request (other than one including an If-Range request-header field) with an unsatisfiable Range request-header
         field (that is, all of whose byte-range-spec values have a first-byte-pos value greater than the current length of the selected
         resource), it <em class="bcp14">SHOULD</em> return a response code of 416 (Requested range not satisfiable) (<a href="#status.416" id="rfc.xref.status.416.2" title="416 Requested Range Not Satisfiable">Section&nbsp;10.4.17</a>). 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> clients cannot depend on servers to send a 416 (Requested range not satisfiable) response instead of a 200 (OK) response for
            an unsatisfiable Range request-header, since not all servers implement this request-header.
         </dd>
      </dl>
      <div id="rfc.iref.c.29"></div>
      <div id="rfc.iref.h.19"></div>
      <h2 id="rfc.section.14.17"><a href="#rfc.section.14.17">14.17</a>&nbsp;<a id="header.content-type" href="#header.content-type">Content-Type</a></h2>
      <p id="rfc.section.14.17.p.1">The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of
         the HEAD method, the media type that would have been sent had the request been a GET.
      </p>
      <div id="rfc.figure.u.99"></div><pre class="inline"><span id="rfc.iref.g.128"></span>    Content-Type   = "Content-Type" ":" media-type
</pre><p id="rfc.section.14.17.p.3">Media types are defined in <a href="#media.types" title="Media Types">Section&nbsp;3.7</a>. An example of the field is
      </p>
      <div id="rfc.figure.u.100"></div><pre class="text">    Content-Type: text/html; charset=ISO-8859-4
</pre><p id="rfc.section.14.17.p.5">Further discussion of methods for identifying the media type of an entity is provided in <a href="#type" title="Type">Section&nbsp;7.2.1</a>.
      </p>
      <div id="rfc.iref.d.4"></div>
      <div id="rfc.iref.h.20"></div>
      <h2 id="rfc.section.14.18"><a href="#rfc.section.14.18">14.18</a>&nbsp;<a id="header.date" href="#header.date">Date</a></h2>
      <p id="rfc.section.14.18.p.1">The Date general-header field represents the date and time at which the message was originated, having the same semantics
         as orig-date in RFC 822. The field value is an HTTP-date, as described in <a href="#full.date" title="Full Date">Section&nbsp;3.3.1</a>; it <em class="bcp14">MUST</em> be sent in RFC 1123 <a href="#RFC1123" id="rfc.xref.RFC1123.2"><cite title="Requirements for Internet Hosts - Application and Support">[RFC1123]</cite></a>-date format.
      </p>
      <div id="rfc.figure.u.101"></div><pre class="inline"><span id="rfc.iref.g.129"></span>    Date  = "Date" ":" HTTP-date
</pre><p id="rfc.section.14.18.p.3">An example is</p>
      <div id="rfc.figure.u.102"></div><pre class="text">    Date: Tue, 15 Nov 1994 08:12:31 GMT
</pre><p id="rfc.section.14.18.p.5">Origin servers <em class="bcp14">MUST</em> include a Date header field in all responses, except in these cases: 
      </p>
      <ol>
         <li>If the response status code is 100 (Continue) or 101 (Switching Protocols), the response <em class="bcp14">MAY</em> include a Date header field, at the server's option.
         </li>
         <li>If the response status code conveys a server error, e.g. 500 (Internal Server Error) or 503 (Service Unavailable), and it
            is inconvenient or impossible to generate a valid Date.
         </li>
         <li>If the server does not have a clock that can provide a reasonable approximation of the current time, its responses <em class="bcp14">MUST NOT</em> include a Date header field. In this case, the rules in <a href="#clockless.origin.server.operation" title="Clockless Origin Server Operation">Section&nbsp;14.18.1</a>  <em class="bcp14">MUST</em> be followed.
         </li>
      </ol>
      <p id="rfc.section.14.18.p.6">A received message that does not have a Date header field <em class="bcp14">MUST</em> be assigned one by the recipient if the message will be cached by that recipient or gatewayed via a protocol which requires
         a Date. An HTTP implementation without a clock <em class="bcp14">MUST NOT</em> cache responses without revalidating them on every use. An HTTP cache, especially a shared cache, <em class="bcp14">SHOULD</em> use a mechanism, such as NTP <a href="#RFC1305" id="rfc.xref.RFC1305.2"><cite title="Network Time Protocol (Version 3) Specification, Implementation">[RFC1305]</cite></a>, to synchronize its clock with a reliable external standard.
      </p>
      <p id="rfc.section.14.18.p.7">Clients <em class="bcp14">SHOULD</em> only send a Date header field in messages that include an entity-body, as in the case of the PUT and POST requests, and even
         then it is optional. A client without a clock <em class="bcp14">MUST NOT</em> send a Date header field in a request.
      </p>
      <p id="rfc.section.14.18.p.8">The HTTP-date sent in a Date header <em class="bcp14">SHOULD NOT</em> represent a date and time subsequent to the generation of the message. It <em class="bcp14">SHOULD</em> represent the best available approximation of the date and time of message generation, unless the implementation has no means
         of generating a reasonably accurate date and time. In theory, the date ought to represent the moment just before the entity
         is generated. In practice, the date can be generated at any time during the message origination without affecting its semantic
         value.
      </p>
      <h3 id="rfc.section.14.18.1"><a href="#rfc.section.14.18.1">14.18.1</a>&nbsp;<a id="clockless.origin.server.operation" href="#clockless.origin.server.operation">Clockless Origin Server Operation</a></h3>
      <p id="rfc.section.14.18.1.p.1">Some origin server implementations might not have a clock available. An origin server without a clock <em class="bcp14">MUST NOT</em> assign Expires or Last-Modified values to a response, unless these values were associated with the resource by a system or
         user with a reliable clock. It <em class="bcp14">MAY</em> assign an Expires value that is known, at or before server configuration time, to be in the past (this allows "pre-expiration"
         of responses without storing separate Expires values for each resource).
      </p>
      <div id="rfc.iref.e.3"></div>
      <div id="rfc.iref.h.21"></div>
      <h2 id="rfc.section.14.19"><a href="#rfc.section.14.19">14.19</a>&nbsp;<a id="header.etag" href="#header.etag">ETag</a></h2>
      <p id="rfc.section.14.19.p.1">The ETag response-header field provides the current value of the entity tag for the requested variant. The headers used with
         entity tags are described in sections <a href="#header.if-match" id="rfc.xref.header.if-match.4" title="If-Match">14.24</a>, <a href="#header.if-none-match" id="rfc.xref.header.if-none-match.4" title="If-None-Match">14.26</a> and <a href="#header.vary" id="rfc.xref.header.vary.5" title="Vary">14.44</a>. The entity tag <em class="bcp14">MAY</em> be used for comparison with other entities from the same resource (see <a href="#weak.and.strong.validators" title="Weak and Strong Validators">Section&nbsp;13.3.3</a>).
      </p>
      <div id="rfc.figure.u.103"></div><pre class="inline"><span id="rfc.iref.g.130"></span>    ETag = "ETag" ":" entity-tag
</pre><div id="rfc.figure.u.104"></div>
      <p>Examples:</p>  <pre class="text">   ETag: "xyzzy"
   ETag: W/"xyzzy"
   ETag: ""
</pre><div id="rfc.iref.e.4"></div>
      <div id="rfc.iref.h.22"></div>
      <h2 id="rfc.section.14.20"><a href="#rfc.section.14.20">14.20</a>&nbsp;<a id="header.expect" href="#header.expect">Expect</a></h2>
      <p id="rfc.section.14.20.p.1">The Expect request-header field is used to indicate that particular server behaviors are required by the client.</p>
      <div id="rfc.figure.u.105"></div><pre class="inline"><span id="rfc.iref.g.131"></span><span id="rfc.iref.g.132"></span><span id="rfc.iref.g.133"></span><span id="rfc.iref.g.134"></span>   Expect       =  "Expect" ":" 1#expectation

   expectation  =  "100-continue" | expectation-extension
   expectation-extension =  token [ "=" ( token | quoted-string )
                            *expect-params ]
   expect-params =  ";" token [ "=" ( token | quoted-string ) ]
</pre><p id="rfc.section.14.20.p.3">A server that does not understand or is unable to comply with any of the expectation values in the Expect field of a request <em class="bcp14">MUST</em> respond with appropriate error status. The server <em class="bcp14">MUST</em> respond with a 417 (Expectation Failed) status if any of the expectations cannot be met or, if there are other problems with
         the request, some other 4xx status.
      </p>
      <p id="rfc.section.14.20.p.4">This header field is defined with extensible syntax to allow for future extensions. If a server receives a request containing
         an Expect field that includes an expectation-extension that it does not support, it <em class="bcp14">MUST</em> respond with a 417 (Expectation Failed) status.
      </p>
      <p id="rfc.section.14.20.p.5">Comparison of expectation values is case-insensitive for unquoted tokens (including the 100-continue token), and is case-sensitive
         for quoted-string expectation-extensions.
      </p>
      <p id="rfc.section.14.20.p.6">The Expect mechanism is hop-by-hop: that is, an HTTP/1.1 proxy <em class="bcp14">MUST</em> return a 417 (Expectation Failed) status if it receives a request with an expectation that it cannot meet. However, the Expect
         request-header itself is end-to-end; it <em class="bcp14">MUST</em> be forwarded if the request is forwarded.
      </p>
      <p id="rfc.section.14.20.p.7">Many older HTTP/1.0 and HTTP/1.1 applications do not understand the Expect header.</p>
      <p id="rfc.section.14.20.p.8">See <a href="#use.of.the.100.status" title="Use of the 100 (Continue) Status">Section&nbsp;8.2.3</a> for the use of the 100 (continue) status.
      </p>
      <div id="rfc.iref.e.5"></div>
      <div id="rfc.iref.h.23"></div>
      <h2 id="rfc.section.14.21"><a href="#rfc.section.14.21">14.21</a>&nbsp;<a id="header.expires" href="#header.expires">Expires</a></h2>
      <p id="rfc.section.14.21.p.1">The Expires entity-header field gives the date/time after which the response is considered stale. A stale cache entry may
         not normally be returned by a cache (either a proxy cache or a user agent cache) unless it is first validated with the origin
         server (or with an intermediate cache that has a fresh copy of the entity). See <a href="#expiration.model" title="Expiration Model">Section&nbsp;13.2</a> for further discussion of the expiration model.
      </p>
      <p id="rfc.section.14.21.p.2">The presence of an Expires field does not imply that the original resource will change or cease to exist at, before, or after
         that time.
      </p>
      <p id="rfc.section.14.21.p.3">The format is an absolute date and time as defined by HTTP-date in <a href="#full.date" title="Full Date">Section&nbsp;3.3.1</a>; it <em class="bcp14">MUST</em> be in RFC 1123 date format:
      </p>
      <div id="rfc.figure.u.106"></div><pre class="inline"><span id="rfc.iref.g.135"></span>   Expires = "Expires" ":" HTTP-date
</pre><p id="rfc.section.14.21.p.5">An example of its use is</p>
      <div id="rfc.figure.u.107"></div><pre class="text">   Expires: Thu, 01 Dec 1994 16:00:00 GMT
</pre><p id="rfc.section.14.21.p.7"> </p>
      <dl class="empty">
         <dd> <b>Note:</b> if a response includes a Cache-Control field with the max-age directive (see <a href="#modifications.of.the.basic.expiration.mechanism" title="Modifications of the Basic Expiration Mechanism">Section&nbsp;14.9.3</a>), that directive overrides the Expires field.
         </dd>
      </dl>
      <p id="rfc.section.14.21.p.8">HTTP/1.1 clients and caches <em class="bcp14">MUST</em> treat other invalid date formats, especially including the value "0", as in the past (i.e., "already expired").
      </p>
      <p id="rfc.section.14.21.p.9">To mark a response as "already expired," an origin server sends an Expires date that is equal to the Date header value. (See
         the rules for expiration calculations in <a href="#expiration.calculations" title="Expiration Calculations">Section&nbsp;13.2.4</a>.)
      </p>
      <p id="rfc.section.14.21.p.10">To mark a response as "never expires," an origin server sends an Expires date approximately one year from the time the response
         is sent. HTTP/1.1 servers <em class="bcp14">SHOULD NOT</em> send Expires dates more than one year in the future.
      </p>
      <p id="rfc.section.14.21.p.11">The presence of an Expires header field with a date value of some time in the future on a response that otherwise would by
         default be non-cacheable indicates that the response is cacheable, unless indicated otherwise by a Cache-Control header field
         (<a href="#header.cache-control" id="rfc.xref.header.cache-control.10" title="Cache-Control">Section&nbsp;14.9</a>).
      </p>
      <div id="rfc.iref.f.4"></div>
      <div id="rfc.iref.h.24"></div>
      <h2 id="rfc.section.14.22"><a href="#rfc.section.14.22">14.22</a>&nbsp;<a id="header.from" href="#header.from">From</a></h2>
      <p id="rfc.section.14.22.p.1">The From request-header field, if given, <em class="bcp14">SHOULD</em> contain an Internet e-mail address for the human user who controls the requesting user agent. The address <em class="bcp14">SHOULD</em> be machine-usable, as defined by "mailbox" in RFC 822 <a href="#RFC822" id="rfc.xref.RFC822.7"><cite title="Standard for the format of ARPA Internet text messages">[RFC822]</cite></a> as updated by RFC 1123 <a href="#RFC1123" id="rfc.xref.RFC1123.3"><cite title="Requirements for Internet Hosts - Application and Support">[RFC1123]</cite></a>:
      </p>
      <div id="rfc.figure.u.108"></div><pre class="inline"><span id="rfc.iref.g.136"></span>    From   = "From" ":" mailbox
</pre><p id="rfc.section.14.22.p.3">An example is:</p>
      <div id="rfc.figure.u.109"></div><pre class="text">    From: webmaster@w3.org
</pre><p id="rfc.section.14.22.p.5">This header field <em class="bcp14">MAY</em> be used for logging purposes and as a means for identifying the source of invalid or unwanted requests. It <em class="bcp14">SHOULD NOT</em> be used as an insecure form of access protection. The interpretation of this field is that the request is being performed
         on behalf of the person given, who accepts responsibility for the method performed. In particular, robot agents <em class="bcp14">SHOULD</em> include this header so that the person responsible for running the robot can be contacted if problems occur on the receiving
         end.
      </p>
      <p id="rfc.section.14.22.p.6">The Internet e-mail address in this field <em class="bcp14">MAY</em> be separate from the Internet host which issued the request. For example, when a request is passed through a proxy the original
         issuer's address <em class="bcp14">SHOULD</em> be used.
      </p>
      <p id="rfc.section.14.22.p.7">The client <em class="bcp14">SHOULD NOT</em> send the From header field without the user's approval, as it might conflict with the user's privacy interests or their site's
         security policy. It is strongly recommended that the user be able to disable, enable, and modify the value of this field at
         any time prior to a request.
      </p>
      <div id="rfc.iref.h.25"></div>
      <div id="rfc.iref.h.26"></div>
      <h2 id="rfc.section.14.23"><a href="#rfc.section.14.23">14.23</a>&nbsp;<a id="header.host" href="#header.host">Host</a></h2>
      <p id="rfc.section.14.23.p.1">The Host request-header field specifies the Internet host and port number of the resource being requested, as obtained from
         the original URI given by the user or referring resource (generally an HTTP URL, as described in <a href="#http.url" title="http URL">Section&nbsp;3.2.2</a>). The Host field value <em class="bcp14">MUST</em> represent the naming authority of the origin server or gateway given by the original URL. This allows the origin server or
         gateway to differentiate between internally-ambiguous URLs, such as the root "/" URL of a server for multiple host names on
         a single IP address.
      </p>
      <div id="rfc.figure.u.110"></div><pre class="inline"><span id="rfc.iref.g.137"></span>    Host = "Host" ":" host [ ":" port ] ; <a href="#http.url" title="http URL">Section&nbsp;3.2.2</a>
</pre><p id="rfc.section.14.23.p.3">A "host" without any trailing port information implies the default port for the service requested (e.g., "80" for an HTTP
         URL). For example, a request on the origin server for &lt;http://www.w3.org/pub/WWW/&gt; would properly include:
      </p>
      <div id="rfc.figure.u.111"></div><pre class="text">    GET /pub/WWW/ HTTP/1.1
    Host: www.w3.org
</pre><p id="rfc.section.14.23.p.5">A client <em class="bcp14">MUST</em> include a Host header field in all HTTP/1.1 request messages . If the requested URI does not include an Internet host name
         for the service being requested, then the Host header field <em class="bcp14">MUST</em> be given with an empty value. An HTTP/1.1 proxy <em class="bcp14">MUST</em> ensure that any request message it forwards does contain an appropriate Host header field that identifies the service being
         requested by the proxy. All Internet-based HTTP/1.1 servers <em class="bcp14">MUST</em> respond with a 400 (Bad Request) status code to any HTTP/1.1 request message which lacks a Host header field.
      </p>
      <p id="rfc.section.14.23.p.6">See sections <a href="#the.resource.identified.by.a.request" title="The Resource Identified by a Request">5.2</a> and <a href="#changes.to.simplify.multi-homed.web.servers.and.conserve.ip.addresses" title="Changes to Simplify Multi-homed Web Servers and Conserve IP Addresses">19.6.1.1</a> for other requirements relating to Host.
      </p>
      <div id="rfc.iref.i.3"></div>
      <div id="rfc.iref.h.27"></div>
      <h2 id="rfc.section.14.24"><a href="#rfc.section.14.24">14.24</a>&nbsp;<a id="header.if-match" href="#header.if-match">If-Match</a></h2>
      <p id="rfc.section.14.24.p.1">The If-Match request-header field is used with a method to make it conditional. A client that has one or more entities previously
         obtained from the resource can verify that one of those entities is current by including a list of their associated entity
         tags in the If-Match header field. Entity tags are defined in <a href="#entity.tags" title="Entity Tags">Section&nbsp;3.11</a>. The purpose of this feature is to allow efficient updates of cached information with a minimum amount of transaction overhead.
         It is also used, on updating requests, to prevent inadvertent modification of the wrong version of a resource. As a special
         case, the value "*" matches any current entity of the resource.
      </p>
      <div id="rfc.figure.u.112"></div><pre class="inline"><span id="rfc.iref.g.138"></span>    If-Match = "If-Match" ":" ( "*" | 1#entity-tag )
</pre><p id="rfc.section.14.24.p.3">If any of the entity tags match the entity tag of the entity that would have been returned in the response to a similar GET
         request (without the If-Match header) on that resource, or if "*" is given and any current entity exists for that resource,
         then the server <em class="bcp14">MAY</em> perform the requested method as if the If-Match header field did not exist.
      </p>
      <p id="rfc.section.14.24.p.4">A server <em class="bcp14">MUST</em> use the strong comparison function (see <a href="#weak.and.strong.validators" title="Weak and Strong Validators">Section&nbsp;13.3.3</a>) to compare the entity tags in If-Match.
      </p>
      <p id="rfc.section.14.24.p.5">If none of the entity tags match, or if "*" is given and no current entity exists, the server <em class="bcp14">MUST NOT</em> perform the requested method, and <em class="bcp14">MUST</em> return a 412 (Precondition Failed) response. This behavior is most useful when the client wants to prevent an updating method,
         such as PUT, from modifying a resource that has changed since the client last retrieved it.
      </p>
      <p id="rfc.section.14.24.p.6">If the request would, without the If-Match header field, result in anything other than a 2xx or 412 status, then the If-Match
         header <em class="bcp14">MUST</em> be ignored.
      </p>
      <p id="rfc.section.14.24.p.7">The meaning of "If-Match: *" is that the method <em class="bcp14">SHOULD</em> be performed if the representation selected by the origin server (or by a cache, possibly using the Vary mechanism, see <a href="#header.vary" id="rfc.xref.header.vary.6" title="Vary">Section&nbsp;14.44</a>) exists, and <em class="bcp14">MUST NOT</em> be performed if the representation does not exist.
      </p>
      <p id="rfc.section.14.24.p.8">A request intended to update a resource (e.g., a PUT) <em class="bcp14">MAY</em> include an If-Match header field to signal that the request method <em class="bcp14">MUST NOT</em> be applied if the entity corresponding to the If-Match value (a single entity tag) is no longer a representation of that resource.
         This allows the user to indicate that they do not wish the request to be successful if the resource has been changed without
         their knowledge. Examples:
      </p>
      <div id="rfc.figure.u.113"></div><pre class="text">    If-Match: "xyzzy"
    If-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
    If-Match: *
</pre><p id="rfc.section.14.24.p.10">The result of a request having both an If-Match header field and either an If-None-Match or an If-Modified-Since header fields
         is undefined by this specification.
      </p>
      <div id="rfc.iref.i.4"></div>
      <div id="rfc.iref.h.28"></div>
      <h2 id="rfc.section.14.25"><a href="#rfc.section.14.25">14.25</a>&nbsp;<a id="header.if-modified-since" href="#header.if-modified-since">If-Modified-Since</a></h2>
      <p id="rfc.section.14.25.p.1">The If-Modified-Since request-header field is used with a method to make it conditional: if the requested variant has not
         been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not
         modified) response will be returned without any message-body.
      </p>
      <div id="rfc.figure.u.114"></div><pre class="inline"><span id="rfc.iref.g.139"></span>    If-Modified-Since = "If-Modified-Since" ":" HTTP-date
</pre><p id="rfc.section.14.25.p.3">An example of the field is:</p>
      <div id="rfc.figure.u.115"></div><pre class="text">    If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</pre><p id="rfc.section.14.25.p.5">A GET method with an If-Modified-Since header and no Range header requests that the identified entity be transferred only
         if it has been modified since the date given by the If-Modified-Since header. The algorithm for determining this includes
         the following cases: 
      </p>
      <ol>
         <li>If the request would normally result in anything other than a 200 (OK) status, or if the passed If-Modified-Since date is
            invalid, the response is exactly the same as for a normal GET. A date which is later than the server's current time is invalid.
         </li>
         <li>If the variant has been modified since the If-Modified-Since date, the response is exactly the same as for a normal GET.</li>
         <li>If the variant has not been modified since a valid If-Modified-Since date, the server <em class="bcp14">SHOULD</em> return a 304 (Not Modified) response.
         </li>
      </ol>
      <p id="rfc.section.14.25.p.6">The purpose of this feature is to allow efficient updates of cached information with a minimum amount of transaction overhead. </p>
      <dl class="empty">
         <dd> <b>Note:</b> The Range request-header field modifies the meaning of If-Modified-Since; see <a href="#header.range" id="rfc.xref.header.range.6" title="Range">Section&nbsp;14.35</a> for full details.
         </dd>
         <dd> <b>Note:</b> If-Modified-Since times are interpreted by the server, whose clock might not be synchronized with the client.
         </dd>
         <dd> <b>Note:</b> When handling an If-Modified-Since header field, some servers will use an exact date comparison function, rather than a less-than
            function, for deciding whether to send a 304 (Not Modified) response. To get best results when sending an If-Modified-Since
            header field for cache validation, clients are advised to use the exact date string received in a previous Last-Modified header
            field whenever possible.
         </dd>
         <dd> <b>Note:</b> If a client uses an arbitrary date in the If-Modified-Since header instead of a date taken from the Last-Modified header for
            the same request, the client should be aware of the fact that this date is interpreted in the server's understanding of time.
            The client should consider unsynchronized clocks and rounding problems due to the different encodings of time between the
            client and server. This includes the possibility of race conditions if the document has changed between the time it was first
            requested and the If-Modified-Since date of a subsequent request, and the possibility of clock-skew-related problems if the
            If-Modified-Since date is derived from the client's clock without correction to the server's clock. Corrections for different
            time bases between client and server are at best approximate due to network latency.
         </dd>
      </dl>
      <p id="rfc.section.14.25.p.7">The result of a request having both an If-Modified-Since header field and either an If-Match or an If-Unmodified-Since header
         fields is undefined by this specification.
      </p>
      <div id="rfc.iref.i.5"></div>
      <div id="rfc.iref.h.29"></div>
      <h2 id="rfc.section.14.26"><a href="#rfc.section.14.26">14.26</a>&nbsp;<a id="header.if-none-match" href="#header.if-none-match">If-None-Match</a></h2>
      <p id="rfc.section.14.26.p.1">The If-None-Match request-header field is used with a method to make it conditional. A client that has one or more entities
         previously obtained from the resource can verify that none of those entities is current by including a list of their associated
         entity tags in the If-None-Match header field. The purpose of this feature is to allow efficient updates of cached information
         with a minimum amount of transaction overhead. It is also used to prevent a method (e.g. PUT) from inadvertently modifying
         an existing resource when the client believes that the resource does not exist.
      </p>
      <p id="rfc.section.14.26.p.2">As a special case, the value "*" matches any current entity of the resource.</p>
      <div id="rfc.figure.u.116"></div><pre class="inline"><span id="rfc.iref.g.140"></span>    If-None-Match = "If-None-Match" ":" ( "*" | 1#entity-tag )
</pre><p id="rfc.section.14.26.p.4">If any of the entity tags match the entity tag of the entity that would have been returned in the response to a similar GET
         request (without the If-None-Match header) on that resource, or if "*" is given and any current entity exists for that resource,
         then the server <em class="bcp14">MUST NOT</em> perform the requested method, unless required to do so because the resource's modification date fails to match that supplied
         in an If-Modified-Since header field in the request. Instead, if the request method was GET or HEAD, the server <em class="bcp14">SHOULD</em> respond with a 304 (Not Modified) response, including the cache-related header fields (particularly ETag) of one of the entities
         that matched. For all other request methods, the server <em class="bcp14">MUST</em> respond with a status of 412 (Precondition Failed).
      </p>
      <p id="rfc.section.14.26.p.5">See <a href="#weak.and.strong.validators" title="Weak and Strong Validators">Section&nbsp;13.3.3</a> for rules on how to determine if two entities tags match. The weak comparison function can only be used with GET or HEAD requests.
      </p>
      <p id="rfc.section.14.26.p.6">If none of the entity tags match, then the server <em class="bcp14">MAY</em> perform the requested method as if the If-None-Match header field did not exist, but <em class="bcp14">MUST</em> also ignore any If-Modified-Since header field(s) in the request. That is, if no entity tags match, then the server <em class="bcp14">MUST NOT</em> return a 304 (Not Modified) response.
      </p>
      <p id="rfc.section.14.26.p.7">If the request would, without the If-None-Match header field, result in anything other than a 2xx or 304 status, then the
         If-None-Match header <em class="bcp14">MUST</em> be ignored. (See <a href="#rules.for.when.to.use.entity.tags.and.last-modified.dates" title="Rules for When to Use Entity Tags and Last-Modified Dates">Section&nbsp;13.3.4</a> for a discussion of server behavior when both If-Modified-Since and If-None-Match appear in the same request.)
      </p>
      <p id="rfc.section.14.26.p.8">The meaning of "If-None-Match: *" is that the method <em class="bcp14">MUST NOT</em> be performed if the representation selected by the origin server (or by a cache, possibly using the Vary mechanism, see <a href="#header.vary" id="rfc.xref.header.vary.7" title="Vary">Section&nbsp;14.44</a>) exists, and <em class="bcp14">SHOULD</em> be performed if the representation does not exist. This feature is intended to be useful in preventing races between PUT operations.
      </p>
      <p id="rfc.section.14.26.p.9">Examples:</p>
      <div id="rfc.figure.u.117"></div><pre class="text">    If-None-Match: "xyzzy"
    If-None-Match: W/"xyzzy"
    If-None-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
    If-None-Match: W/"xyzzy", W/"r2d2xxxx", W/"c3piozzzz"
    If-None-Match: *
</pre><p id="rfc.section.14.26.p.11">The result of a request having both an If-None-Match header field and either an If-Match or an If-Unmodified-Since header
         fields is undefined by this specification.
      </p>
      <div id="rfc.iref.i.6"></div>
      <div id="rfc.iref.h.30"></div>
      <h2 id="rfc.section.14.27"><a href="#rfc.section.14.27">14.27</a>&nbsp;<a id="header.if-range" href="#header.if-range">If-Range</a></h2>
      <p id="rfc.section.14.27.p.1">If a client has a partial copy of an entity in its cache, and wishes to have an up-to-date copy of the entire entity in its
         cache, it could use the Range request-header with a conditional GET (using either or both of If-Unmodified-Since and If-Match.)
         However, if the condition fails because the entity has been modified, the client would then have to make a second request
         to obtain the entire current entity-body.
      </p>
      <p id="rfc.section.14.27.p.2">The If-Range header allows a client to "short-circuit" the second request. Informally, its meaning is `if the entity is unchanged,
         send me the part(s) that I am missing; otherwise, send me the entire new entity'.
      </p>
      <div id="rfc.figure.u.118"></div><pre class="inline"><span id="rfc.iref.g.141"></span>     If-Range = "If-Range" ":" ( entity-tag | HTTP-date )
</pre><p id="rfc.section.14.27.p.4">If the client has no entity tag for an entity, but does have a Last-Modified date, it <em class="bcp14">MAY</em> use that date in an If-Range header. (The server can distinguish between a valid HTTP-date and any form of entity-tag by examining
         no more than two characters.) The If-Range header <em class="bcp14">SHOULD</em> only be used together with a Range header, and <em class="bcp14">MUST</em> be ignored if the request does not include a Range header, or if the server does not support the sub-range operation.
      </p>
      <p id="rfc.section.14.27.p.5">If the entity tag given in the If-Range header matches the current entity tag for the entity, then the server <em class="bcp14">SHOULD</em> provide the specified sub-range of the entity using a 206 (Partial content) response. If the entity tag does not match, then
         the server <em class="bcp14">SHOULD</em> return the entire entity using a 200 (OK) response.
      </p>
      <div id="rfc.iref.i.7"></div>
      <div id="rfc.iref.h.31"></div>
      <h2 id="rfc.section.14.28"><a href="#rfc.section.14.28">14.28</a>&nbsp;<a id="header.if-unmodified-since" href="#header.if-unmodified-since">If-Unmodified-Since</a></h2>
      <p id="rfc.section.14.28.p.1">The If-Unmodified-Since request-header field is used with a method to make it conditional. If the requested resource has not
         been modified since the time specified in this field, the server <em class="bcp14">SHOULD</em> perform the requested operation as if the If-Unmodified-Since header were not present.
      </p>
      <p id="rfc.section.14.28.p.2">If the requested variant has been modified since the specified time, the server <em class="bcp14">MUST NOT</em> perform the requested operation, and <em class="bcp14">MUST</em> return a 412 (Precondition Failed).
      </p>
      <div id="rfc.figure.u.119"></div><pre class="inline"><span id="rfc.iref.g.142"></span>   If-Unmodified-Since = "If-Unmodified-Since" ":" HTTP-date
</pre><p id="rfc.section.14.28.p.4">An example of the field is:</p>
      <div id="rfc.figure.u.120"></div><pre class="text">    If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</pre><p id="rfc.section.14.28.p.6">If the request normally (i.e., without the If-Unmodified-Since header) would result in anything other than a 2xx or 412 status,
         the If-Unmodified-Since header <em class="bcp14">SHOULD</em> be ignored.
      </p>
      <p id="rfc.section.14.28.p.7">If the specified date is invalid, the header is ignored.</p>
      <p id="rfc.section.14.28.p.8">The result of a request having both an If-Unmodified-Since header field and either an If-None-Match or an If-Modified-Since
         header fields is undefined by this specification.
      </p>
      <div id="rfc.iref.l.1"></div>
      <div id="rfc.iref.h.32"></div>
      <h2 id="rfc.section.14.29"><a href="#rfc.section.14.29">14.29</a>&nbsp;<a id="header.last-modified" href="#header.last-modified">Last-Modified</a></h2>
      <p id="rfc.section.14.29.p.1">The Last-Modified entity-header field indicates the date and time at which the origin server believes the variant was last
         modified.
      </p>
      <div id="rfc.figure.u.121"></div><pre class="inline"><span id="rfc.iref.g.143"></span>    Last-Modified  = "Last-Modified" ":" HTTP-date
</pre><p id="rfc.section.14.29.p.3">An example of its use is</p>
      <div id="rfc.figure.u.122"></div><pre class="text">    Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
</pre><p id="rfc.section.14.29.p.5">The exact meaning of this header field depends on the implementation of the origin server and the nature of the original resource.
         For files, it may be just the file system last-modified time. For entities with dynamically included parts, it may be the
         most recent of the set of last-modify times for its component parts. For database gateways, it may be the last-update time
         stamp of the record. For virtual objects, it may be the last time the internal state changed.
      </p>
      <p id="rfc.section.14.29.p.6">An origin server <em class="bcp14">MUST NOT</em> send a Last-Modified date which is later than the server's time of message origination. In such cases, where the resource's
         last modification would indicate some time in the future, the server <em class="bcp14">MUST</em> replace that date with the message origination date.
      </p>
      <p id="rfc.section.14.29.p.7">An origin server <em class="bcp14">SHOULD</em> obtain the Last-Modified value of the entity as close as possible to the time that it generates the Date value of its response.
         This allows a recipient to make an accurate assessment of the entity's modification time, especially if the entity changes
         near the time that the response is generated.
      </p>
      <p id="rfc.section.14.29.p.8">HTTP/1.1 servers <em class="bcp14">SHOULD</em> send Last-Modified whenever feasible.
      </p>
      <div id="rfc.iref.l.2"></div>
      <div id="rfc.iref.h.33"></div>
      <h2 id="rfc.section.14.30"><a href="#rfc.section.14.30">14.30</a>&nbsp;<a id="header.location" href="#header.location">Location</a></h2>
      <p id="rfc.section.14.30.p.1">The Location response-header field is used to redirect the recipient to a location other than the Request-URI for completion
         of the request or identification of a new resource. For 201 (Created) responses, the Location is that of the new resource
         which was created by the request. For 3xx responses, the location <em class="bcp14">SHOULD</em> indicate the server's preferred URI for automatic redirection to the resource. The field value consists of a single absolute
         URI.
      </p>
      <div id="rfc.figure.u.123"></div><pre class="inline"><span id="rfc.iref.g.144"></span>    Location       = "Location" ":" absoluteURI
</pre><p id="rfc.section.14.30.p.3">An example is:</p>
      <div id="rfc.figure.u.124"></div><pre class="text">    Location: http://www.w3.org/pub/WWW/People.html
</pre><p id="rfc.section.14.30.p.5"> </p>
      <dl class="empty">
         <dd> <b>Note:</b> The Content-Location header field (<a href="#header.content-location" id="rfc.xref.header.content-location.2" title="Content-Location">Section&nbsp;14.14</a>) differs from Location in that the Content-Location identifies the original location of the entity enclosed in the request.
            It is therefore possible for a response to contain header fields for both Location and Content-Location. Also see <a href="#invalidation.after.updates.or.deletions" title="Invalidation After Updates or Deletions">Section&nbsp;13.10</a> for cache requirements of some methods.
         </dd>
      </dl>
      <div id="rfc.iref.m.15"></div>
      <div id="rfc.iref.h.34"></div>
      <h2 id="rfc.section.14.31"><a href="#rfc.section.14.31">14.31</a>&nbsp;<a id="header.max-forwards" href="#header.max-forwards">Max-Forwards</a></h2>
      <p id="rfc.section.14.31.p.1">The Max-Forwards request-header field provides a mechanism with the TRACE (<a href="#TRACE" id="rfc.xref.TRACE.2" title="TRACE">Section&nbsp;9.8</a>) and OPTIONS (<a href="#OPTIONS" id="rfc.xref.OPTIONS.2" title="OPTIONS">Section&nbsp;9.2</a>) methods to limit the number of proxies or gateways that can forward the request to the next inbound server. This can be
         useful when the client is attempting to trace a request chain which appears to be failing or looping in mid-chain.
      </p>
      <div id="rfc.figure.u.125"></div><pre class="inline"><span id="rfc.iref.g.145"></span>    Max-Forwards   = "Max-Forwards" ":" 1*DIGIT
</pre><p id="rfc.section.14.31.p.3">The Max-Forwards value is a decimal integer indicating the remaining number of times this request message may be forwarded.</p>
      <p id="rfc.section.14.31.p.4">Each proxy or gateway recipient of a TRACE or OPTIONS request containing a Max-Forwards header field <em class="bcp14">MUST</em> check and update its value prior to forwarding the request. If the received value is zero (0), the recipient <em class="bcp14">MUST NOT</em> forward the request; instead, it <em class="bcp14">MUST</em> respond as the final recipient. If the received Max-Forwards value is greater than zero, then the forwarded message <em class="bcp14">MUST</em> contain an updated Max-Forwards field with a value decremented by one (1).
      </p>
      <p id="rfc.section.14.31.p.5">The Max-Forwards header field <em class="bcp14">MAY</em> be ignored for all other methods defined by this specification and for any extension methods for which it is not explicitly
         referred to as part of that method definition.
      </p>
      <div id="rfc.iref.p.7"></div>
      <div id="rfc.iref.h.35"></div>
      <h2 id="rfc.section.14.32"><a href="#rfc.section.14.32">14.32</a>&nbsp;<a id="header.pragma" href="#header.pragma">Pragma</a></h2>
      <p id="rfc.section.14.32.p.1">The Pragma general-header field is used to include implementation-specific directives that might apply to any recipient along
         the request/response chain. All pragma directives specify optional behavior from the viewpoint of the protocol; however, some
         systems <em class="bcp14">MAY</em> require that behavior be consistent with the directives.
      </p>
      <div id="rfc.figure.u.126"></div><pre class="inline"><span id="rfc.iref.g.146"></span><span id="rfc.iref.g.147"></span><span id="rfc.iref.g.148"></span>    Pragma            = "Pragma" ":" 1#pragma-directive
    pragma-directive  = "no-cache" | extension-pragma
    extension-pragma  = token [ "=" ( token | quoted-string ) ]
</pre><p id="rfc.section.14.32.p.3">When the no-cache directive is present in a request message, an application <em class="bcp14">SHOULD</em> forward the request toward the origin server even if it has a cached copy of what is being requested. This pragma directive
         has the same semantics as the no-cache cache-directive (see <a href="#header.cache-control" id="rfc.xref.header.cache-control.11" title="Cache-Control">Section&nbsp;14.9</a>) and is defined here for backward compatibility with HTTP/1.0. Clients <em class="bcp14">SHOULD</em> include both header fields when a no-cache request is sent to a server not known to be HTTP/1.1 compliant.
      </p>
      <p id="rfc.section.14.32.p.4">Pragma directives <em class="bcp14">MUST</em> be passed through by a proxy or gateway application, regardless of their significance to that application, since the directives
         might be applicable to all recipients along the request/response chain. It is not possible to specify a pragma for a specific
         recipient; however, any pragma directive not relevant to a recipient <em class="bcp14">SHOULD</em> be ignored by that recipient.
      </p>
      <p id="rfc.section.14.32.p.5">HTTP/1.1 caches <em class="bcp14">SHOULD</em> treat "Pragma: no-cache" as if the client had sent "Cache-Control: no-cache". No new Pragma directives will be defined in
         HTTP. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> because the meaning of "Pragma: no-cache as a response header field is not actually specified, it does not provide a reliable
            replacement for "Cache-Control: no-cache" in a response
         </dd>
      </dl>
      <div id="rfc.iref.p.8"></div>
      <div id="rfc.iref.h.36"></div>
      <h2 id="rfc.section.14.33"><a href="#rfc.section.14.33">14.33</a>&nbsp;<a id="header.proxy-authenticate" href="#header.proxy-authenticate">Proxy-Authenticate</a></h2>
      <p id="rfc.section.14.33.p.1">The Proxy-Authenticate response-header field <em class="bcp14">MUST</em> be included as part of a 407 (Proxy Authentication Required) response. The field value consists of a challenge that indicates
         the authentication scheme and parameters applicable to the proxy for this Request-URI.
      </p>
      <div id="rfc.figure.u.127"></div><pre class="inline"><span id="rfc.iref.g.149"></span>    Proxy-Authenticate  = "Proxy-Authenticate" ":" 1#challenge
</pre><p id="rfc.section.14.33.p.3">The HTTP access authentication process is described in "HTTP Authentication: Basic and Digest Access Authentication" <a href="#RFC2617" id="rfc.xref.RFC2617.5"><cite title="HTTP Authentication: Basic and Digest Access Authentication">[RFC2617]</cite></a>. Unlike WWW-Authenticate, the Proxy-Authenticate header field applies only to the current connection and <em class="bcp14">SHOULD NOT</em> be passed on to downstream clients. However, an intermediate proxy might need to obtain its own credentials by requesting
         them from the downstream client, which in some circumstances will appear as if the proxy is forwarding the Proxy-Authenticate
         header field.
      </p>
      <div id="rfc.iref.p.9"></div>
      <div id="rfc.iref.h.37"></div>
      <h2 id="rfc.section.14.34"><a href="#rfc.section.14.34">14.34</a>&nbsp;<a id="header.proxy-authorization" href="#header.proxy-authorization">Proxy-Authorization</a></h2>
      <p id="rfc.section.14.34.p.1">The Proxy-Authorization request-header field allows the client to identify itself (or its user) to a proxy which requires
         authentication. The Proxy-Authorization field value consists of credentials containing the authentication information of the
         user agent for the proxy and/or realm of the resource being requested.
      </p>
      <div id="rfc.figure.u.128"></div><pre class="inline"><span id="rfc.iref.g.150"></span>    Proxy-Authorization     = "Proxy-Authorization" ":" credentials
</pre><p id="rfc.section.14.34.p.3">The HTTP access authentication process is described in "HTTP Authentication: Basic and Digest Access Authentication" <a href="#RFC2617" id="rfc.xref.RFC2617.6"><cite title="HTTP Authentication: Basic and Digest Access Authentication">[RFC2617]</cite></a>. Unlike Authorization, the Proxy-Authorization header field applies only to the next outbound proxy that demanded authentication
         using the Proxy-Authenticate field. When multiple proxies are used in a chain, the Proxy-Authorization header field is consumed
         by the first outbound proxy that was expecting to receive credentials. A proxy <em class="bcp14">MAY</em> relay the credentials from the client request to the next proxy if that is the mechanism by which the proxies cooperatively
         authenticate a given request.
      </p>
      <div id="rfc.iref.r.5"></div>
      <div id="rfc.iref.h.38"></div>
      <h2 id="rfc.section.14.35"><a href="#rfc.section.14.35">14.35</a>&nbsp;<a id="header.range" href="#header.range">Range</a></h2>
      <h3 id="rfc.section.14.35.1"><a href="#rfc.section.14.35.1">14.35.1</a>&nbsp;<a id="byte.ranges" href="#byte.ranges">Byte Ranges</a></h3>
      <p id="rfc.section.14.35.1.p.1">Since all HTTP entities are represented in HTTP messages as sequences of bytes, the concept of a byte range is meaningful
         for any HTTP entity. (However, not all clients and servers need to support byte-range operations.)
      </p>
      <p id="rfc.section.14.35.1.p.2">Byte range specifications in HTTP apply to the sequence of bytes in the entity-body (not necessarily the same as the message-body).</p>
      <p id="rfc.section.14.35.1.p.3">A byte range operation <em class="bcp14">MAY</em> specify a single range of bytes, or a set of ranges within a single entity.
      </p>
      <div id="rfc.figure.u.129"></div><pre class="inline"><span id="rfc.iref.g.151"></span><span id="rfc.iref.g.152"></span><span id="rfc.iref.g.153"></span><span id="rfc.iref.g.154"></span><span id="rfc.iref.g.155"></span><span id="rfc.iref.g.156"></span>    ranges-specifier = byte-ranges-specifier
    byte-ranges-specifier = bytes-unit "=" byte-range-set
    byte-range-set  = 1#( byte-range-spec | suffix-byte-range-spec )
    byte-range-spec = first-byte-pos "-" [last-byte-pos]
    first-byte-pos  = 1*DIGIT
    last-byte-pos   = 1*DIGIT
</pre><p id="rfc.section.14.35.1.p.5">The first-byte-pos value in a byte-range-spec gives the byte-offset of the first byte in a range. The last-byte-pos value
         gives the byte-offset of the last byte in the range; that is, the byte positions specified are inclusive. Byte offsets start
         at zero.
      </p>
      <p id="rfc.section.14.35.1.p.6">If the last-byte-pos value is present, it <em class="bcp14">MUST</em> be greater than or equal to the first-byte-pos in that byte-range-spec, or the byte-range-spec is syntactically invalid. The
         recipient of a byte-range-set that includes one or more syntactically invalid byte-range-spec values <em class="bcp14">MUST</em> ignore the header field that includes that byte-range-set.
      </p>
      <p id="rfc.section.14.35.1.p.7">If the last-byte-pos value is absent, or if the value is greater than or equal to the current length of the entity-body, last-byte-pos
         is taken to be equal to one less than the current length of the entity-body in bytes.
      </p>
      <p id="rfc.section.14.35.1.p.8">By its choice of last-byte-pos, a client can limit the number of bytes retrieved without knowing the size of the entity.</p>
      <div id="rfc.figure.u.130"></div><pre class="inline"><span id="rfc.iref.g.157"></span><span id="rfc.iref.g.158"></span>    suffix-byte-range-spec = "-" suffix-length
    suffix-length = 1*DIGIT
</pre><p id="rfc.section.14.35.1.p.10">A suffix-byte-range-spec is used to specify the suffix of the entity-body, of a length given by the suffix-length value. (That
         is, this form specifies the last N bytes of an entity-body.) If the entity is shorter than the specified suffix-length, the
         entire entity-body is used.
      </p>
      <p id="rfc.section.14.35.1.p.11">If a syntactically valid byte-range-set includes at least one byte-range-spec whose first-byte-pos is less than the current
         length of the entity-body, or at least one suffix-byte-range-spec with a non-zero suffix-length, then the byte-range-set is
         satisfiable. Otherwise, the byte-range-set is unsatisfiable. If the byte-range-set is unsatisfiable, the server <em class="bcp14">SHOULD</em> return a response with a status of 416 (Requested range not satisfiable). Otherwise, the server <em class="bcp14">SHOULD</em> return a response with a status of 206 (Partial Content) containing the satisfiable ranges of the entity-body.
      </p>
      <p id="rfc.section.14.35.1.p.12">Examples of byte-ranges-specifier values (assuming an entity-body of length 10000): </p>
      <ul>
         <li>The first 500 bytes (byte offsets 0-499, inclusive): bytes=0-499</li>
         <li>The second 500 bytes (byte offsets 500-999, inclusive): bytes=500-999</li>
         <li>The final 500 bytes (byte offsets 9500-9999, inclusive): bytes=-500</li>
         <li>Or bytes=9500-</li>
         <li>The first and last bytes only (bytes 0 and 9999): bytes=0-0,-1</li>
         <li>Several legal but not canonical specifications of the second 500 bytes (byte offsets 500-999, inclusive): <br> bytes=500-600,601-999<br> bytes=500-700,601-999
         </li>
      </ul>
      <h3 id="rfc.section.14.35.2"><a href="#rfc.section.14.35.2">14.35.2</a>&nbsp;<a id="range.retrieval.requests" href="#range.retrieval.requests">Range Retrieval Requests</a></h3>
      <p id="rfc.section.14.35.2.p.1">HTTP retrieval requests using conditional or unconditional GET methods <em class="bcp14">MAY</em> request one or more sub-ranges of the entity, instead of the entire entity, using the Range request header, which applies
         to the entity returned as the result of the request:
      </p>
      <div id="rfc.figure.u.131"></div><pre class="inline"><span id="rfc.iref.g.159"></span>   Range = "Range" ":" ranges-specifier
</pre><p id="rfc.section.14.35.2.p.3">A server <em class="bcp14">MAY</em> ignore the Range header. However, HTTP/1.1 origin servers and intermediate caches ought to support byte ranges when possible,
         since Range supports efficient recovery from partially failed transfers, and supports efficient partial retrieval of large
         entities.
      </p>
      <p id="rfc.section.14.35.2.p.4">If the server supports the Range header and the specified range or ranges are appropriate for the entity: </p>
      <ul>
         <li>The presence of a Range header in an unconditional GET modifies what is returned if the GET is otherwise successful. In other
            words, the response carries a status code of 206 (Partial Content) instead of 200 (OK).
         </li>
         <li>The presence of a Range header in a conditional GET (a request using one or both of If-Modified-Since and If-None-Match, or
            one or both of If-Unmodified-Since and If-Match) modifies what is returned if the GET is otherwise successful and the condition
            is true. It does not affect the 304 (Not Modified) response returned if the conditional is false.
         </li>
      </ul>
      <p id="rfc.section.14.35.2.p.5">In some cases, it might be more appropriate to use the If-Range header (see <a href="#header.if-range" id="rfc.xref.header.if-range.4" title="If-Range">Section&nbsp;14.27</a>) in addition to the Range header.
      </p>
      <p id="rfc.section.14.35.2.p.6">If a proxy that supports ranges receives a Range request, forwards the request to an inbound server, and receives an entire
         entity in reply, it <em class="bcp14">SHOULD</em> only return the requested range to its client. It <em class="bcp14">SHOULD</em> store the entire received response in its cache if that is consistent with its cache allocation policies.
      </p>
      <div id="rfc.iref.r.6"></div>
      <div id="rfc.iref.h.39"></div>
      <h2 id="rfc.section.14.36"><a href="#rfc.section.14.36">14.36</a>&nbsp;<a id="header.referer" href="#header.referer">Referer</a></h2>
      <p id="rfc.section.14.36.p.1">The Referer[sic] request-header field allows the client to specify, for the server's benefit, the address (URI) of the resource
         from which the Request-URI was obtained (the "referrer", although the header field is misspelled.) The Referer request-header
         allows a server to generate lists of back-links to resources for interest, logging, optimized caching, etc. It also allows
         obsolete or mistyped links to be traced for maintenance. The Referer field <em class="bcp14">MUST NOT</em> be sent if the Request-URI was obtained from a source that does not have its own URI, such as input from the user keyboard.
      </p>
      <div id="rfc.figure.u.132"></div><pre class="inline"><span id="rfc.iref.g.160"></span>    Referer        = "Referer" ":" ( absoluteURI | relativeURI )
</pre><p id="rfc.section.14.36.p.3">Example:</p>
      <div id="rfc.figure.u.133"></div><pre class="text">    Referer: http://www.w3.org/hypertext/DataSources/Overview.html
</pre><p id="rfc.section.14.36.p.5">If the field value is a relative URI, it <em class="bcp14">SHOULD</em> be interpreted relative to the Request-URI. The URI <em class="bcp14">MUST NOT</em> include a fragment. See <a href="#encoding.sensitive.information.in.uris" title="Encoding Sensitive Information in URI's">Section&nbsp;15.1.3</a> for security considerations.
      </p>
      <div id="rfc.iref.r.7"></div>
      <div id="rfc.iref.h.40"></div>
      <h2 id="rfc.section.14.37"><a href="#rfc.section.14.37">14.37</a>&nbsp;<a id="header.retry-after" href="#header.retry-after">Retry-After</a></h2>
      <p id="rfc.section.14.37.p.1">The Retry-After response-header field can be used with a 503 (Service Unavailable) response to indicate how long the service
         is expected to be unavailable to the requesting client. This field <em class="bcp14">MAY</em> also be used with any 3xx (Redirection) response to indicate the minimum time the user-agent is asked wait before issuing
         the redirected request. The value of this field can be either an HTTP-date or an integer number of seconds (in decimal) after
         the time of the response.
      </p>
      <div id="rfc.figure.u.134"></div><pre class="inline"><span id="rfc.iref.g.161"></span>    Retry-After  = "Retry-After" ":" ( HTTP-date | delta-seconds )
</pre><p id="rfc.section.14.37.p.3">Two examples of its use are</p>
      <div id="rfc.figure.u.135"></div><pre class="text">    Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
    Retry-After: 120
</pre><p id="rfc.section.14.37.p.5">In the latter example, the delay is 2 minutes.</p>
      <div id="rfc.iref.s.46"></div>
      <div id="rfc.iref.h.41"></div>
      <h2 id="rfc.section.14.38"><a href="#rfc.section.14.38">14.38</a>&nbsp;<a id="header.server" href="#header.server">Server</a></h2>
      <p id="rfc.section.14.38.p.1">The Server response-header field contains information about the software used by the origin server to handle the request.
         The field can contain multiple product tokens (<a href="#product.tokens" title="Product Tokens">Section&nbsp;3.8</a>) and comments identifying the server and any significant subproducts. The product tokens are listed in order of their significance
         for identifying the application.
      </p>
      <div id="rfc.figure.u.136"></div><pre class="inline"><span id="rfc.iref.g.162"></span>    Server         = "Server" ":" 1*( product | comment )
</pre><p id="rfc.section.14.38.p.3">Example:</p>
      <div id="rfc.figure.u.137"></div><pre class="text">    Server: CERN/3.0 libwww/2.17
</pre><p id="rfc.section.14.38.p.5">If the response is being forwarded through a proxy, the proxy application <em class="bcp14">MUST NOT</em> modify the Server response-header. Instead, it <em class="bcp14">SHOULD</em> include a Via field (as described in <a href="#header.via" id="rfc.xref.header.via.3" title="Via">Section&nbsp;14.45</a>). 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> Revealing the specific software version of the server might allow the server machine to become more vulnerable to attacks
            against software that is known to contain security holes. Server implementors are encouraged to make this field a configurable
            option.
         </dd>
      </dl>
      <div id="rfc.iref.t.3"></div>
      <div id="rfc.iref.h.42"></div>
      <h2 id="rfc.section.14.39"><a href="#rfc.section.14.39">14.39</a>&nbsp;<a id="header.te" href="#header.te">TE</a></h2>
      <p id="rfc.section.14.39.p.1">The TE request-header field indicates what extension transfer-codings it is willing to accept in the response and whether
         or not it is willing to accept trailer fields in a chunked transfer-coding. Its value may consist of the keyword "trailers"
         and/or a comma-separated list of extension transfer-coding names with optional accept parameters (as described in <a href="#transfer.codings" title="Transfer Codings">Section&nbsp;3.6</a>).
      </p>
      <div id="rfc.figure.u.138"></div><pre class="inline"><span id="rfc.iref.g.163"></span><span id="rfc.iref.g.164"></span>    TE        = "TE" ":" #( t-codings )
    t-codings = "trailers" | ( transfer-extension [ accept-params ] )
</pre><p id="rfc.section.14.39.p.3">The presence of the keyword "trailers" indicates that the client is willing to accept trailer fields in a chunked transfer-coding,
         as defined in <a href="#chunked.transfer.encoding" title="Chunked Transfer Coding">Section&nbsp;3.6.1</a>. This keyword is reserved for use with transfer-coding values even though it does not itself represent a transfer-coding.
      </p>
      <p id="rfc.section.14.39.p.4">Examples of its use are:</p>
      <div id="rfc.figure.u.139"></div><pre class="text">    TE: deflate
    TE:
    TE: trailers, deflate;q=0.5
</pre><p id="rfc.section.14.39.p.6">The TE header field only applies to the immediate connection. Therefore, the keyword <em class="bcp14">MUST</em> be supplied within a Connection header field (<a href="#header.connection" id="rfc.xref.header.connection.5" title="Connection">Section&nbsp;14.10</a>) whenever TE is present in an HTTP/1.1 message.
      </p>
      <p id="rfc.section.14.39.p.7">A server tests whether a transfer-coding is acceptable, according to a TE field, using these rules: </p>
      <ol>
         <li>
            <p>The "chunked" transfer-coding is always acceptable. If the keyword "trailers" is listed, the client indicates that it is willing
               to accept trailer fields in the chunked response on behalf of itself and any downstream clients. The implication is that,
               if given, the client is stating that either all downstream clients are willing to accept trailer fields in the forwarded response,
               or that it will attempt to buffer the response on behalf of downstream recipients.
            </p>
            <p> <b>Note:</b> HTTP/1.1 does not define any means to limit the size of a chunked response such that a client can be assured of buffering
               the entire response.
            </p>
         </li>
         <li>
            <p>If the transfer-coding being tested is one of the transfer-codings listed in the TE field, then it is acceptable unless it
               is accompanied by a qvalue of 0. (As defined in <a href="#quality.values" title="Quality Values">Section&nbsp;3.9</a>, a qvalue of 0 means "not acceptable.")
            </p>
         </li>
         <li>
            <p>If multiple transfer-codings are acceptable, then the acceptable transfer-coding with the highest non-zero qvalue is preferred.
               The "chunked" transfer-coding always has a qvalue of 1.
            </p>
         </li>
      </ol>
      <p id="rfc.section.14.39.p.8">If the TE field-value is empty or if no TE field is present, the only transfer-coding is "chunked". A message with no transfer-coding
         is always acceptable.
      </p>
      <div id="rfc.iref.t.4"></div>
      <div id="rfc.iref.h.43"></div>
      <h2 id="rfc.section.14.40"><a href="#rfc.section.14.40">14.40</a>&nbsp;<a id="header.trailer" href="#header.trailer">Trailer</a></h2>
      <p id="rfc.section.14.40.p.1">The Trailer general field value indicates that the given set of header fields is present in the trailer of a message encoded
         with chunked transfer-coding.
      </p>
      <div id="rfc.figure.u.140"></div><pre class="inline"><span id="rfc.iref.g.165"></span>    Trailer  = "Trailer" ":" 1#field-name
</pre><p id="rfc.section.14.40.p.3">An HTTP/1.1 message <em class="bcp14">SHOULD</em> include a Trailer header field in a message using chunked transfer-coding with a non-empty trailer. Doing so allows the recipient
         to know which header fields to expect in the trailer.
      </p>
      <p id="rfc.section.14.40.p.4">If no Trailer header field is present, the trailer <em class="bcp14">SHOULD NOT</em> include any header fields. See <a href="#chunked.transfer.encoding" title="Chunked Transfer Coding">Section&nbsp;3.6.1</a> for restrictions on the use of trailer fields in a "chunked" transfer-coding.
      </p>
      <p id="rfc.section.14.40.p.5">Message header fields listed in the Trailer header field <em class="bcp14">MUST NOT</em> include the following header fields: 
      </p>
      <ul>
         <li>Transfer-Encoding</li>
         <li>Content-Length</li>
         <li>Trailer</li>
      </ul>
      <div id="rfc.iref.t.5"></div>
      <div id="rfc.iref.h.44"></div>
      <h2 id="rfc.section.14.41"><a href="#rfc.section.14.41">14.41</a>&nbsp;<a id="header.transfer-encoding" href="#header.transfer-encoding">Transfer-Encoding</a></h2>
      <p id="rfc.section.14.41.p.1">The Transfer-Encoding general-header field indicates what (if any) type of transformation has been applied to the message
         body in order to safely transfer it between the sender and the recipient. This differs from the content-coding in that the
         transfer-coding is a property of the message, not of the entity.
      </p>
      <div id="rfc.figure.u.141"></div><pre class="inline"><span id="rfc.iref.g.166"></span>  Transfer-Encoding       = "Transfer-Encoding" ":" 1#transfer-coding
</pre><p id="rfc.section.14.41.p.3">Transfer-codings are defined in <a href="#transfer.codings" title="Transfer Codings">Section&nbsp;3.6</a>. An example is:
      </p>
      <div id="rfc.figure.u.142"></div><pre class="text">  Transfer-Encoding: chunked
</pre><p id="rfc.section.14.41.p.5">If multiple encodings have been applied to an entity, the transfer-codings <em class="bcp14">MUST</em> be listed in the order in which they were applied. Additional information about the encoding parameters <em class="bcp14">MAY</em> be provided by other entity-header fields not defined by this specification.
      </p>
      <p id="rfc.section.14.41.p.6">Many older HTTP/1.0 applications do not understand the Transfer-Encoding header.</p>
      <div id="rfc.iref.u.3"></div>
      <div id="rfc.iref.h.45"></div>
      <h2 id="rfc.section.14.42"><a href="#rfc.section.14.42">14.42</a>&nbsp;<a id="header.upgrade" href="#header.upgrade">Upgrade</a></h2>
      <p id="rfc.section.14.42.p.1">The Upgrade general-header allows the client to specify what additional communication protocols it supports and would like
         to use if the server finds it appropriate to switch protocols. The server <em class="bcp14">MUST</em> use the Upgrade header field within a 101 (Switching Protocols) response to indicate which protocol(s) are being switched.
      </p>
      <div id="rfc.figure.u.143"></div><pre class="inline"><span id="rfc.iref.g.167"></span>    Upgrade        = "Upgrade" ":" 1#product
</pre><p id="rfc.section.14.42.p.3">For example,</p>
      <div id="rfc.figure.u.144"></div><pre class="text">    Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11
</pre><p id="rfc.section.14.42.p.5">The Upgrade header field is intended to provide a simple mechanism for transition from HTTP/1.1 to some other, incompatible
         protocol. It does so by allowing the client to advertise its desire to use another protocol, such as a later version of HTTP
         with a higher major version number, even though the current request has been made using HTTP/1.1. This eases the difficult
         transition between incompatible protocols by allowing the client to initiate a request in the more commonly supported protocol
         while indicating to the server that it would like to use a "better" protocol if available (where "better" is determined by
         the server, possibly according to the nature of the method and/or resource being requested).
      </p>
      <p id="rfc.section.14.42.p.6">The Upgrade header field only applies to switching application-layer protocols upon the existing transport-layer connection.
         Upgrade cannot be used to insist on a protocol change; its acceptance and use by the server is optional. The capabilities
         and nature of the application-layer communication after the protocol change is entirely dependent upon the new protocol chosen,
         although the first action after changing the protocol <em class="bcp14">MUST</em> be a response to the initial HTTP request containing the Upgrade header field.
      </p>
      <p id="rfc.section.14.42.p.7">The Upgrade header field only applies to the immediate connection. Therefore, the upgrade keyword <em class="bcp14">MUST</em> be supplied within a Connection header field (<a href="#header.connection" id="rfc.xref.header.connection.6" title="Connection">Section&nbsp;14.10</a>) whenever Upgrade is present in an HTTP/1.1 message.
      </p>
      <p id="rfc.section.14.42.p.8">The Upgrade header field cannot be used to indicate a switch to a protocol on a different connection. For that purpose, it
         is more appropriate to use a 301, 302, 303, or 305 redirection response.
      </p>
      <p id="rfc.section.14.42.p.9">This specification only defines the protocol name "HTTP" for use by the family of Hypertext Transfer Protocols, as defined
         by the HTTP version rules of <a href="#http.version" title="HTTP Version">Section&nbsp;3.1</a> and future updates to this specification. Any token can be used as a protocol name; however, it will only be useful if both
         the client and server associate the name with the same protocol.
      </p>
      <div id="rfc.iref.u.4"></div>
      <div id="rfc.iref.h.46"></div>
      <h2 id="rfc.section.14.43"><a href="#rfc.section.14.43">14.43</a>&nbsp;<a id="header.user-agent" href="#header.user-agent">User-Agent</a></h2>
      <p id="rfc.section.14.43.p.1">The User-Agent request-header field contains information about the user agent originating the request. This is for statistical
         purposes, the tracing of protocol violations, and automated recognition of user agents for the sake of tailoring responses
         to avoid particular user agent limitations. User agents <em class="bcp14">SHOULD</em> include this field with requests. The field can contain multiple product tokens (<a href="#product.tokens" title="Product Tokens">Section&nbsp;3.8</a>) and comments identifying the agent and any subproducts which form a significant part of the user agent. By convention, the
         product tokens are listed in order of their significance for identifying the application.
      </p>
      <div id="rfc.figure.u.145"></div><pre class="inline"><span id="rfc.iref.g.168"></span>    User-Agent     = "User-Agent" ":" 1*( product | comment )
</pre><p id="rfc.section.14.43.p.3">Example:</p>
      <div id="rfc.figure.u.146"></div><pre class="text">    User-Agent: CERN-LineMode/2.15 libwww/2.17b3
</pre><div id="rfc.iref.v.3"></div>
      <div id="rfc.iref.h.47"></div>
      <h2 id="rfc.section.14.44"><a href="#rfc.section.14.44">14.44</a>&nbsp;<a id="header.vary" href="#header.vary">Vary</a></h2>
      <p id="rfc.section.14.44.p.1">The Vary field value indicates the set of request-header fields that fully determines, while the response is fresh, whether
         a cache is permitted to use the response to reply to a subsequent request without revalidation. For uncacheable or stale responses,
         the Vary field value advises the user agent about the criteria that were used to select the representation. A Vary field value
         of "*" implies that a cache cannot determine from the request headers of a subsequent request whether this response is the
         appropriate representation. See <a href="#caching.negotiated.responses" title="Caching Negotiated Responses">Section&nbsp;13.6</a> for use of the Vary header field by caches.
      </p>
      <div id="rfc.figure.u.147"></div><pre class="inline"><span id="rfc.iref.g.169"></span>    Vary  = "Vary" ":" ( "*" | 1#field-name )
</pre><p id="rfc.section.14.44.p.3">An HTTP/1.1 server <em class="bcp14">SHOULD</em> include a Vary header field with any cacheable response that is subject to server-driven negotiation. Doing so allows a cache
         to properly interpret future requests on that resource and informs the user agent about the presence of negotiation on that
         resource. A server <em class="bcp14">MAY</em> include a Vary header field with a non-cacheable response that is subject to server-driven negotiation, since this might provide
         the user agent with useful information about the dimensions over which the response varies at the time of the response.
      </p>
      <p id="rfc.section.14.44.p.4">A Vary field value consisting of a list of field-names signals that the representation selected for the response is based
         on a selection algorithm which considers ONLY the listed request-header field values in selecting the most appropriate representation.
         A cache <em class="bcp14">MAY</em> assume that the same selection will be made for future requests with the same values for the listed field names, for the duration
         of time for which the response is fresh.
      </p>
      <p id="rfc.section.14.44.p.5">The field-names given are not limited to the set of standard request-header fields defined by this specification. Field names
         are case-insensitive.
      </p>
      <p id="rfc.section.14.44.p.6">A Vary field value of "*" signals that unspecified parameters not limited to the request-headers (e.g., the network address
         of the client), play a role in the selection of the response representation. The "*" value <em class="bcp14">MUST NOT</em> be generated by a proxy server; it may only be generated by an origin server.
      </p>
      <div id="rfc.iref.v.4"></div>
      <div id="rfc.iref.h.48"></div>
      <h2 id="rfc.section.14.45"><a href="#rfc.section.14.45">14.45</a>&nbsp;<a id="header.via" href="#header.via">Via</a></h2>
      <p id="rfc.section.14.45.p.1">The Via general-header field <em class="bcp14">MUST</em> be used by gateways and proxies to indicate the intermediate protocols and recipients between the user agent and the server
         on requests, and between the origin server and the client on responses. It is analogous to the "Received" field of RFC 822 <a href="#RFC822" id="rfc.xref.RFC822.8"><cite title="Standard for the format of ARPA Internet text messages">[RFC822]</cite></a> and is intended to be used for tracking message forwards, avoiding request loops, and identifying the protocol capabilities
         of all senders along the request/response chain.
      </p>
      <div id="rfc.figure.u.148"></div><pre class="inline"><span id="rfc.iref.g.170"></span><span id="rfc.iref.g.171"></span><span id="rfc.iref.g.172"></span><span id="rfc.iref.g.173"></span><span id="rfc.iref.g.174"></span><span id="rfc.iref.g.175"></span>   Via =  "Via" ":" 1#( received-protocol received-by [ comment ] )
   received-protocol = [ protocol-name "/" ] protocol-version
   protocol-name     = token
   protocol-version  = token
   received-by       = ( host [ ":" port ] ) | pseudonym
   pseudonym         = token
</pre><p id="rfc.section.14.45.p.3">The received-protocol indicates the protocol version of the message received by the server or client along each segment of
         the request/response chain. The received-protocol version is appended to the Via field value when the message is forwarded
         so that information about the protocol capabilities of upstream applications remains visible to all recipients.
      </p>
      <p id="rfc.section.14.45.p.4">The protocol-name is optional if and only if it would be "HTTP". The received-by field is normally the host and optional port
         number of a recipient server or client that subsequently forwarded the message. However, if the real host is considered to
         be sensitive information, it <em class="bcp14">MAY</em> be replaced by a pseudonym. If the port is not given, it <em class="bcp14">MAY</em> be assumed to be the default port of the received-protocol.
      </p>
      <p id="rfc.section.14.45.p.5">Multiple Via field values represents each proxy or gateway that has forwarded the message. Each recipient <em class="bcp14">MUST</em> append its information such that the end result is ordered according to the sequence of forwarding applications.
      </p>
      <p id="rfc.section.14.45.p.6">Comments <em class="bcp14">MAY</em> be used in the Via header field to identify the software of the recipient proxy or gateway, analogous to the User-Agent and
         Server header fields. However, all comments in the Via field are optional and <em class="bcp14">MAY</em> be removed by any recipient prior to forwarding the message.
      </p>
      <p id="rfc.section.14.45.p.7">For example, a request message could be sent from an HTTP/1.0 user agent to an internal proxy code-named "fred", which uses
         HTTP/1.1 to forward the request to a public proxy at nowhere.com, which completes the request by forwarding it to the origin
         server at www.ics.uci.edu. The request received by www.ics.uci.edu would then have the following Via header field:
      </p>
      <div id="rfc.figure.u.149"></div><pre class="text">    Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)
</pre><p id="rfc.section.14.45.p.9">Proxies and gateways used as a portal through a network firewall <em class="bcp14">SHOULD NOT</em>, by default, forward the names and ports of hosts within the firewall region. This information <em class="bcp14">SHOULD</em> only be propagated if explicitly enabled. If not enabled, the received-by host of any host behind the firewall <em class="bcp14">SHOULD</em> be replaced by an appropriate pseudonym for that host.
      </p>
      <p id="rfc.section.14.45.p.10">For organizations that have strong privacy requirements for hiding internal structures, a proxy <em class="bcp14">MAY</em> combine an ordered subsequence of Via header field entries with identical received-protocol values into a single such entry.
         For example,
      </p>
      <div id="rfc.figure.u.150"></div><pre class="text">    Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy
</pre><p id="rfc.section.14.45.p.12">could be collapsed to</p>
      <div id="rfc.figure.u.151"></div><pre class="text">    Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
</pre><p id="rfc.section.14.45.p.14">Applications <em class="bcp14">SHOULD NOT</em> combine multiple entries unless they are all under the same organizational control and the hosts have already been replaced
         by pseudonyms. Applications <em class="bcp14">MUST NOT</em> combine entries which have different received-protocol values.
      </p>
      <div id="rfc.iref.w.1"></div>
      <div id="rfc.iref.h.49"></div>
      <h2 id="rfc.section.14.46"><a href="#rfc.section.14.46">14.46</a>&nbsp;<a id="header.warning" href="#header.warning">Warning</a></h2>
      <p id="rfc.section.14.46.p.1">The Warning general-header field is used to carry additional information about the status or transformation of a message which
         might not be reflected in the message. This information is typically used to warn about a possible lack of semantic transparency
         from caching operations or transformations applied to the entity body of the message.
      </p>
      <p id="rfc.section.14.46.p.2">Warning headers are sent with responses using:</p>
      <div id="rfc.figure.u.152"></div><pre class="inline"><span id="rfc.iref.g.176"></span><span id="rfc.iref.g.177"></span><span id="rfc.iref.g.178"></span><span id="rfc.iref.g.179"></span><span id="rfc.iref.g.180"></span><span id="rfc.iref.g.181"></span>    Warning    = "Warning" ":" 1#warning-value

    warning-value = warn-code SP warn-agent SP warn-text
                                          [SP warn-date]

    warn-code  = 3DIGIT
    warn-agent = ( host [ ":" port ] ) | pseudonym
                    ; the name or pseudonym of the server adding
                    ; the Warning header, for use in debugging
    warn-text  = quoted-string
    warn-date  = &lt;"&gt; HTTP-date &lt;"&gt;
</pre><p id="rfc.section.14.46.p.4">A response <em class="bcp14">MAY</em> carry more than one Warning header.
      </p>
      <p id="rfc.section.14.46.p.5">The warn-text <em class="bcp14">SHOULD</em> be in a natural language and character set that is most likely to be intelligible to the human user receiving the response.
         This decision <em class="bcp14">MAY</em> be based on any available knowledge, such as the location of the cache or user, the Accept-Language field in a request, the
         Content-Language field in a response, etc. The default language is English and the default character set is ISO-8859-1.
      </p>
      <p id="rfc.section.14.46.p.6">If a character set other than ISO-8859-1 is used, it <em class="bcp14">MUST</em> be encoded in the warn-text using the method described in RFC 2047 <a href="#RFC2047" id="rfc.xref.RFC2047.2"><cite title="MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Text">[RFC2047]</cite></a>.
      </p>
      <p id="rfc.section.14.46.p.7">Warning headers can in general be applied to any message, however some specific warn-codes are specific to caches and can
         only be applied to response messages. New Warning headers <em class="bcp14">SHOULD</em> be added after any existing Warning headers. A cache <em class="bcp14">MUST NOT</em> delete any Warning header that it received with a message. However, if a cache successfully validates a cache entry, it <em class="bcp14">SHOULD</em> remove any Warning headers previously attached to that entry except as specified for specific Warning codes. It <em class="bcp14">MUST</em> then add any Warning headers received in the validating response. In other words, Warning headers are those that would be
         attached to the most recent relevant response.
      </p>
      <p id="rfc.section.14.46.p.8">When multiple Warning headers are attached to a response, the user agent ought to inform the user of as many of them as possible,
         in the order that they appear in the response. If it is not possible to inform the user of all of the warnings, the user agent <em class="bcp14">SHOULD</em> follow these heuristics: 
      </p>
      <ul>
         <li>Warnings that appear early in the response take priority over those appearing later in the response.</li>
         <li>Warnings in the user's preferred character set take priority over warnings in other character sets but with identical warn-codes
            and warn-agents.
         </li>
      </ul>
      <p id="rfc.section.14.46.p.9">Systems that generate multiple Warning headers <em class="bcp14">SHOULD</em> order them with this user agent behavior in mind.
      </p>
      <p id="rfc.section.14.46.p.10">Requirements for the behavior of caches with respect to Warnings are stated in <a href="#warnings" title="Warnings">Section&nbsp;13.1.2</a>.
      </p>
      <p id="rfc.section.14.46.p.11">This is a list of the currently-defined warn-codes, each with a recommended warn-text in English, and a description of its
         meaning.
      </p>
      <p id="rfc.section.14.46.p.12">110 Response is stale </p>
      <dl class="empty">
         <dd> <em class="bcp14">MUST</em> be included whenever the returned response is stale.
         </dd>
      </dl>
      <p id="rfc.section.14.46.p.13">111 Revalidation failed </p>
      <dl class="empty">
         <dd> <em class="bcp14">MUST</em> be included if a cache returns a stale response because an attempt to revalidate the response failed, due to an inability
            to reach the server.
         </dd>
      </dl>
      <p id="rfc.section.14.46.p.14">112 Disconnected operation </p>
      <dl class="empty">
         <dd> <em class="bcp14">SHOULD</em> be included if the cache is intentionally disconnected from the rest of the network for a period of time.
         </dd>
      </dl>
      <p id="rfc.section.14.46.p.15">113 Heuristic expiration </p>
      <dl class="empty">
         <dd> <em class="bcp14">MUST</em> be included if the cache heuristically chose a freshness lifetime greater than 24 hours and the response's age is greater
            than 24 hours.
         </dd>
      </dl>
      <p id="rfc.section.14.46.p.16">199 Miscellaneous warning </p>
      <dl class="empty">
         <dd>The warning text <em class="bcp14">MAY</em> include arbitrary information to be presented to a human user, or logged. A system receiving this warning <em class="bcp14">MUST NOT</em> take any automated action, besides presenting the warning to the user.
         </dd>
      </dl>
      <p id="rfc.section.14.46.p.17">214 Transformation applied </p>
      <dl class="empty">
         <dd> <em class="bcp14">MUST</em> be added by an intermediate cache or proxy if it applies any transformation changing the content-coding (as specified in the
            Content-Encoding header) or media-type (as specified in the Content-Type header) of the response, or the entity-body of the
            response, unless this Warning code already appears in the response.
         </dd>
      </dl>
      <p id="rfc.section.14.46.p.18">299 Miscellaneous persistent warning </p>
      <dl class="empty">
         <dd>The warning text <em class="bcp14">MAY</em> include arbitrary information to be presented to a human user, or logged. A system receiving this warning <em class="bcp14">MUST NOT</em> take any automated action.
         </dd>
      </dl>
      <p id="rfc.section.14.46.p.19">If an implementation sends a message with one or more Warning headers whose version is HTTP/1.0 or lower, then the sender <em class="bcp14">MUST</em> include in each warning-value a warn-date that matches the date in the response.
      </p>
      <p id="rfc.section.14.46.p.20">If an implementation receives a message with a warning-value that includes a warn-date, and that warn-date is different from
         the Date value in the response, then that warning-value <em class="bcp14">MUST</em> be deleted from the message before storing, forwarding, or using it. (This prevents bad consequences of naive caching of Warning
         header fields.) If all of the warning-values are deleted for this reason, the Warning header <em class="bcp14">MUST</em> be deleted as well.
      </p>
      <div id="rfc.iref.w.2"></div>
      <div id="rfc.iref.h.50"></div>
      <h2 id="rfc.section.14.47"><a href="#rfc.section.14.47">14.47</a>&nbsp;<a id="header.www-authenticate" href="#header.www-authenticate">WWW-Authenticate</a></h2>
      <p id="rfc.section.14.47.p.1">The WWW-Authenticate response-header field <em class="bcp14">MUST</em> be included in 401 (Unauthorized) response messages. The field value consists of at least one challenge that indicates the
         authentication scheme(s) and parameters applicable to the Request-URI.
      </p>
      <div id="rfc.figure.u.153"></div><pre class="inline"><span id="rfc.iref.g.182"></span>    WWW-Authenticate  = "WWW-Authenticate" ":" 1#challenge
</pre><p id="rfc.section.14.47.p.3">The HTTP access authentication process is described in "HTTP Authentication: Basic and Digest Access Authentication" <a href="#RFC2617" id="rfc.xref.RFC2617.7"><cite title="HTTP Authentication: Basic and Digest Access Authentication">[RFC2617]</cite></a>. User agents are advised to take special care in parsing the WWW-Authenticate field value as it might contain more than one
         challenge, or if more than one WWW-Authenticate header field is provided, the contents of a challenge itself can contain a
         comma-separated list of authentication parameters.
      </p>
      <h1 id="rfc.section.15"><a href="#rfc.section.15">15.</a>&nbsp;<a id="security.considerations" href="#security.considerations">Security Considerations</a></h1>
      <p id="rfc.section.15.p.1">This section is meant to inform application developers, information providers, and users of the security limitations in HTTP/1.1
         as described by this document. The discussion does not include definitive solutions to the problems revealed, though it does
         make some suggestions for reducing security risks.
      </p>
      <h2 id="rfc.section.15.1"><a href="#rfc.section.15.1">15.1</a>&nbsp;<a id="personal.information" href="#personal.information">Personal Information</a></h2>
      <p id="rfc.section.15.1.p.1">HTTP clients are often privy to large amounts of personal information (e.g. the user's name, location, mail address, passwords,
         encryption keys, etc.), and <em class="bcp14">SHOULD</em> be very careful to prevent unintentional leakage of this information via the HTTP protocol to other sources. We very strongly
         recommend that a convenient interface be provided for the user to control dissemination of such information, and that designers
         and implementors be particularly careful in this area. History shows that errors in this area often create serious security
         and/or privacy problems and generate highly adverse publicity for the implementor's company.
      </p>
      <h3 id="rfc.section.15.1.1"><a href="#rfc.section.15.1.1">15.1.1</a>&nbsp;<a id="abuse.of.server.log.information" href="#abuse.of.server.log.information">Abuse of Server Log Information</a></h3>
      <p id="rfc.section.15.1.1.p.1">A server is in the position to save personal data about a user's requests which might identify their reading patterns or subjects
         of interest. This information is clearly confidential in nature and its handling can be constrained by law in certain countries.
         People using the HTTP protocol to provide data are responsible for ensuring that such material is not distributed without
         the permission of any individuals that are identifiable by the published results.
      </p>
      <h3 id="rfc.section.15.1.2"><a href="#rfc.section.15.1.2">15.1.2</a>&nbsp;<a id="security.sensitive" href="#security.sensitive">Transfer of Sensitive Information</a></h3>
      <p id="rfc.section.15.1.2.p.1">Like any generic data transfer protocol, HTTP cannot regulate the content of the data that is transferred, nor is there any
         a priori method of determining the sensitivity of any particular piece of information within the context of any given request.
         Therefore, applications <em class="bcp14">SHOULD</em> supply as much control over this information as possible to the provider of that information. Four header fields are worth
         special mention in this context: Server, Via, Referer and From.
      </p>
      <p id="rfc.section.15.1.2.p.2">Revealing the specific software version of the server might allow the server machine to become more vulnerable to attacks
         against software that is known to contain security holes. Implementors <em class="bcp14">SHOULD</em> make the Server header field a configurable option.
      </p>
      <p id="rfc.section.15.1.2.p.3">Proxies which serve as a portal through a network firewall <em class="bcp14">SHOULD</em> take special precautions regarding the transfer of header information that identifies the hosts behind the firewall. In particular,
         they <em class="bcp14">SHOULD</em> remove, or replace with sanitized versions, any Via fields generated behind the firewall.
      </p>
      <p id="rfc.section.15.1.2.p.4">The Referer header allows reading patterns to be studied and reverse links drawn. Although it can be very useful, its power
         can be abused if user details are not separated from the information contained in the Referer. Even when the personal information
         has been removed, the Referer header might indicate a private document's URI whose publication would be inappropriate.
      </p>
      <p id="rfc.section.15.1.2.p.5">The information sent in the From field might conflict with the user's privacy interests or their site's security policy, and
         hence it <em class="bcp14">SHOULD NOT</em> be transmitted without the user being able to disable, enable, and modify the contents of the field. The user <em class="bcp14">MUST</em> be able to set the contents of this field within a user preference or application defaults configuration.
      </p>
      <p id="rfc.section.15.1.2.p.6">We suggest, though do not require, that a convenient toggle interface be provided for the user to enable or disable the sending
         of From and Referer information.
      </p>
      <p id="rfc.section.15.1.2.p.7">The User-Agent (<a href="#header.user-agent" id="rfc.xref.header.user-agent.3" title="User-Agent">Section&nbsp;14.43</a>) or Server (<a href="#header.server" id="rfc.xref.header.server.2" title="Server">Section&nbsp;14.38</a>) header fields can sometimes be used to determine that a specific client or server have a particular security hole which
         might be exploited. Unfortunately, this same information is often used for other valuable purposes for which HTTP currently
         has no better mechanism.
      </p>
      <h3 id="rfc.section.15.1.3"><a href="#rfc.section.15.1.3">15.1.3</a>&nbsp;<a id="encoding.sensitive.information.in.uris" href="#encoding.sensitive.information.in.uris">Encoding Sensitive Information in URI's</a></h3>
      <p id="rfc.section.15.1.3.p.1">Because the source of a link might be private information or might reveal an otherwise private information source, it is strongly
         recommended that the user be able to select whether or not the Referer field is sent. For example, a browser client could
         have a toggle switch for browsing openly/anonymously, which would respectively enable/disable the sending of Referer and From
         information.
      </p>
      <p id="rfc.section.15.1.3.p.2">Clients <em class="bcp14">SHOULD NOT</em> include a Referer header field in a (non-secure) HTTP request if the referring page was transferred with a secure protocol.
      </p>
      <p id="rfc.section.15.1.3.p.3">Authors of services which use the HTTP protocol <em class="bcp14">SHOULD NOT</em> use GET based forms for the submission of sensitive data, because this will cause this data to be encoded in the Request-URI.
         Many existing servers, proxies, and user agents will log the request URI in some place where it might be visible to third
         parties. Servers can use POST-based form submission instead
      </p>
      <h3 id="rfc.section.15.1.4"><a href="#rfc.section.15.1.4">15.1.4</a>&nbsp;<a id="privacy.issues.connected.to.accept.headers" href="#privacy.issues.connected.to.accept.headers">Privacy Issues Connected to Accept Headers</a></h3>
      <p id="rfc.section.15.1.4.p.1">Accept request-headers can reveal information about the user to all servers which are accessed. The Accept-Language header
         in particular can reveal information the user would consider to be of a private nature, because the understanding of particular
         languages is often strongly correlated to the membership of a particular ethnic group. User agents which offer the option
         to configure the contents of an Accept-Language header to be sent in every request are strongly encouraged to let the configuration
         process include a message which makes the user aware of the loss of privacy involved.
      </p>
      <p id="rfc.section.15.1.4.p.2">An approach that limits the loss of privacy would be for a user agent to omit the sending of Accept-Language headers by default,
         and to ask the user whether or not to start sending Accept-Language headers to a server if it detects, by looking for any
         Vary response-header fields generated by the server, that such sending could improve the quality of service.
      </p>
      <p id="rfc.section.15.1.4.p.3">Elaborate user-customized accept header fields sent in every request, in particular if these include quality values, can be
         used by servers as relatively reliable and long-lived user identifiers. Such user identifiers would allow content providers
         to do click-trail tracking, and would allow collaborating content providers to match cross-server click-trails or form submissions
         of individual users. Note that for many users not behind a proxy, the network address of the host running the user agent will
         also serve as a long-lived user identifier. In environments where proxies are used to enhance privacy, user agents ought to
         be conservative in offering accept header configuration options to end users. As an extreme privacy measure, proxies could
         filter the accept headers in relayed requests. General purpose user agents which provide a high degree of header configurability <em class="bcp14">SHOULD</em> warn users about the loss of privacy which can be involved.
      </p>
      <h2 id="rfc.section.15.2"><a href="#rfc.section.15.2">15.2</a>&nbsp;<a id="attack.pathname" href="#attack.pathname">Attacks Based On File and Path Names</a></h2>
      <p id="rfc.section.15.2.p.1">Implementations of HTTP origin servers <em class="bcp14">SHOULD</em> be careful to restrict the documents returned by HTTP requests to be only those that were intended by the server administrators.
         If an HTTP server translates HTTP URIs directly into file system calls, the server <em class="bcp14">MUST</em> take special care not to serve files that were not intended to be delivered to HTTP clients. For example, UNIX, Microsoft
         Windows, and other operating systems use ".." as a path component to indicate a directory level above the current one. On
         such a system, an HTTP server <em class="bcp14">MUST</em> disallow any such construct in the Request-URI if it would otherwise allow access to a resource outside those intended to
         be accessible via the HTTP server. Similarly, files intended for reference only internally to the server (such as access control
         files, configuration files, and script code) <em class="bcp14">MUST</em> be protected from inappropriate retrieval, since they might contain sensitive information. Experience has shown that minor
         bugs in such HTTP server implementations have turned into security risks.
      </p>
      <h2 id="rfc.section.15.3"><a href="#rfc.section.15.3">15.3</a>&nbsp;<a id="dns.spoofing" href="#dns.spoofing">DNS Spoofing</a></h2>
      <p id="rfc.section.15.3.p.1">Clients using HTTP rely heavily on the Domain Name Service, and are thus generally prone to security attacks based on the
         deliberate mis-association of IP addresses and DNS names. Clients need to be cautious in assuming the continuing validity
         of an IP number/DNS name association.
      </p>
      <p id="rfc.section.15.3.p.2">In particular, HTTP clients <em class="bcp14">SHOULD</em> rely on their name resolver for confirmation of an IP number/DNS name association, rather than caching the result of previous
         host name lookups. Many platforms already can cache host name lookups locally when appropriate, and they <em class="bcp14">SHOULD</em> be configured to do so. It is proper for these lookups to be cached, however, only when the TTL (Time To Live) information
         reported by the name server makes it likely that the cached information will remain useful.
      </p>
      <p id="rfc.section.15.3.p.3">If HTTP clients cache the results of host name lookups in order to achieve a performance improvement, they <em class="bcp14">MUST</em> observe the TTL information reported by DNS.
      </p>
      <p id="rfc.section.15.3.p.4">If HTTP clients do not observe this rule, they could be spoofed when a previously-accessed server's IP address changes. As
         network renumbering is expected to become increasingly common <a href="#RFC1900" id="rfc.xref.RFC1900.2"><cite title="Renumbering Needs Work">[RFC1900]</cite></a>, the possibility of this form of attack will grow. Observing this requirement thus reduces this potential security vulnerability.
      </p>
      <p id="rfc.section.15.3.p.5">This requirement also improves the load-balancing behavior of clients for replicated servers using the same DNS name and reduces
         the likelihood of a user's experiencing failure in accessing sites which use that strategy.
      </p>
      <h2 id="rfc.section.15.4"><a href="#rfc.section.15.4">15.4</a>&nbsp;<a id="location.spoofing" href="#location.spoofing">Location Headers and Spoofing</a></h2>
      <p id="rfc.section.15.4.p.1">If a single server supports multiple organizations that do not trust one another, then it <em class="bcp14">MUST</em> check the values of Location and Content-Location headers in responses that are generated under control of said organizations
         to make sure that they do not attempt to invalidate resources over which they have no authority.
      </p>
      <h2 id="rfc.section.15.5"><a href="#rfc.section.15.5">15.5</a>&nbsp;<a id="content-disposition.issues" href="#content-disposition.issues">Content-Disposition Issues</a></h2>
      <p id="rfc.section.15.5.p.1">RFC 1806 <a href="#RFC1806" id="rfc.xref.RFC1806.1"><cite title="Communicating Presentation Information in Internet Messages: The Content-Disposition Header">[RFC1806]</cite></a>, from which the often implemented Content-Disposition (see <a href="#content-disposition" id="rfc.xref.content-disposition.1" title="Content-Disposition">Appendix&nbsp;19.5.1</a>) header in HTTP is derived, has a number of very serious security considerations. Content-Disposition is not part of the
         HTTP standard, but since it is widely implemented, we are documenting its use and risks for implementors. See RFC 2183 <a href="#RFC2183" id="rfc.xref.RFC2183.1"><cite title="Communicating Presentation Information in Internet Messages: The Content-Disposition Header Field">[RFC2183]</cite></a> (which updates RFC 1806) for details.
      </p>
      <h2 id="rfc.section.15.6"><a href="#rfc.section.15.6">15.6</a>&nbsp;<a id="auth.credentials.and.idle.clients" href="#auth.credentials.and.idle.clients">Authentication Credentials and Idle Clients</a></h2>
      <p id="rfc.section.15.6.p.1">Existing HTTP clients and user agents typically retain authentication information indefinitely. HTTP/1.1. does not provide
         a method for a server to direct clients to discard these cached credentials. This is a significant defect that requires further
         extensions to HTTP. Circumstances under which credential caching can interfere with the application's security model include
         but are not limited to: 
      </p>
      <ul>
         <li>Clients which have been idle for an extended period following which the server might wish to cause the client to reprompt
            the user for credentials.
         </li>
         <li>Applications which include a session termination indication (such as a `logout' or `commit' button on a page) after which
            the server side of the application `knows' that there is no further reason for the client to retain the credentials.
         </li>
      </ul>
      <p id="rfc.section.15.6.p.2">This is currently under separate study. There are a number of work-arounds to parts of this problem, and we encourage the
         use of password protection in screen savers, idle time-outs, and other methods which mitigate the security problems inherent
         in this problem. In particular, user agents which cache credentials are encouraged to provide a readily accessible mechanism
         for discarding cached credentials under user control.
      </p>
      <h2 id="rfc.section.15.7"><a href="#rfc.section.15.7">15.7</a>&nbsp;<a id="attack.proxies" href="#attack.proxies">Proxies and Caching</a></h2>
      <p id="rfc.section.15.7.p.1">By their very nature, HTTP proxies are men-in-the-middle, and represent an opportunity for man-in-the-middle attacks. Compromise
         of the systems on which the proxies run can result in serious security and privacy problems. Proxies have access to security-related
         information, personal information about individual users and organizations, and proprietary information belonging to users
         and content providers. A compromised proxy, or a proxy implemented or configured without regard to security and privacy considerations,
         might be used in the commission of a wide range of potential attacks.
      </p>
      <p id="rfc.section.15.7.p.2">Proxy operators should protect the systems on which proxies run as they would protect any system that contains or transports
         sensitive information. In particular, log information gathered at proxies often contains highly sensitive personal information,
         and/or information about organizations. Log information should be carefully guarded, and appropriate guidelines for use developed
         and followed. (<a href="#abuse.of.server.log.information" title="Abuse of Server Log Information">Section&nbsp;15.1.1</a>).
      </p>
      <p id="rfc.section.15.7.p.3">Caching proxies provide additional potential vulnerabilities, since the contents of the cache represent an attractive target
         for malicious exploitation. Because cache contents persist after an HTTP request is complete, an attack on the cache can reveal
         information long after a user believes that the information has been removed from the network. Therefore, cache contents should
         be protected as sensitive information.
      </p>
      <p id="rfc.section.15.7.p.4">Proxy implementors should consider the privacy and security implications of their design and coding decisions, and of the
         configuration options they provide to proxy operators (especially the default configuration).
      </p>
      <p id="rfc.section.15.7.p.5">Users of a proxy need to be aware that they are no trustworthier than the people who run the proxy; HTTP itself cannot solve
         this problem.
      </p>
      <p id="rfc.section.15.7.p.6">The judicious use of cryptography, when appropriate, may suffice to protect against a broad range of security and privacy
         attacks. Such cryptography is beyond the scope of the HTTP/1.1 specification.
      </p>
      <h3 id="rfc.section.15.7.1"><a href="#rfc.section.15.7.1">15.7.1</a>&nbsp;<a id="attack.DoS" href="#attack.DoS">Denial of Service Attacks on Proxies</a></h3>
      <p id="rfc.section.15.7.1.p.1">They exist. They are hard to defend against. Research continues. Beware.</p>
      <h1 id="rfc.section.16"><a href="#rfc.section.16">16.</a>&nbsp;<a id="ack" href="#ack">Acknowledgments</a></h1>
      <p id="rfc.section.16.p.1">This specification makes heavy use of the augmented BNF and generic constructs defined by David H. Crocker for RFC 822 <a href="#RFC822" id="rfc.xref.RFC822.9"><cite title="Standard for the format of ARPA Internet text messages">[RFC822]</cite></a>. Similarly, it reuses many of the definitions provided by Nathaniel Borenstein and Ned Freed for MIME <a href="#RFC2045" id="rfc.xref.RFC2045.3"><cite title="Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies">[RFC2045]</cite></a>. We hope that their inclusion in this specification will help reduce past confusion over the relationship between HTTP and
         Internet mail message formats.
      </p>
      <p id="rfc.section.16.p.2">The HTTP protocol has evolved considerably over the years. It has benefited from a large and active developer community--the
         many people who have participated on the www-talk mailing list--and it is that community which has been most responsible for
         the success of HTTP and of the World-Wide Web in general. Marc Andreessen, Robert Cailliau, Daniel W. Connolly, Bob Denny,
         John Franks, Jean-Francois Groff, Phillip M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob McCool, Lou Montulli, Dave Raggett,
         Tony Sanders, and Marc VanHeyningen deserve special recognition for their efforts in defining early aspects of the protocol.
      </p>
      <p id="rfc.section.16.p.3">This document has benefited greatly from the comments of all those participating in the HTTP-WG. In addition to those already
         mentioned, the following individuals have contributed to this specification:
      </p>
      <div id="rfc.figure.u.154"></div><pre class="text">    Gary Adams                  Ross Patterson
    Harald Tveit Alvestrand     Albert Lunde
    Keith Ball                  John C. Mallery
    Brian Behlendorf            Jean-Philippe Martin-Flatin
    Paul Burchard               Mitra
    Maurizio Codogno            David Morris
    Mike Cowlishaw              Gavin Nicol
    Roman Czyborra              Bill Perry
    Michael A. Dolan            Jeffrey Perry
    David J. Fiander            Scott Powers
    Alan Freier                 Owen Rees
    Marc Hedlund                Luigi Rizzo
    Greg Herlihy                David Robinson
    Koen Holtman                Marc Salomon
    Alex Hopmann                Rich Salz
    Bob Jernigan                Allan M. Schiffman
    Shel Kaphan                 Jim Seidman
    Rohit Khare                 Chuck Shotton
    John Klensin                Eric W. Sink
    Martijn Koster              Simon E. Spero
    Alexei Kosut                Richard N. Taylor
    David M. Kristol            Robert S. Thau
    Daniel LaLiberte            Bill (BearHeart) Weinman
    Ben Laurie                  Francois Yergeau
    Paul J. Leach               Mary Ellen Zurko
    Daniel DuBois               Josh Cohen
</pre><p id="rfc.section.16.p.5">Much of the content and presentation of the caching design is due to suggestions and comments from individuals including:
         Shel Kaphan, Paul Leach, Koen Holtman, David Morris, and Larry Masinter.
      </p>
      <p id="rfc.section.16.p.6">Most of the specification of ranges is based on work originally done by Ari Luotonen and John Franks, with additional input
         from Steve Zilles.
      </p>
      <p id="rfc.section.16.p.7">Thanks to the "cave men" of Palo Alto. You know who you are.</p>
      <p id="rfc.section.16.p.8">Jim Gettys (the current editor of this document) wishes particularly to thank Roy Fielding, the previous editor of this document,
         along with John Klensin, Jeff Mogul, Paul Leach, Dave Kristol, Koen Holtman, John Franks, Josh Cohen, Alex Hopmann, Scott
         Lawrence, and Larry Masinter for their help. And thanks go particularly to Jeff Mogul and Scott Lawrence for performing the
         "MUST/MAY/SHOULD" audit.
      </p>
      <p id="rfc.section.16.p.9">The Apache Group, Anselm Baird-Smith, author of Jigsaw, and Henrik Frystyk implemented RFC 2068 early, and we wish to thank
         them for the discovery of many of the problems that this document attempts to rectify.
      </p>
      <h1 id="rfc.references"><a href="#rfc.section.17" id="rfc.section.17">17.</a> References
      </h1>
      <table summary="References">                                                                                                  
         <tr>
            <td class="reference"><b id="ISO-8859">[ISO-8859]</b></td>
            <td class="top">International Organization for Standardization, “Information technology - 8-bit single byte coded graphic - character sets”, 1987-1990.<br>Part 1: Latin alphabet No. 1, ISO-8859-1:1987. Part 2: Latin alphabet No. 2, ISO-8859-2, 1987. Part 3: Latin alphabet No.
               3, ISO-8859-3, 1988. Part 4: Latin alphabet No. 4, ISO-8859-4, 1988. Part 5: Latin/Cyrillic alphabet, ISO-8859-5, 1988. Part
               6: Latin/Arabic alphabet, ISO-8859-6, 1987. Part 7: Latin/Greek alphabet, ISO-8859-7, 1987. Part 8: Latin/Hebrew alphabet,
               ISO-8859-8, 1988. Part 9: Latin alphabet No. 5, ISO-8859-9, 1990.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="Luo1998">[Luo1998]</b></td>
            <td class="top">Luotonen, A., “Tunneling TCP based protocols through Web proxy servers”, &nbsp;Work in Progress.</td>
         </tr>
         <tr>
            <td class="reference"><b id="Nie1997">[Nie1997]</b></td>
            <td class="top">Nielsen, H.F.., Gettys, J., Prud'hommeaux, E., Lie, H., and C. Lilley, “Network Performance Effects of HTTP/1.1, CSS1, and PNG”, Proceedings of ACM SIGCOMM '97, Cannes France, Sep&nbsp;1997.</td>
         </tr>
         <tr>
            <td class="reference"><b id="Pad1995">[Pad1995]</b></td>
            <td class="top">Padmanabhan, V.N. and J.C. Mogul, “Improving HTTP Latency”, Computer Networks and ISDN Systems&nbsp;v. 28, pp. 25-35, Dec&nbsp;1995.<br>Slightly revised version of paper in Proc. 2nd International WWW Conference '94: Mosaic and the Web, Oct. 1994, which is available
               at &lt;<a href="http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLatency.html">http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLatency.html</a>&gt;.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC1036">[RFC1036]</b></td>
            <td class="top">Horton, M. and R. Adams, “<a href="http://tools.ietf.org/html/rfc1036">Standard for interchange of USENET messages</a>”, RFC&nbsp;1036, December&nbsp;1987.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC1123">[RFC1123]</b></td>
            <td class="top"><a title="University of Southern California (USC), Information Sciences Institute">Braden, R.</a>, “<a href="http://tools.ietf.org/html/rfc1123">Requirements for Internet Hosts - Application and Support</a>”, STD&nbsp;3, RFC&nbsp;1123, October&nbsp;1989.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC1305">[RFC1305]</b></td>
            <td class="top"><a title="University of Delaware, Electrical Engineering Department">Mills, D.</a>, “<a href="http://tools.ietf.org/html/rfc1305">Network Time Protocol (Version 3) Specification, Implementation</a>”, RFC&nbsp;1305, March&nbsp;1992.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC1436">[RFC1436]</b></td>
            <td class="top"><a title="University of Minnesota, Computer and Information Services">Anklesaria, F.</a>, <a title="University of Minnesota, Computer and Information Services">McCahill, M.</a>, <a title="University of Minnesota, Computer and Information Services">Lindner, P.</a>, <a title="University of Minnesota, Computer and Information Services">Johnson, D.</a>, <a title="University of Minnesota, Computer and Information Services">Torrey, D.</a>, and <a title="University of Minnesota, Computer and Information Services">B. Alberti</a>, “<a href="http://tools.ietf.org/html/rfc1436">The Internet Gopher Protocol (a distributed document search and retrieval protocol)</a>”, RFC&nbsp;1436, March&nbsp;1993.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC1590">[RFC1590]</b></td>
            <td class="top"><a title="USC/Information Sciences Institute">Postel, J.</a>, “<a href="http://tools.ietf.org/html/rfc1590">Media Type Registration Procedure</a>”, RFC&nbsp;1590, November&nbsp;1996.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC1630">[RFC1630]</b></td>
            <td class="top"><a title="CERN, World-Wide Web project">Berners-Lee, T.</a>, “<a href="http://tools.ietf.org/html/rfc1630">Universal Resource Identifiers in WWW: A Unifying Syntax for the Expression of Names and Addresses of Objects on the Network
                  as used in the World-Wide Web</a>”, RFC&nbsp;1630, June&nbsp;1994.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC1700">[RFC1700]</b></td>
            <td class="top"><a title="USC/Information Sciences Institute">Reynolds, J.</a> and <a title="USC/Information Sciences Institute">J. Postel</a>, “<a href="http://tools.ietf.org/html/rfc1700">Assigned Numbers</a>”, STD&nbsp;2, RFC&nbsp;1700, October&nbsp;1994.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC1737">[RFC1737]</b></td>
            <td class="top"><a title="Xerox Palo Alto Research Center">Masinter, L.</a> and <a title="MIT Laboratory for Computer Science">K. Sollins</a>, “<a href="http://tools.ietf.org/html/rfc1737">Functional Requirements for Uniform Resource Names</a>”, RFC&nbsp;1737, December&nbsp;1994.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC1738">[RFC1738]</b></td>
            <td class="top"><a title="CERN, World-Wide Web project">Berners-Lee, T.</a>, <a title="Xerox PARC">Masinter, L.</a>, and <a title="University of Minnesota, Computer and Information Services">M. McCahill</a>, “<a href="http://tools.ietf.org/html/rfc1738">Uniform Resource Locators (URL)</a>”, RFC&nbsp;1738, December&nbsp;1994.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC1766">[RFC1766]</b></td>
            <td class="top"><a title="UNINETT">Alvestrand, H.</a>, “<a href="http://tools.ietf.org/html/rfc1766">Tags for the Identification of Languages</a>”, RFC&nbsp;1766, March&nbsp;1995.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC1806">[RFC1806]</b></td>
            <td class="top"><a title="New Century Systems">Troost, R.</a> and <a title="QUALCOMM Incorporated">S. Dorner</a>, “<a href="http://tools.ietf.org/html/rfc1806">Communicating Presentation Information in Internet Messages: The Content-Disposition Header</a>”, RFC&nbsp;1806, June&nbsp;1995.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC1808">[RFC1808]</b></td>
            <td class="top"><a title="University of California Irvine, Department of Information and Computer Science">Fielding, R.</a>, “<a href="http://tools.ietf.org/html/rfc1808">Relative Uniform Resource Locators</a>”, RFC&nbsp;1808, June&nbsp;1995.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC1864">[RFC1864]</b></td>
            <td class="top"><a title="Carnegie Mellon University">Myers, J.</a> and <a title="Dover Beach Consulting, Inc.">M. Rose</a>, “<a href="http://tools.ietf.org/html/rfc1864">The Content-MD5 Header Field</a>”, RFC&nbsp;1864, October&nbsp;1995.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC1866">[RFC1866]</b></td>
            <td class="top"><a title="MIT Laboratory for Computer Science">Berners-Lee, T.</a> and <a title="MIT Laboratory for Computer Science, W3 Consortium">D.W. Connolly</a>, “<a href="http://tools.ietf.org/html/rfc1866">Hypertext Markup Language - 2.0</a>”, RFC&nbsp;1866, November&nbsp;1995.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC1867">[RFC1867]</b></td>
            <td class="top"><a title="Xerox Palo Alto Research Center">Masinter, L.</a> and <a title="XSoft, Xerox Corporation">E. Nebel</a>, “<a href="http://tools.ietf.org/html/rfc1867">Form-based File Upload in HTML</a>”, RFC&nbsp;1867, November&nbsp;1995.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC1900">[RFC1900]</b></td>
            <td class="top"><a title="CERN, Computing and Networks Division">Carpenter, B.</a> and <a title="cisco Systems">Y. Rekhter</a>, “<a href="http://tools.ietf.org/html/rfc1900">Renumbering Needs Work</a>”, RFC&nbsp;1900, February&nbsp;1996.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC1945">[RFC1945]</b></td>
            <td class="top"><a title="MIT, Laboratory for Computer Science">Berners-Lee, T.</a>, <a title="University of California, Irvine, Department of Information and Computer Science">Fielding, R.T.</a>, and <a title="W3 Consortium, MIT Laboratory for Computer Science">H.F. Nielsen</a>, “<a href="http://tools.ietf.org/html/rfc1945">Hypertext Transfer Protocol -- HTTP/1.0</a>”, RFC&nbsp;1945, May&nbsp;1996.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC1950">[RFC1950]</b></td>
            <td class="top"><a title="Aladdin Enterprises">Deutsch, L.P.</a> and J-L. Gailly, “<a href="http://tools.ietf.org/html/rfc1950">ZLIB Compressed Data Format Specification version 3.3</a>”, RFC&nbsp;1950, May&nbsp;1996.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC1951">[RFC1951]</b></td>
            <td class="top"><a title="Aladdin Enterprises">Deutsch, P.</a>, “<a href="http://tools.ietf.org/html/rfc1951">DEFLATE Compressed Data Format Specification version 1.3</a>”, RFC&nbsp;1951, May&nbsp;1996.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC1952">[RFC1952]</b></td>
            <td class="top"><a title="Aladdin Enterprises">Deutsch, P.</a>, <a>Gailly, J-L.</a>, <a>Adler, M.</a>, <a>Deutsch, L.P.</a>, and <a>G. Randers-Pehrson</a>, “<a href="http://tools.ietf.org/html/rfc1952">GZIP file format specification version 4.3</a>”, RFC&nbsp;1952, May&nbsp;1996.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2026">[RFC2026]</b></td>
            <td class="top"><a title="Harvard University">Bradner, S.</a>, “<a href="http://tools.ietf.org/html/rfc2026">The Internet Standards Process -- Revision 3</a>”, BCP&nbsp;9, RFC&nbsp;2026, October&nbsp;1996.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2045">[RFC2045]</b></td>
            <td class="top"><a title="Innosoft International, Inc.">Freed, N.</a> and <a title="First Virtual Holdings">N.S. Borenstein</a>, “<a href="http://tools.ietf.org/html/rfc2045">Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</a>”, RFC&nbsp;2045, November&nbsp;1996.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2046">[RFC2046]</b></td>
            <td class="top"><a title="Innosoft International, Inc.">Freed, N.</a> and <a title="First Virtual Holdings">N. Borenstein</a>, “<a href="http://tools.ietf.org/html/rfc2046">Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</a>”, RFC&nbsp;2046, November&nbsp;1996.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2047">[RFC2047]</b></td>
            <td class="top"><a title="University of Tennessee">Moore, K.</a>, “<a href="http://tools.ietf.org/html/rfc2047">MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Text</a>”, RFC&nbsp;2047, November&nbsp;1996.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2049">[RFC2049]</b></td>
            <td class="top"><a title="Innosoft International, Inc.">Freed, N.</a> and <a title="First Virtual Holdings">N.S. Borenstein</a>, “<a href="http://tools.ietf.org/html/rfc2049">Multipurpose Internet Mail Extensions (MIME) Part Five: Conformance Criteria and Examples</a>”, RFC&nbsp;2049, November&nbsp;1996.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2068">[RFC2068]</b></td>
            <td class="top"><a title="University of California, Irvine, Department of Information and Computer Science">Fielding, R.</a>, <a title="MIT Laboratory for Computer Science">Gettys, J.</a>, <a title="Digital Equipment Corporation, Western Research Laboratory">Mogul, J.</a>, <a title="MIT Laboratory for Computer Science">Nielsen, H.</a>, and <a title="MIT Laboratory for Computer Science">T. Berners-Lee</a>, “<a href="http://tools.ietf.org/html/rfc2068">Hypertext Transfer Protocol -- HTTP/1.1</a>”, RFC&nbsp;2068, January&nbsp;1997.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2069">[RFC2069]</b></td>
            <td class="top"><a title="Northwestern University,  Department of Mathematics">Franks, J.</a>, <a title="CERN">Hallam-Baker, P.</a>, <a title="Spyglass, Inc.">Hostetler, J.</a>, <a title="Microsoft Corporation">Leach, P.</a>, <a title="Netscape Communications Corporation">Luotonen, A.</a>, <a title="Spyglass, Inc.">Sink, E.</a>, and <a title="Open Market, Inc.">L. Stewart</a>, “<a href="http://tools.ietf.org/html/rfc2069">An Extension to HTTP : Digest Access Authentication</a>”, RFC&nbsp;2069, January&nbsp;1997.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2076">[RFC2076]</b></td>
            <td class="top"><a title="Stockholm University/KTH">Palme, J.</a>, “<a href="http://tools.ietf.org/html/rfc2076">Common Internet Message Headers</a>”, RFC&nbsp;2076, February&nbsp;1997.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2110">[RFC2110]</b></td>
            <td class="top"><a title="Stockholm University and KTH">Palme, J.</a> and <a title="Microsoft Corporation">A. Hopmann</a>, “<a href="http://tools.ietf.org/html/rfc2110">MIME E-mail Encapsulation of Aggregate Documents, such as HTML (MHTML)</a>”, RFC&nbsp;2110, March&nbsp;1997.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2119">[RFC2119]</b></td>
            <td class="top"><a title="Harvard University">Bradner, S.</a>, “<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2145">[RFC2145]</b></td>
            <td class="top"><a title="Western Research Laboratory">Mogul, J.C.</a>, <a title="Department of Information and Computer Science">Fielding, R.T.</a>, <a title="MIT Laboratory for Computer Science">Gettys, J.</a>, and <a title="W3 Consortium">H.F. Nielsen</a>, “<a href="http://tools.ietf.org/html/rfc2145">Use and Interpretation of HTTP Version Numbers</a>”, RFC&nbsp;2145, May&nbsp;1997.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2183">[RFC2183]</b></td>
            <td class="top"><a title="New Century Systems">Troost, R.</a>, <a title="QUALCOMM Incorporated">Dorner, S.</a>, and <a title="Department of Computer Science">K. Moore</a>, “<a href="http://tools.ietf.org/html/rfc2183">Communicating Presentation Information in Internet Messages: The Content-Disposition Header Field</a>”, RFC&nbsp;2183, August&nbsp;1997.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2277">[RFC2277]</b></td>
            <td class="top"><a title="UNINETT">Alvestrand, H.T.</a>, “<a href="http://tools.ietf.org/html/rfc2277">IETF Policy on Character Sets and Languages</a>”, BCP&nbsp;18, RFC&nbsp;2277, January&nbsp;1998.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2279">[RFC2279]</b></td>
            <td class="top"><a title="Alis Technologies">Yergeau, F.</a>, “<a href="http://tools.ietf.org/html/rfc2279">UTF-8, a transformation format of ISO 10646</a>”, RFC&nbsp;2279, January&nbsp;1998.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2324">[RFC2324]</b></td>
            <td class="top"><a title="Xerox Palo Alto Research Center">Masinter, L.</a>, “<a href="http://tools.ietf.org/html/rfc2324">Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)</a>”, RFC&nbsp;2324, April&nbsp;1998.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2396">[RFC2396]</b></td>
            <td class="top"><a title="World Wide Web Consortium">Berners-Lee, T.</a>, <a title="Department of Information and Computer Science">Fielding, R.T.</a>, and <a title="Xerox PARC">L. Masinter</a>, “<a href="http://tools.ietf.org/html/rfc2396">Uniform Resource Identifiers (URI): Generic Syntax</a>”, RFC&nbsp;2396, August&nbsp;1998.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC2617">[RFC2617]</b></td>
            <td class="top"><a title="Northwestern University, Department of Mathematics">Franks, J.</a>, <a title="Verisign Inc.">Hallam-Baker, P.M.</a>, <a title="AbiSource, Inc.">Hostetler, J.L.</a>, <a title="Agranat Systems, Inc.">Lawrence, S.D.</a>, <a title="Microsoft Corporation">Leach, P.J.</a>, Luotonen, A., and <a title="Open Market, Inc.">L. Stewart</a>, “<a href="http://tools.ietf.org/html/rfc2617">HTTP Authentication: Basic and Digest Access Authentication</a>”, RFC&nbsp;2617, June&nbsp;1999.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC821">[RFC821]</b></td>
            <td class="top">Postel, J.B., “<a href="http://tools.ietf.org/html/rfc821">Simple Mail Transfer Protocol</a>”, STD&nbsp;10, RFC&nbsp;821, August&nbsp;1982.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC822">[RFC822]</b></td>
            <td class="top"><a title="University of Delaware, Dept. of Electrical Engineering">Crocker, D.H.</a>, “<a href="http://tools.ietf.org/html/rfc822">Standard for the format of ARPA Internet text messages</a>”, STD&nbsp;11, RFC&nbsp;822, August&nbsp;1982.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC959">[RFC959]</b></td>
            <td class="top">Postel, J. and J. Reynolds, “<a href="http://tools.ietf.org/html/rfc959">File Transfer Protocol</a>”, STD&nbsp;9, RFC&nbsp;959, October&nbsp;1985.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="RFC977">[RFC977]</b></td>
            <td class="top">Kantor, B. and P. Lapsley, “<a href="http://tools.ietf.org/html/rfc977">Network News Transfer Protocol</a>”, RFC&nbsp;977, February&nbsp;1986.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="Spe">[Spe]</b></td>
            <td class="top">Spero, S., “<a href="http://sunsite.unc.edu/mdma-release/http-prob.html">Analysis of HTTP Performance Problems</a>”, &lt;<a href="http://sunsite.unc.edu/mdma-release/http-prob.html">http://sunsite.unc.edu/mdma-release/http-prob.html</a>&gt;.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="Tou1998">[Tou1998]</b></td>
            <td class="top"><a title="USC/Information Sciences Institute">Touch, J.</a>, <a title="USC/Information Sciences Institute">Heidemann, J.</a>, and <a title="USC/Information Sciences Institute">K. Obraczka</a>, “<a href="http://www.isi.edu/touch/pubs/http-perf96/">Analysis of HTTP Performance</a>”, ISI Research Report&nbsp;ISI/RR-98-463 (original report dated Aug.1996), Aug&nbsp;1998, &lt;<a href="http://www.isi.edu/touch/pubs/http-perf96/">http://www.isi.edu/touch/pubs/http-perf96/</a>&gt;.
            </td>
         </tr>
         <tr>
            <td class="reference"><b id="USASCII">[USASCII]</b></td>
            <td class="top">American National Standards Institute, “Coded Character Set -- 7-bit American Standard Code for Information Interchange”, ANSI&nbsp;X3.4, 1986.</td>
         </tr>
         <tr>
            <td class="reference"><b id="WAIS">[WAIS]</b></td>
            <td class="top">Davis, F., Kahle, B., Morris, H., Salem, J., Shen, T., Wang, R., Sui, J., and M. Grinbaum, “WAIS Interface Protocol Prototype Functional Specification (v1.5)”, Thinking Machines Corporation, April&nbsp;1990.</td>
         </tr>
      </table>
      <h1 id="rfc.authors"><a href="#rfc.section.18" id="rfc.section.18">18.</a> <a href="#rfc.authors">Authors' Addresses</a></h1>
      <address class="vcard"><span class="vcardline"><span class="fn">Roy T. Fielding</span><span class="n hidden"><span class="family-name">Fielding</span><span class="given-name">Roy T.</span></span></span><span class="org vcardline">Department of Information and Computer Science</span><span class="adr"><span class="street-address vcardline">University of California, Irvine</span><span class="vcardline"><span class="locality">Irvine</span>, <span class="region">CA</span>&nbsp;<span class="postal-code">92697-3425</span></span></span><span class="vcardline tel"><span class="type">Fax</span>: <a href="fax:+1(949)824-1715"><span class="value">+1(949)824-1715</span></a></span><span class="vcardline">EMail: <a><span class="email">fielding@ics.uci.edu</span></a></span></address>
      <address class="vcard"><span class="vcardline"><span class="fn">James Gettys</span><span class="n hidden"><span class="family-name">Gettys</span><span class="given-name">James</span></span></span><span class="org vcardline">World Wide Web Consortium</span><span class="adr"><span class="street-address vcardline">MIT Laboratory for Computer Science, NE43-356</span><span class="street-address vcardline">545 Technology Square</span><span class="vcardline"><span class="locality">Cambridge</span>, <span class="region">MA</span>&nbsp;<span class="postal-code">02139</span></span></span><span class="vcardline tel"><span class="type">Fax</span>: <a href="fax:+1(617)258-8682"><span class="value">+1(617)258-8682</span></a></span><span class="vcardline">EMail: <a><span class="email">jg@w3.org</span></a></span></address>
      <address class="vcard"><span class="vcardline"><span class="fn">Jeffrey C. Mogul</span><span class="n hidden"><span class="family-name">Mogul</span><span class="given-name">Jeffrey C.</span></span></span><span class="org vcardline">Compaq Computer Corporation</span><span class="adr"><span class="street-address vcardline">Western Research Laboratory</span><span class="street-address vcardline">250 University Avenue</span><span class="vcardline"><span class="locality">Palo Alto</span>, <span class="region">CA</span>&nbsp;<span class="postal-code">94305</span></span></span><span class="vcardline">EMail: <a><span class="email">mogul@wrl.dec.com</span></a></span></address>
      <address class="vcard"><span class="vcardline"><span class="fn">Henrik Frystyk Nielsen</span><span class="n hidden"><span class="family-name">Frystyk</span></span></span><span class="org vcardline">World Wide Web Consortium</span><span class="adr"><span class="street-address vcardline">MIT Laboratory for Computer Science, NE43-356</span><span class="street-address vcardline">545 Technology Square</span><span class="vcardline"><span class="locality">Cambridge</span>, <span class="region">MA</span>&nbsp;<span class="postal-code">02139</span></span></span><span class="vcardline tel"><span class="type">Fax</span>: <a href="fax:+1(617)258-8682"><span class="value">+1(617)258-8682</span></a></span><span class="vcardline">EMail: <a><span class="email">frystyk@w3.org</span></a></span></address>
      <address class="vcard"><span class="vcardline"><span class="fn">Larry Masinter</span><span class="n hidden"><span class="family-name">Masinter</span><span class="given-name">Larry</span></span></span><span class="org vcardline">Xerox Corporation</span><span class="adr"><span class="street-address vcardline">MIT Laboratory for Computer Science, NE43-356</span><span class="street-address vcardline">3333 Coyote Hill Road</span><span class="vcardline"><span class="locality">Palo Alto</span>, <span class="region">CA</span>&nbsp;<span class="postal-code">94034</span></span></span><span class="vcardline">EMail: <a><span class="email">masinter@parc.xerox.com</span></a></span></address>
      <address class="vcard"><span class="vcardline"><span class="fn">Paul J. Leach</span><span class="n hidden"><span class="family-name">Leach</span><span class="given-name">Paul J.</span></span></span><span class="org vcardline">Microsoft Corporation</span><span class="adr"><span class="street-address vcardline">1 Microsoft Way</span><span class="vcardline"><span class="locality">Redmond</span>, <span class="region">WA</span>&nbsp;<span class="postal-code">98052</span></span></span><span class="vcardline">EMail: <a><span class="email">paulle@microsoft.com</span></a></span></address>
      <address class="vcard"><span class="vcardline"><span class="fn">Tim Berners-Lee</span><span class="n hidden"><span class="family-name">Berners-Lee</span><span class="given-name">Tim</span></span></span><span class="org vcardline">World Wide Web Consortium</span><span class="adr"><span class="street-address vcardline">MIT Laboratory for Computer Science, NE43-356</span><span class="street-address vcardline">545 Technology Square</span><span class="vcardline"><span class="locality">Cambridge</span>, <span class="region">MA</span>&nbsp;<span class="postal-code">02139</span></span></span><span class="vcardline tel"><span class="type">Fax</span>: <a href="fax:+1(617)258-8682"><span class="value">+1(617)258-8682</span></a></span><span class="vcardline">EMail: <a><span class="email">timbl@w3.org</span></a></span></address>
      <h1 id="rfc.section.19"><a href="#rfc.section.19">19.</a>&nbsp;Appendices
      </h1>
      <div id="rfc.iref.m.16"></div>
      <div id="rfc.iref.m.17"></div>
      <div id="rfc.iref.m.18"></div>
      <div id="rfc.iref.a.10"></div>
      <h2 id="rfc.section.19.1"><a href="#rfc.section.19.1">19.1</a>&nbsp;<a id="internet.media.type.http" href="#internet.media.type.http">Internet Media Type message/http and application/http</a></h2>
      <p id="rfc.section.19.1.p.1">In addition to defining the HTTP/1.1 protocol, this document serves as the specification for the Internet media type "message/http"
         and "application/http". The message/http type can be used to enclose a single HTTP request or response message, provided that
         it obeys the MIME restrictions for all "message" types regarding line length and encodings. The application/http type can
         be used to enclose a pipeline of one or more HTTP request or response messages (not intermixed). The following is to be registered
         with IANA <a href="#RFC1590" id="rfc.xref.RFC1590.3"><cite title="Media Type Registration Procedure">[RFC1590]</cite></a>.
      </p>
      <p id="rfc.section.19.1.p.2"> </p>
      <dl>
         <dt>Media Type name:</dt>
         <dd>message</dd>
         <dt>Media subtype name:</dt>
         <dd>http</dd>
         <dt>Required parameters:</dt>
         <dd>none</dd>
         <dt>Optional parameters:</dt>
         <dd>version, msgtype 
            <dl>
               <dt>version:</dt>
               <dd>The HTTP-Version number of the enclosed message (e.g., "1.1"). If not present, the version can be determined from the first
                  line of the body.
               </dd>
               <dt>msgtype:</dt>
               <dd>The message type -- "request" or "response". If not present, the type can be determined from the first line of the body.</dd>
            </dl> 
         </dd>
         <dt>Encoding considerations:</dt>
         <dd>only "7bit", "8bit", or "binary" are permitted</dd>
         <dt>Security considerations:</dt>
         <dd>none</dd>
      </dl>
      <p id="rfc.section.19.1.p.3"> </p>
      <dl>
         <dt>Media Type name:</dt>
         <dd>application</dd>
         <dt>Media subtype name:</dt>
         <dd>http</dd>
         <dt>Required parameters:</dt>
         <dd>none</dd>
         <dt>Optional parameters:</dt>
         <dd>version, msgtype 
            <dl>
               <dt>version:</dt>
               <dd>The HTTP-Version number of the enclosed messages (e.g., "1.1"). If not present, the version can be determined from the first
                  line of the body.
               </dd>
               <dt>msgtype:</dt>
               <dd>The message type -- "request" or "response". If not present, the type can be determined from the first line of the body.</dd>
            </dl> 
         </dd>
         <dt>Encoding considerations:</dt>
         <dd>HTTP messages enclosed by this type are in "binary" format; use of an appropriate Content-Transfer-Encoding is required when
            transmitted via E-mail.
         </dd>
         <dt>Security considerations:</dt>
         <dd>none</dd>
      </dl>
      <div id="rfc.iref.m.19"></div>
      <div id="rfc.iref.m.20"></div>
      <h2 id="rfc.section.19.2"><a href="#rfc.section.19.2">19.2</a>&nbsp;<a id="internet.media.type.multipart.byteranges" href="#internet.media.type.multipart.byteranges">Internet Media Type multipart/byteranges</a></h2>
      <p id="rfc.section.19.2.p.1">When an HTTP 206 (Partial Content) response message includes the content of multiple ranges (a response to a request for multiple
         non-overlapping ranges), these are transmitted as a multipart message-body. The media type for this purpose is called "multipart/byteranges".
      </p>
      <p id="rfc.section.19.2.p.2">The multipart/byteranges media type includes two or more parts, each with its own Content-Type and Content-Range fields. The
         required boundary parameter specifies the boundary string used to separate each body-part.
      </p>
      <p id="rfc.section.19.2.p.3"> </p>
      <dl>
         <dt>Media Type name:</dt>
         <dd>multipart</dd>
         <dt>Media subtype name:</dt>
         <dd>byteranges</dd>
         <dt>Required parameters:</dt>
         <dd>boundary</dd>
         <dt>Optional parameters:</dt>
         <dd>none</dd>
         <dt>Encoding considerations:</dt>
         <dd>only "7bit", "8bit", or "binary" are permitted</dd>
         <dt>Security considerations:</dt>
         <dd>none</dd>
      </dl>
      <div id="rfc.figure.u.155"></div>
      <p>For example:</p><pre class="text">   HTTP/1.1 206 Partial Content
   Date: Wed, 15 Nov 1995 06:25:24 GMT
   Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
   Content-type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

   --THIS_STRING_SEPARATES
   Content-type: application/pdf
   Content-range: bytes 500-999/8000

   ...the first range...
   --THIS_STRING_SEPARATES
   Content-type: application/pdf
   Content-range: bytes 7000-7999/8000

   ...the second range
   --THIS_STRING_SEPARATES--
</pre><p id="rfc.section.19.2.p.5">Notes: </p>
      <ol>
         <li>Additional CRLFs may precede the first boundary string in the entity.</li>
         <li>Although RFC 2046 <a href="#RFC2046" id="rfc.xref.RFC2046.3"><cite title="Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types">[RFC2046]</cite></a> permits the boundary string to be quoted, some existing implementations handle a quoted boundary string incorrectly.
         </li>
         <li>A number of browsers and servers were coded to an early draft of the byteranges specification to use a media type of multipart/x-byteranges<span id="rfc.iref.m.21"></span><span id="rfc.iref.m.22"></span>, which is almost, but not quite compatible with the version documented in HTTP/1.1.
         </li>
      </ol>
      <h2 id="rfc.section.19.3"><a href="#rfc.section.19.3">19.3</a>&nbsp;<a id="tolerant.applications" href="#tolerant.applications">Tolerant Applications</a></h2>
      <p id="rfc.section.19.3.p.1">Although this document specifies the requirements for the generation of HTTP/1.1 messages, not all applications will be correct
         in their implementation. We therefore recommend that operational applications be tolerant of deviations whenever those deviations
         can be interpreted unambiguously.
      </p>
      <p id="rfc.section.19.3.p.2">Clients <em class="bcp14">SHOULD</em> be tolerant in parsing the Status-Line and servers tolerant when parsing the Request-Line. In particular, they <em class="bcp14">SHOULD</em> accept any amount of SP or HT characters between fields, even though only a single SP is required.
      </p>
      <p id="rfc.section.19.3.p.3">The line terminator for message-header fields is the sequence CRLF. However, we recommend that applications, when parsing
         such headers, recognize a single LF as a line terminator and ignore the leading CR.
      </p>
      <p id="rfc.section.19.3.p.4">The character set of an entity-body <em class="bcp14">SHOULD</em> be labeled as the lowest common denominator of the character codes used within that body, with the exception that not labeling
         the entity is preferred over labeling the entity with the labels US-ASCII or ISO-8859-1. See section <a href="#canonicalization.and.text.defaults" title="Canonicalization and Text Defaults">3.7.1</a> and <a href="#missing.charset" title="Missing Charset">3.4.1</a>.
      </p>
      <p id="rfc.section.19.3.p.5">Additional rules for requirements on parsing and encoding of dates and other potential problems with date encodings include:</p>
      <p id="rfc.section.19.3.p.6"> </p>
      <ul>
         <li>HTTP/1.1 clients and caches <em class="bcp14">SHOULD</em> assume that an RFC-850 date which appears to be more than 50 years in the future is in fact in the past (this helps solve
            the "year 2000" problem).
         </li>
         <li>An HTTP/1.1 implementation <em class="bcp14">MAY</em> internally represent a parsed Expires date as earlier than the proper value, but <em class="bcp14">MUST NOT</em> internally represent a parsed Expires date as later than the proper value.
         </li>
         <li>All expiration-related calculations <em class="bcp14">MUST</em> be done in GMT. The local time zone <em class="bcp14">MUST NOT</em> influence the calculation or comparison of an age or expiration time.
         </li>
         <li>If an HTTP header incorrectly carries a date value with a time zone other than GMT, it <em class="bcp14">MUST</em> be converted into GMT using the most conservative possible conversion.
         </li>
      </ul>
      <h2 id="rfc.section.19.4"><a href="#rfc.section.19.4">19.4</a>&nbsp;<a id="differences.between.http.entities.and.rfc.2045.entities" href="#differences.between.http.entities.and.rfc.2045.entities">Differences Between HTTP Entities and RFC 2045 Entities</a></h2>
      <p id="rfc.section.19.4.p.1">HTTP/1.1 uses many of the constructs defined for Internet Mail (RFC 822 <a href="#RFC822" id="rfc.xref.RFC822.10"><cite title="Standard for the format of ARPA Internet text messages">[RFC822]</cite></a>) and the Multipurpose Internet Mail Extensions (MIME <a href="#RFC2045" id="rfc.xref.RFC2045.4"><cite title="Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies">[RFC2045]</cite></a>) to allow entities to be transmitted in an open variety of representations and with extensible mechanisms. However, RFC 2045
         discusses mail, and HTTP has a few features that are different from those described in RFC 2045. These differences were carefully
         chosen to optimize performance over binary connections, to allow greater freedom in the use of new media types, to make date
         comparisons easier, and to acknowledge the practice of some early HTTP servers and clients.
      </p>
      <p id="rfc.section.19.4.p.2">This appendix describes specific areas where HTTP differs from RFC 2045. Proxies and gateways to strict MIME environments <em class="bcp14">SHOULD</em> be aware of these differences and provide the appropriate conversions where necessary. Proxies and gateways from MIME environments
         to HTTP also need to be aware of the differences because some conversions might be required.
      </p>
      <h3 id="rfc.section.19.4.1"><a href="#rfc.section.19.4.1">19.4.1</a>&nbsp;<a id="mime-version" href="#mime-version">MIME-Version</a></h3>
      <p id="rfc.section.19.4.1.p.1">HTTP is not a MIME-compliant protocol. However, HTTP/1.1 messages <em class="bcp14">MAY</em> include a single MIME-Version general-header field to indicate what version of the MIME protocol was used to construct the
         message. Use of the MIME-Version header field indicates that the message is in full compliance with the MIME protocol (as
         defined in RFC 2045<a href="#RFC2045" id="rfc.xref.RFC2045.5"><cite title="Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies">[RFC2045]</cite></a>). Proxies/gateways are responsible for ensuring full compliance (where possible) when exporting HTTP messages to strict MIME
         environments.
      </p>
      <div id="rfc.figure.u.156"></div><pre class="inline"><span id="rfc.iref.g.183"></span>    MIME-Version   = "MIME-Version" ":" 1*DIGIT "." 1*DIGIT
</pre><p id="rfc.section.19.4.1.p.3">MIME version "1.0" is the default for use in HTTP/1.1. However, HTTP/1.1 message parsing and semantics are defined by this
         document and not the MIME specification.
      </p>
      <h3 id="rfc.section.19.4.2"><a href="#rfc.section.19.4.2">19.4.2</a>&nbsp;<a id="conversion.to.canonical.form" href="#conversion.to.canonical.form">Conversion to Canonical Form</a></h3>
      <p id="rfc.section.19.4.2.p.1">RFC 2045 <a href="#RFC2045" id="rfc.xref.RFC2045.6"><cite title="Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies">[RFC2045]</cite></a> requires that an Internet mail entity be converted to canonical form prior to being transferred, as described in section <a href="http://tools.ietf.org/html/rfc2049#section-4" id="rfc.xref.RFC2049.1">4</a> of RFC 2049 <a href="#RFC2049" id="rfc.xref.RFC2049.2"><cite title="Multipurpose Internet Mail Extensions (MIME) Part Five: Conformance Criteria and Examples">[RFC2049]</cite></a>. <a href="#canonicalization.and.text.defaults" title="Canonicalization and Text Defaults">Section&nbsp;3.7.1</a> of this document describes the forms allowed for subtypes of the "text" media type when transmitted over HTTP. RFC 2046 requires
         that content with a type of "text" represent line breaks as CRLF and forbids the use of CR or LF outside of line break sequences.
         HTTP allows CRLF, bare CR, and bare LF to indicate a line break within text content when a message is transmitted over HTTP.
      </p>
      <p id="rfc.section.19.4.2.p.2">Where it is possible, a proxy or gateway from HTTP to a strict MIME environment <em class="bcp14">SHOULD</em> translate all line breaks within the text media types described in <a href="#canonicalization.and.text.defaults" title="Canonicalization and Text Defaults">Section&nbsp;3.7.1</a> of this document to the RFC 2049 canonical form of CRLF. Note, however, that this might be complicated by the presence of
         a Content-Encoding and by the fact that HTTP allows the use of some character sets which do not use octets 13 and 10 to represent
         CR and LF, as is the case for some multi-byte character sets.
      </p>
      <p id="rfc.section.19.4.2.p.3">Implementors should note that conversion will break any cryptographic checksums applied to the original content unless the
         original content is already in canonical form. Therefore, the canonical form is recommended for any content that uses such
         checksums in HTTP.
      </p>
      <h3 id="rfc.section.19.4.3"><a href="#rfc.section.19.4.3">19.4.3</a>&nbsp;<a id="conversion.of.date.formats" href="#conversion.of.date.formats">Conversion of Date Formats</a></h3>
      <p id="rfc.section.19.4.3.p.1">HTTP/1.1 uses a restricted set of date formats (<a href="#full.date" title="Full Date">Section&nbsp;3.3.1</a>) to simplify the process of date comparison. Proxies and gateways from other protocols <em class="bcp14">SHOULD</em> ensure that any Date header field present in a message conforms to one of the HTTP/1.1 formats and rewrite the date if necessary.
      </p>
      <h3 id="rfc.section.19.4.4"><a href="#rfc.section.19.4.4">19.4.4</a>&nbsp;<a id="introduction.of.content-encoding" href="#introduction.of.content-encoding">Introduction of Content-Encoding</a></h3>
      <p id="rfc.section.19.4.4.p.1">RFC 2045 does not include any concept equivalent to HTTP/1.1's Content-Encoding header field. Since this acts as a modifier
         on the media type, proxies and gateways from HTTP to MIME-compliant protocols <em class="bcp14">MUST</em> either change the value of the Content-Type header field or decode the entity-body before forwarding the message. (Some experimental
         applications of Content-Type for Internet mail have used a media-type parameter of ";conversions=&lt;content-coding&gt;" to perform
         a function equivalent to Content-Encoding. However, this parameter is not part of RFC 2045).
      </p>
      <h3 id="rfc.section.19.4.5"><a href="#rfc.section.19.4.5">19.4.5</a>&nbsp;<a id="no.content-transfer-encoding" href="#no.content-transfer-encoding">No Content-Transfer-Encoding</a></h3>
      <p id="rfc.section.19.4.5.p.1">HTTP does not use the Content-Transfer-Encoding (CTE) field of RFC 2045. Proxies and gateways from MIME-compliant protocols
         to HTTP <em class="bcp14">MUST</em> remove any non-identity CTE ("quoted-printable" or "base64") encoding prior to delivering the response message to an HTTP
         client.
      </p>
      <p id="rfc.section.19.4.5.p.2">Proxies and gateways from HTTP to MIME-compliant protocols are responsible for ensuring that the message is in the correct
         format and encoding for safe transport on that protocol, where "safe transport" is defined by the limitations of the protocol
         being used. Such a proxy or gateway <em class="bcp14">SHOULD</em> label the data with an appropriate Content-Transfer-Encoding if doing so will improve the likelihood of safe transport over
         the destination protocol.
      </p>
      <h3 id="rfc.section.19.4.6"><a href="#rfc.section.19.4.6">19.4.6</a>&nbsp;<a id="introduction.of.transfer-encoding" href="#introduction.of.transfer-encoding">Introduction of Transfer-Encoding</a></h3>
      <p id="rfc.section.19.4.6.p.1">HTTP/1.1 introduces the Transfer-Encoding header field (<a href="#header.transfer-encoding" id="rfc.xref.header.transfer-encoding.5" title="Transfer-Encoding">Section&nbsp;14.41</a>). Proxies/gateways <em class="bcp14">MUST</em> remove any transfer-coding prior to forwarding a message via a MIME-compliant protocol.
      </p>
      <p id="rfc.section.19.4.6.p.2">A process for decoding the "chunked" transfer-coding (<a href="#transfer.codings" title="Transfer Codings">Section&nbsp;3.6</a>) can be represented in pseudo-code as:
      </p>
      <div id="rfc.figure.u.157"></div><pre class="text">    length := 0
    read chunk-size, chunk-extension (if any) and CRLF
    while (chunk-size &gt; 0) {
       read chunk-data and CRLF
       append chunk-data to entity-body
       length := length + chunk-size
       read chunk-size and CRLF
    }
    read entity-header
    while (entity-header not empty) {
       append entity-header to existing header fields
       read entity-header
    }
    Content-Length := length
    Remove "chunked" from Transfer-Encoding
</pre><h3 id="rfc.section.19.4.7"><a href="#rfc.section.19.4.7">19.4.7</a>&nbsp;<a id="mhtml.line.length" href="#mhtml.line.length">MHTML and Line Length Limitations</a></h3>
      <p id="rfc.section.19.4.7.p.1">HTTP implementations which share code with MHTML <a href="#RFC2110" id="rfc.xref.RFC2110.1"><cite title="MIME E-mail Encapsulation of Aggregate Documents, such as HTML (MHTML)">[RFC2110]</cite></a> implementations need to be aware of MIME line length limitations. Since HTTP does not have this limitation, HTTP does not
         fold long lines. MHTML messages being transported by HTTP follow all conventions of MHTML, including line length limitations
         and folding, canonicalization, etc., since HTTP transports all message-bodies as payload (see <a href="#multipart.types" title="Multipart Types">Section&nbsp;3.7.2</a>) and does not interpret the content or any MIME header lines that might be contained therein.
      </p>
      <h2 id="rfc.section.19.5"><a href="#rfc.section.19.5">19.5</a>&nbsp;<a id="additional.features" href="#additional.features">Additional Features</a></h2>
      <p id="rfc.section.19.5.p.1">RFC 1945 and RFC 2068 document protocol elements used by some existing HTTP implementations, but not consistently and correctly
         across most HTTP/1.1 applications. Implementors are advised to be aware of these features, but cannot rely upon their presence
         in, or interoperability with, other HTTP/1.1 applications. Some of these describe proposed experimental features, and some
         describe features that experimental deployment found lacking that are now addressed in the base HTTP/1.1 specification.
      </p>
      <p id="rfc.section.19.5.p.2">A number of other headers, such as Content-Disposition and Title, from SMTP and MIME are also often implemented (see RFC 2076 <a href="#RFC2076" id="rfc.xref.RFC2076.1"><cite title="Common Internet Message Headers">[RFC2076]</cite></a>).
      </p>
      <div id="rfc.iref.h.51"></div>
      <div id="rfc.iref.c.30"></div>
      <h3 id="rfc.section.19.5.1"><a href="#rfc.section.19.5.1">19.5.1</a>&nbsp;<a id="content-disposition" href="#content-disposition">Content-Disposition</a></h3>
      <p id="rfc.section.19.5.1.p.1">The Content-Disposition response-header field has been proposed as a means for the origin server to suggest a default filename
         if the user requests that the content is saved to a file. This usage is derived from the definition of Content-Disposition
         in RFC 1806 <a href="#RFC1806" id="rfc.xref.RFC1806.2"><cite title="Communicating Presentation Information in Internet Messages: The Content-Disposition Header">[RFC1806]</cite></a>.
      </p>
      <div id="rfc.figure.u.158"></div><pre class="inline"><span id="rfc.iref.g.184"></span><span id="rfc.iref.g.185"></span><span id="rfc.iref.g.186"></span><span id="rfc.iref.g.187"></span><span id="rfc.iref.g.188"></span><span id="rfc.iref.g.189"></span>     content-disposition = "Content-Disposition" ":"
                           disposition-type *( ";" disposition-parm )
     disposition-type = "attachment" | disp-extension-token
     disposition-parm = filename-parm | disp-extension-parm
     filename-parm = "filename" "=" quoted-string
     disp-extension-token = token
     disp-extension-parm = token "=" ( token | quoted-string )
</pre><p id="rfc.section.19.5.1.p.3">An example is</p>
      <div id="rfc.figure.u.159"></div><pre class="text">     Content-Disposition: attachment; filename="fname.ext"
</pre><p id="rfc.section.19.5.1.p.5">The receiving user agent <em class="bcp14">SHOULD NOT</em> respect any directory path information present in the filename-parm parameter, which is the only parameter believed to apply
         to HTTP implementations at this time. The filename <em class="bcp14">SHOULD</em> be treated as a terminal component only.
      </p>
      <p id="rfc.section.19.5.1.p.6">If this header is used in a response with the application/octet-stream content-type, the implied suggestion is that the user
         agent should not display the response, but directly enter a `save response as...' dialog.
      </p>
      <p id="rfc.section.19.5.1.p.7">See <a href="#content-disposition.issues" title="Content-Disposition Issues">Section&nbsp;15.5</a> for Content-Disposition security issues.
      </p>
      <h2 id="rfc.section.19.6"><a href="#rfc.section.19.6">19.6</a>&nbsp;<a id="compatibility" href="#compatibility">Compatibility with Previous Versions</a></h2>
      <p id="rfc.section.19.6.p.1">It is beyond the scope of a protocol specification to mandate compliance with previous versions. HTTP/1.1 was deliberately
         designed, however, to make supporting previous versions easy. It is worth noting that, at the time of composing this specification
         (1996), we would expect commercial HTTP/1.1 servers to: 
      </p>
      <ul>
         <li>recognize the format of the Request-Line for HTTP/0.9, 1.0, and 1.1 requests;</li>
         <li>understand any valid request in the format of HTTP/0.9, 1.0, or 1.1;</li>
         <li>respond appropriately with a message in the same major version used by the client.</li>
      </ul>
      <p id="rfc.section.19.6.p.2">And we would expect HTTP/1.1 clients to: </p>
      <ul>
         <li>recognize the format of the Status-Line for HTTP/1.0 and 1.1 responses;</li>
         <li>understand any valid response in the format of HTTP/0.9, 1.0, or 1.1.</li>
      </ul>
      <p id="rfc.section.19.6.p.3">For most implementations of HTTP/1.0, each connection is established by the client prior to the request and closed by the
         server after sending the response. Some implementations implement the Keep-Alive version of persistent connections described
         in <a href="http://tools.ietf.org/html/rfc2068#section-19.7.1" id="rfc.xref.RFC2068.5">Section 19.7.1</a> of RFC 2068 <a href="#RFC2068" id="rfc.xref.RFC2068.6"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[RFC2068]</cite></a>.
      </p>
      <h3 id="rfc.section.19.6.1"><a href="#rfc.section.19.6.1">19.6.1</a>&nbsp;<a id="changes.from.1.0" href="#changes.from.1.0">Changes from HTTP/1.0</a></h3>
      <p id="rfc.section.19.6.1.p.1">This section summarizes major differences between versions HTTP/1.0 and HTTP/1.1.</p>
      <h4 id="rfc.section.19.6.1.1"><a href="#rfc.section.19.6.1.1">19.6.1.1</a>&nbsp;<a id="changes.to.simplify.multi-homed.web.servers.and.conserve.ip.addresses" href="#changes.to.simplify.multi-homed.web.servers.and.conserve.ip.addresses">Changes to Simplify Multi-homed Web Servers and Conserve IP Addresses</a></h4>
      <p id="rfc.section.19.6.1.1.p.1">The requirements that clients and servers support the Host request-header, report an error if the Host request-header (<a href="#header.host" id="rfc.xref.header.host.3" title="Host">Section&nbsp;14.23</a>) is missing from an HTTP/1.1 request, and accept absolute URIs (<a href="#request-uri" title="Request-URI">Section&nbsp;5.1.2</a>) are among the most important changes defined by this specification.
      </p>
      <p id="rfc.section.19.6.1.1.p.2">Older HTTP/1.0 clients assumed a one-to-one relationship of IP addresses and servers; there was no other established mechanism
         for distinguishing the intended server of a request than the IP address to which that request was directed. The changes outlined
         above will allow the Internet, once older HTTP clients are no longer common, to support multiple Web sites from a single IP
         address, greatly simplifying large operational Web servers, where allocation of many IP addresses to a single host has created
         serious problems. The Internet will also be able to recover the IP addresses that have been allocated for the sole purpose
         of allowing special-purpose domain names to be used in root-level HTTP URLs. Given the rate of growth of the Web, and the
         number of servers already deployed, it is extremely important that all implementations of HTTP (including updates to existing
         HTTP/1.0 applications) correctly implement these requirements: 
      </p>
      <ul>
         <li>Both clients and servers <em class="bcp14">MUST</em> support the Host request-header.
         </li>
         <li>A client that sends an HTTP/1.1 request <em class="bcp14">MUST</em> send a Host header.
         </li>
         <li>Servers <em class="bcp14">MUST</em> report a 400 (Bad Request) error if an HTTP/1.1 request does not include a Host request-header.
         </li>
         <li>Servers <em class="bcp14">MUST</em> accept absolute URIs.
         </li>
      </ul>
      <h3 id="rfc.section.19.6.2"><a href="#rfc.section.19.6.2">19.6.2</a>&nbsp;<a id="compatibility.with.http.1.0.persistent.connections" href="#compatibility.with.http.1.0.persistent.connections">Compatibility with HTTP/1.0 Persistent Connections</a></h3>
      <p id="rfc.section.19.6.2.p.1">Some clients and servers might wish to be compatible with some previous implementations of persistent connections in HTTP/1.0
         clients and servers. Persistent connections in HTTP/1.0 are explicitly negotiated as they are not the default behavior. HTTP/1.0
         experimental implementations of persistent connections are faulty, and the new facilities in HTTP/1.1 are designed to rectify
         these problems. The problem was that some existing 1.0 clients may be sending Keep-Alive to a proxy server that doesn't understand
         Connection, which would then erroneously forward it to the next inbound server, which would establish the Keep-Alive connection
         and result in a hung HTTP/1.0 proxy waiting for the close on the response. The result is that HTTP/1.0 clients must be prevented
         from using Keep-Alive when talking to proxies.
      </p>
      <p id="rfc.section.19.6.2.p.2">However, talking to proxies is the most important use of persistent connections, so that prohibition is clearly unacceptable.
         Therefore, we need some other mechanism for indicating a persistent connection is desired, which is safe to use even when
         talking to an old proxy that ignores Connection. Persistent connections are the default for HTTP/1.1 messages; we introduce
         a new keyword (Connection: close) for declaring non-persistence. See <a href="#header.connection" id="rfc.xref.header.connection.7" title="Connection">Section&nbsp;14.10</a>.
      </p>
      <p id="rfc.section.19.6.2.p.3">The original HTTP/1.0 form of persistent connections (the Connection: Keep-Alive and Keep-Alive header) is documented in RFC
         2068. <a href="#RFC2068" id="rfc.xref.RFC2068.7"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[RFC2068]</cite></a> 
      </p>
      <h3 id="rfc.section.19.6.3"><a href="#rfc.section.19.6.3">19.6.3</a>&nbsp;<a id="changes.from.rfc.2068" href="#changes.from.rfc.2068">Changes from RFC 2068</a></h3>
      <p id="rfc.section.19.6.3.p.1">This specification has been carefully audited to correct and disambiguate key word usage; RFC 2068 had many problems in respect
         to the conventions laid out in RFC 2119 <a href="#RFC2119" id="rfc.xref.RFC2119.2"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.
      </p>
      <p id="rfc.section.19.6.3.p.2">Clarified which error code should be used for inbound server failures (e.g. DNS failures). (<a href="#status.504" id="rfc.xref.status.504.2" title="504 Gateway Timeout">Section&nbsp;10.5.5</a>).
      </p>
      <p id="rfc.section.19.6.3.p.3">CREATE had a race that required an Etag be sent when a resource is first created. (<a href="#status.201" id="rfc.xref.status.201.2" title="201 Created">Section&nbsp;10.2.2</a>).
      </p>
      <p id="rfc.section.19.6.3.p.4">Content-Base was deleted from the specification: it was not implemented widely, and there is no simple, safe way to introduce
         it without a robust extension mechanism. In addition, it is used in a similar, but not identical fashion in MHTML <a href="#RFC2110" id="rfc.xref.RFC2110.2"><cite title="MIME E-mail Encapsulation of Aggregate Documents, such as HTML (MHTML)">[RFC2110]</cite></a>.
      </p>
      <p id="rfc.section.19.6.3.p.5">Transfer-coding and message lengths all interact in ways that required fixing exactly when chunked encoding is used (to allow
         for transfer encoding that may not be self delimiting); it was important to straighten out exactly how message lengths are
         computed. (Sections <a href="#transfer.codings" title="Transfer Codings">3.6</a>, <a href="#message.length" title="Message Length">4.4</a>, <a href="#entity.length" title="Entity Length">7.2.2</a>, <a href="#non-modifiable.headers" title="Non-modifiable Headers">13.5.2</a>, <a href="#header.content-length" id="rfc.xref.header.content-length.3" title="Content-Length">14.13</a>, <a href="#header.content-range" id="rfc.xref.header.content-range.6" title="Content-Range">14.16</a>)
      </p>
      <p id="rfc.section.19.6.3.p.6">A content-coding of "identity" was introduced, to solve problems discovered in caching. (<a href="#content.codings" title="Content Codings">Section&nbsp;3.5</a>)
      </p>
      <p id="rfc.section.19.6.3.p.7">Quality Values of zero should indicate that "I don't want something" to allow clients to refuse a representation. (<a href="#quality.values" title="Quality Values">Section&nbsp;3.9</a>)
      </p>
      <p id="rfc.section.19.6.3.p.8">The use and interpretation of HTTP version numbers has been clarified by RFC 2145. Require proxies to upgrade requests to
         highest protocol version they support to deal with problems discovered in HTTP/1.0 implementations (<a href="#http.version" title="HTTP Version">Section&nbsp;3.1</a>)
      </p>
      <p id="rfc.section.19.6.3.p.9">Charset wildcarding is introduced to avoid explosion of character set names in accept headers. (<a href="#header.accept-charset" id="rfc.xref.header.accept-charset.3" title="Accept-Charset">Section&nbsp;14.2</a>)
      </p>
      <p id="rfc.section.19.6.3.p.10">A case was missed in the Cache-Control model of HTTP/1.1; s-maxage was introduced to add this missing case. (Sections <a href="#response.cacheability" title="Response Cacheability">13.4</a>, <a href="#header.authorization" id="rfc.xref.header.authorization.5" title="Authorization">14.8</a>, <a href="#header.cache-control" id="rfc.xref.header.cache-control.12" title="Cache-Control">14.9</a>, <a href="#modifications.of.the.basic.expiration.mechanism" title="Modifications of the Basic Expiration Mechanism">14.9.3</a>)
      </p>
      <p id="rfc.section.19.6.3.p.11">The Cache-Control: max-age directive was not properly defined for responses. (<a href="#modifications.of.the.basic.expiration.mechanism" title="Modifications of the Basic Expiration Mechanism">Section&nbsp;14.9.3</a>)
      </p>
      <p id="rfc.section.19.6.3.p.12">There are situations where a server (especially a proxy) does not know the full length of a response but is capable of serving
         a byterange request. We therefore need a mechanism to allow byteranges with a content-range not indicating the full length
         of the message. (<a href="#header.content-range" id="rfc.xref.header.content-range.7" title="Content-Range">Section&nbsp;14.16</a>)
      </p>
      <p id="rfc.section.19.6.3.p.13">Range request responses would become very verbose if all meta-data were always returned; by allowing the server to only send
         needed headers in a 206 response, this problem can be avoided. (Section <a href="#status.206" id="rfc.xref.status.206.2" title="206 Partial Content">10.2.7</a>, <a href="#combining.headers" title="Combining Headers">13.5.3</a>, and <a href="#header.if-range" id="rfc.xref.header.if-range.5" title="If-Range">14.27</a>)
      </p>
      <p id="rfc.section.19.6.3.p.14">Fix problem with unsatisfiable range requests; there are two cases: syntactic problems, and range doesn't exist in the document.
         The 416 status code was needed to resolve this ambiguity needed to indicate an error for a byte range request that falls outside
         of the actual contents of a document. (Section <a href="#status.416" id="rfc.xref.status.416.3" title="416 Requested Range Not Satisfiable">10.4.17</a>, <a href="#header.content-range" id="rfc.xref.header.content-range.8" title="Content-Range">14.16</a>)
      </p>
      <p id="rfc.section.19.6.3.p.15">Rewrite of message transmission requirements to make it much harder for implementors to get it wrong, as the consequences
         of errors here can have significant impact on the Internet, and to deal with the following problems: 
      </p>
      <ol>
         <li>Changing "HTTP/1.1 or later" to "HTTP/1.1", in contexts where this was incorrectly placing a requirement on the behavior of
            an implementation of a future version of HTTP/1.x
         </li>
         <li>Made it clear that user-agents should retry requests, not "clients" in general.</li>
         <li>Converted requirements for clients to ignore unexpected 100 (Continue) responses, and for proxies to forward 100 responses,
            into a general requirement for 1xx responses.
         </li>
         <li>Modified some TCP-specific language, to make it clearer that non-TCP transports are possible for HTTP.</li>
         <li>Require that the origin server <em class="bcp14">MUST NOT</em> wait for the request body before it sends a required 100 (Continue) response.
         </li>
         <li>Allow, rather than require, a server to omit 100 (Continue) if it has already seen some of the request body.</li>
         <li>Allow servers to defend against denial-of-service attacks and broken clients.</li>
      </ol>
      <p id="rfc.section.19.6.3.p.16">This change adds the Expect header and 417 status code. The message transmission requirements fixes are in sections <a href="#message.transmission.requirements" title="Message Transmission Requirements">8.2</a>, <a href="#status.417" id="rfc.xref.status.417.2" title="417 Expectation Failed">10.4.18</a>, <a href="#pipelining" title="Pipelining">8.1.2.2</a>, <a href="#write-through.mandatory" title="Write-Through Mandatory">13.11</a>, and <a href="#header.expect" id="rfc.xref.header.expect.5" title="Expect">14.20</a>.
      </p>
      <p id="rfc.section.19.6.3.p.17">Proxies should be able to add Content-Length when appropriate. (<a href="#non-modifiable.headers" title="Non-modifiable Headers">Section&nbsp;13.5.2</a>)
      </p>
      <p id="rfc.section.19.6.3.p.18">Clean up confusion between 403 and 404 responses. (Section <a href="#status.403" id="rfc.xref.status.403.2" title="403 Forbidden">10.4.4</a>, <a href="#status.404" id="rfc.xref.status.404.2" title="404 Not Found">10.4.5</a>, and <a href="#status.410" id="rfc.xref.status.410.2" title="410 Gone">10.4.11</a>)
      </p>
      <p id="rfc.section.19.6.3.p.19">Warnings could be cached incorrectly, or not updated appropriately. (Section <a href="#warnings" title="Warnings">13.1.2</a>, <a href="#expiration.calculations" title="Expiration Calculations">13.2.4</a>, <a href="#non-modifiable.headers" title="Non-modifiable Headers">13.5.2</a>, <a href="#combining.headers" title="Combining Headers">13.5.3</a>, <a href="#modifications.of.the.basic.expiration.mechanism" title="Modifications of the Basic Expiration Mechanism">14.9.3</a>, and <a href="#header.warning" id="rfc.xref.header.warning.7" title="Warning">14.46</a>) Warning also needed to be a general header, as PUT or other methods may have need for it in requests.
      </p>
      <p id="rfc.section.19.6.3.p.20">Transfer-coding had significant problems, particularly with interactions with chunked encoding. The solution is that transfer-codings
         become as full fledged as content-codings. This involves adding an IANA registry for transfer-codings (separate from content
         codings), a new header field (TE) and enabling trailer headers in the future. Transfer encoding is a major performance benefit,
         so it was worth fixing <a href="#Nie1997" id="rfc.xref.Nie1997.2"><cite title="Network Performance Effects of HTTP/1.1, CSS1, and PNG">[Nie1997]</cite></a>. TE also solves another, obscure, downward interoperability problem that could have occurred due to interactions between
         authentication trailers, chunked encoding and HTTP/1.0 clients.(Section <a href="#transfer.codings" title="Transfer Codings">3.6</a>, <a href="#chunked.transfer.encoding" title="Chunked Transfer Coding">3.6.1</a>, and <a href="#header.te" id="rfc.xref.header.te.4" title="TE">14.39</a>)
      </p>
      <p id="rfc.section.19.6.3.p.21">The PATCH<span id="rfc.iref.p.10"></span><span id="rfc.iref.m.23"></span>, LINK<span id="rfc.iref.l.3"></span><span id="rfc.iref.m.24"></span>, UNLINK<span id="rfc.iref.u.5"></span><span id="rfc.iref.m.25"></span> methods were defined but not commonly implemented in previous versions of this specification. See RFC 2068 <a href="#RFC2068" id="rfc.xref.RFC2068.8"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[RFC2068]</cite></a>.
      </p>
      <p id="rfc.section.19.6.3.p.22">The Alternates<span id="rfc.iref.a.11"></span><span id="rfc.iref.h.52"></span>, Content-Version<span id="rfc.iref.c.31"></span><span id="rfc.iref.h.53"></span>, Derived-From<span id="rfc.iref.d.5"></span><span id="rfc.iref.h.54"></span>, Link<span id="rfc.iref.l.4"></span><span id="rfc.iref.h.55"></span>, URI<span id="rfc.iref.u.6"></span><span id="rfc.iref.h.56"></span>, Public<span id="rfc.iref.p.11"></span><span id="rfc.iref.h.57"></span> and Content-Base<span id="rfc.iref.c.32"></span><span id="rfc.iref.h.58"></span> header fields were defined in previous versions of this specification, but not commonly implemented. See RFC 2068 <a href="#RFC2068" id="rfc.xref.RFC2068.9"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[RFC2068]</cite></a>.
      </p>
      <h1 id="rfc.section.20"><a href="#rfc.section.20">20.</a>&nbsp;Index
      </h1>
      <p id="rfc.section.20.p.1">Please see the PostScript version of this RFC for the INDEX.</p>
      <h1><a id="rfc.copyright" href="#rfc.copyright">Full Copyright Statement</a></h1>
      <p>Copyright © The Internet Society (1999).</p>
      <p>This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the
         authors retain all their rights.
      </p>
      <p>This document and the information contained herein are provided on an “AS IS” basis and THE CONTRIBUTOR, THE ORGANIZATION
         HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
         EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY
         RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
      </p>
      <h1><a id="rfc.ipr" href="#rfc.ipr">Intellectual Property</a></h1>
      <p>The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might
         be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any
         license under such rights might or might not be available; nor does it represent that it has made any independent effort to
         identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and
         BCP 79.
      </p>
      <p>Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result
         of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users
         of this specification can be obtained from the IETF on-line IPR repository at &lt;<a href="http://www.ietf.org/ipr">http://www.ietf.org/ipr</a>&gt;.
      </p>
      <p>The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary
         rights that may cover technology that may be required to implement this standard. Please address the information to the IETF
         at <a href="mailto:ietf-ipr@ietf.org">ietf-ipr@ietf.org</a>.
      </p>
      <h1>Acknowledgement</h1>
      <p>Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).</p>
      <h1 id="rfc.index"><a href="#rfc.index">Index</a></h1>
      <p class="noprint"><a href="#rfc.index.1">1</a> <a href="#rfc.index.2">2</a> <a href="#rfc.index.3">3</a> <a href="#rfc.index.4">4</a> <a href="#rfc.index.5">5</a> <a href="#rfc.index.A">A</a> <a href="#rfc.index.C">C</a> <a href="#rfc.index.D">D</a> <a href="#rfc.index.E">E</a> <a href="#rfc.index.F">F</a> <a href="#rfc.index.G">G</a> <a href="#rfc.index.H">H</a> <a href="#rfc.index.I">I</a> <a href="#rfc.index.L">L</a> <a href="#rfc.index.M">M</a> <a href="#rfc.index.N">N</a> <a href="#rfc.index.O">O</a> <a href="#rfc.index.P">P</a> <a href="#rfc.index.R">R</a> <a href="#rfc.index.S">S</a> <a href="#rfc.index.T">T</a> <a href="#rfc.index.U">U</a> <a href="#rfc.index.V">V</a> <a href="#rfc.index.W">W</a> 
      </p>
      <div class="print2col">
         <ul class="ind">
            <li class="indline0"><a id="rfc.index.1" href="#rfc.index.1"><b>1</b></a><ul class="ind">
                  <li class="indline1">100 Continue (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.100.1">6.1.1</a>, <a class="iref" href="#rfc.xref.status.100.2">8.2.3</a>, <a class="iref" href="#rfc.iref.142"><b>10.1.1</b></a></li>
                  <li class="indline1">101 Switching Protocols (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.101.1">6.1.1</a>, <a class="iref" href="#rfc.iref.143"><b>10.1.2</b></a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.2" href="#rfc.index.2"><b>2</b></a><ul class="ind">
                  <li class="indline1">200 OK (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.200.1">6.1.1</a>, <a class="iref" href="#rfc.iref.144"><b>10.2.1</b></a></li>
                  <li class="indline1">201 Created (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.201.1">6.1.1</a>, <a class="iref" href="#rfc.iref.145"><b>10.2.2</b></a>, <a class="iref" href="#rfc.xref.status.201.2">19.6.3</a></li>
                  <li class="indline1">202 Accepted (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.202.1">6.1.1</a>, <a class="iref" href="#rfc.iref.146"><b>10.2.3</b></a></li>
                  <li class="indline1">203 Non-Authoritative Information (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.203.1">6.1.1</a>, <a class="iref" href="#rfc.iref.147"><b>10.2.4</b></a></li>
                  <li class="indline1">204 No Content (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.204.1">6.1.1</a>, <a class="iref" href="#rfc.iref.148"><b>10.2.5</b></a></li>
                  <li class="indline1">205 Reset Content (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.205.1">6.1.1</a>, <a class="iref" href="#rfc.iref.149"><b>10.2.6</b></a></li>
                  <li class="indline1">206 Partial Content (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.206.1">6.1.1</a>, <a class="iref" href="#rfc.iref.150"><b>10.2.7</b></a>, <a class="iref" href="#rfc.xref.status.206.2">19.6.3</a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.3" href="#rfc.index.3"><b>3</b></a><ul class="ind">
                  <li class="indline1">300 Multiple Choices (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.300.1">6.1.1</a>, <a class="iref" href="#rfc.iref.151"><b>10.3.1</b></a></li>
                  <li class="indline1">301 Moved Permanently (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.301.1">6.1.1</a>, <a class="iref" href="#rfc.iref.152"><b>10.3.2</b></a></li>
                  <li class="indline1">302 Found (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.302.1">6.1.1</a>, <a class="iref" href="#rfc.iref.153"><b>10.3.3</b></a></li>
                  <li class="indline1">303 See Other (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.303.1">6.1.1</a>, <a class="iref" href="#rfc.iref.154"><b>10.3.4</b></a></li>
                  <li class="indline1">304 Not Modified (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.304.1">6.1.1</a>, <a class="iref" href="#rfc.iref.155"><b>10.3.5</b></a></li>
                  <li class="indline1">305 Use Proxy (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.305.1">6.1.1</a>, <a class="iref" href="#rfc.iref.156"><b>10.3.6</b></a></li>
                  <li class="indline1">306 (Unused) (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.iref.157"><b>10.3.7</b></a></li>
                  <li class="indline1">307 Temporary Redirect (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.307.1">6.1.1</a>, <a class="iref" href="#rfc.iref.158"><b>10.3.8</b></a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.4" href="#rfc.index.4"><b>4</b></a><ul class="ind">
                  <li class="indline1">400 Bad Request (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.400.1">6.1.1</a>, <a class="iref" href="#rfc.iref.159"><b>10.4.1</b></a></li>
                  <li class="indline1">401 Unauthorized (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.401.1">6.1.1</a>, <a class="iref" href="#rfc.iref.160"><b>10.4.2</b></a></li>
                  <li class="indline1">402 Payment Required (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.402.1">6.1.1</a>, <a class="iref" href="#rfc.iref.161"><b>10.4.3</b></a></li>
                  <li class="indline1">403 Forbidden (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.403.1">6.1.1</a>, <a class="iref" href="#rfc.iref.162"><b>10.4.4</b></a>, <a class="iref" href="#rfc.xref.status.403.2">19.6.3</a></li>
                  <li class="indline1">404 Not Found (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.404.1">6.1.1</a>, <a class="iref" href="#rfc.iref.163"><b>10.4.5</b></a>, <a class="iref" href="#rfc.xref.status.404.2">19.6.3</a></li>
                  <li class="indline1">405 Method Not Allowed (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.405.1">6.1.1</a>, <a class="iref" href="#rfc.iref.164"><b>10.4.6</b></a></li>
                  <li class="indline1">406 Not Acceptable (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.406.1">6.1.1</a>, <a class="iref" href="#rfc.iref.165"><b>10.4.7</b></a></li>
                  <li class="indline1">407 Proxy Authentication Required (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.407.1">6.1.1</a>, <a class="iref" href="#rfc.iref.166"><b>10.4.8</b></a></li>
                  <li class="indline1">408 Request Timeout (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.408.1">6.1.1</a>, <a class="iref" href="#rfc.iref.167"><b>10.4.9</b></a></li>
                  <li class="indline1">409 Conflict (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.409.1">6.1.1</a>, <a class="iref" href="#rfc.iref.168"><b>10.4.10</b></a></li>
                  <li class="indline1">410 Gone (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.410.1">6.1.1</a>, <a class="iref" href="#rfc.iref.169"><b>10.4.11</b></a>, <a class="iref" href="#rfc.xref.status.410.2">19.6.3</a></li>
                  <li class="indline1">411 Length Required (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.411.1">6.1.1</a>, <a class="iref" href="#rfc.iref.170"><b>10.4.12</b></a></li>
                  <li class="indline1">412 Precondition Failed (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.412.1">6.1.1</a>, <a class="iref" href="#rfc.iref.171"><b>10.4.13</b></a></li>
                  <li class="indline1">413 Request Entity Too Large (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.413.1">6.1.1</a>, <a class="iref" href="#rfc.iref.172"><b>10.4.14</b></a></li>
                  <li class="indline1">414 Request-URI Too Long (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.414.1">3.2.1</a>, <a class="iref" href="#rfc.xref.status.414.2">6.1.1</a>, <a class="iref" href="#rfc.iref.173"><b>10.4.15</b></a></li>
                  <li class="indline1">415 Unsupported Media Type (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.415.1">6.1.1</a>, <a class="iref" href="#rfc.iref.174"><b>10.4.16</b></a></li>
                  <li class="indline1">416 Requested Range Not Satisfiable (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.416.1">6.1.1</a>, <a class="iref" href="#rfc.iref.175"><b>10.4.17</b></a>, <a class="iref" href="#rfc.xref.status.416.2">14.16</a>, <a class="iref" href="#rfc.xref.status.416.3">19.6.3</a></li>
                  <li class="indline1">417 Expectation Failed (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.417.1">6.1.1</a>, <a class="iref" href="#rfc.iref.176"><b>10.4.18</b></a>, <a class="iref" href="#rfc.xref.status.417.2">19.6.3</a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.5" href="#rfc.index.5"><b>5</b></a><ul class="ind">
                  <li class="indline1">500 Internal Server Error (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.500.1">6.1.1</a>, <a class="iref" href="#rfc.iref.177"><b>10.5.1</b></a></li>
                  <li class="indline1">501 Not Implemented (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.501.1">6.1.1</a>, <a class="iref" href="#rfc.iref.178"><b>10.5.2</b></a></li>
                  <li class="indline1">502 Bad Gateway (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.502.1">6.1.1</a>, <a class="iref" href="#rfc.iref.179"><b>10.5.3</b></a></li>
                  <li class="indline1">503 Service Unavailable (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.503.1">6.1.1</a>, <a class="iref" href="#rfc.iref.180"><b>10.5.4</b></a></li>
                  <li class="indline1">504 Gateway Timeout (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.504.1">6.1.1</a>, <a class="iref" href="#rfc.iref.181"><b>10.5.5</b></a>, <a class="iref" href="#rfc.xref.status.504.2">19.6.3</a></li>
                  <li class="indline1">505 HTTP Version Not Supported (status code)&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.505.1">6.1.1</a>, <a class="iref" href="#rfc.iref.182"><b>10.5.6</b></a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.A" href="#rfc.index.A"><b>A</b></a><ul class="ind">
                  <li class="indline1">Accept header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.accept.1">3.7</a>, <a class="iref" href="#rfc.xref.header.accept.2">5.3</a>, <a class="iref" href="#rfc.xref.header.accept.3">12.1</a>, <a class="iref" href="#rfc.iref.a.2"><b>14.1</b></a></li>
                  <li class="indline1">Accept-Charset header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.accept-charset.1">5.3</a>, <a class="iref" href="#rfc.xref.header.accept-charset.2">12.1</a>, <a class="iref" href="#rfc.iref.a.3"><b>14.2</b></a>, <a class="iref" href="#rfc.xref.header.accept-charset.3">19.6.3</a></li>
                  <li class="indline1">Accept-Encoding header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.accept-encoding.1">3.5</a>, <a class="iref" href="#rfc.xref.header.accept-encoding.2">5.3</a>, <a class="iref" href="#rfc.xref.header.accept-encoding.3">12.1</a>, <a class="iref" href="#rfc.iref.a.4"><b>14.3</b></a></li>
                  <li class="indline1">Accept-Language header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.accept-language.1">5.3</a>, <a class="iref" href="#rfc.xref.header.accept-language.2">12.1</a>, <a class="iref" href="#rfc.iref.a.5"><b>14.4</b></a></li>
                  <li class="indline1">Accept-Ranges header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.accept-ranges.1">6.2</a>, <a class="iref" href="#rfc.iref.a.6"><b>14.5</b></a></li>
                  <li class="indline1">age&nbsp;&nbsp;<a class="iref" href="#rfc.iref.a.1">1.3</a></li>
                  <li class="indline1">Age header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.age.1">6.2</a>, <a class="iref" href="#rfc.iref.a.7"><b>14.6</b></a></li>
                  <li class="indline1">Allow header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.allow.1">5.1.1</a>, <a class="iref" href="#rfc.xref.header.allow.2">7.1</a>, <a class="iref" href="#rfc.iref.a.8"><b>14.7</b></a></li>
                  <li class="indline1">Alternates header&nbsp;&nbsp;<a class="iref" href="#rfc.iref.a.11"><b>19.6.3</b></a></li>
                  <li class="indline1">application/http Media Type&nbsp;&nbsp;<a class="iref" href="#rfc.iref.a.10"><b>19.1</b></a></li>
                  <li class="indline1">Authorization header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.authorization.1">5.3</a>, <a class="iref" href="#rfc.xref.header.authorization.2">10.4.2</a>, <a class="iref" href="#rfc.xref.header.authorization.3">13.4</a>, <a class="iref" href="#rfc.iref.a.9"><b>14.8</b></a>, <a class="iref" href="#rfc.xref.header.authorization.4">14.9.1</a>, <a class="iref" href="#rfc.xref.header.authorization.5">19.6.3</a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.C" href="#rfc.index.C"><b>C</b></a><ul class="ind">
                  <li class="indline1">cache&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.4">1.3</a></li>
                  <li class="indline1">Cache Directives&nbsp;&nbsp;
                     <ul class="ind">
                        <li class="indline1">max-age&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.14"><b>14.9.3</b></a>, <a class="iref" href="#rfc.iref.c.17"><b>14.9.4</b></a></li>
                        <li class="indline1">max-stale&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.16"><b>14.9.3</b></a></li>
                        <li class="indline1">min-fresh&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.15"><b>14.9.3</b></a></li>
                        <li class="indline1">must-revalidate&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.19"><b>14.9.4</b></a></li>
                        <li class="indline1">no-cache&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.11"><b>14.9.1</b></a></li>
                        <li class="indline1">no-store&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.12"><b>14.9.2</b></a></li>
                        <li class="indline1">no-transform&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.21"><b>14.9.5</b></a></li>
                        <li class="indline1">only-if-cached&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.18"><b>14.9.4</b></a></li>
                        <li class="indline1">private&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.10"><b>14.9.1</b></a></li>
                        <li class="indline1">proxy-revalidate&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.20"><b>14.9.4</b></a></li>
                        <li class="indline1">public&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.9"><b>14.9.1</b></a></li>
                        <li class="indline1">s-maxage&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.13"><b>14.9.3</b></a></li>
                     </ul>
                  </li>
                  <li class="indline1">Cache-Control header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.cache-control.1">4.5</a>, <a class="iref" href="#rfc.xref.header.cache-control.2">13.1.1</a>, <a class="iref" href="#rfc.xref.header.cache-control.3">13.1.1</a>, <a class="iref" href="#rfc.xref.header.cache-control.4">13.1.3</a>, <a class="iref" href="#rfc.xref.header.cache-control.5">13.2.1</a>, <a class="iref" href="#rfc.xref.header.cache-control.6">13.2.5</a>, <a class="iref" href="#rfc.xref.header.cache-control.7">13.4</a>, <a class="iref" href="#rfc.xref.header.cache-control.8">13.4</a>, <a class="iref" href="#rfc.xref.header.cache-control.9">13.8</a>, <a class="iref" href="#rfc.iref.c.8"><b>14.9</b></a>, <a class="iref" href="#rfc.xref.header.cache-control.10">14.21</a>, <a class="iref" href="#rfc.xref.header.cache-control.11">14.32</a>, <a class="iref" href="#rfc.xref.header.cache-control.12">19.6.3</a></li>
                  <li class="indline1">cacheable&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.5">1.3</a></li>
                  <li class="indline1">client&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.3">1.3</a></li>
                  <li class="indline1">compress&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.6">3.5</a></li>
                  <li class="indline1">CONNECT method&nbsp;&nbsp;<a class="iref" href="#rfc.xref.CONNECT.1">5.1.1</a>, <a class="iref" href="#rfc.xref.CONNECT.2">5.1.2</a>, <a class="iref" href="#rfc.iref.c.7"><b>9.9</b></a></li>
                  <li class="indline1">connection&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.1">1.3</a></li>
                  <li class="indline1">Connection header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.connection.1">4.5</a>, <a class="iref" href="#rfc.xref.header.connection.2">8.1.2</a>, <a class="iref" href="#rfc.xref.header.connection.3">8.1.3</a>, <a class="iref" href="#rfc.xref.header.connection.4">13.5.1</a>, <a class="iref" href="#rfc.iref.c.22"><b>14.10</b></a>, <a class="iref" href="#rfc.xref.header.connection.5">14.39</a>, <a class="iref" href="#rfc.xref.header.connection.6">14.42</a>, <a class="iref" href="#rfc.xref.header.connection.7">19.6.2</a></li>
                  <li class="indline1">content negotiation&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.2">1.3</a></li>
                  <li class="indline1">Content-Base header&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.32"><b>19.6.3</b></a></li>
                  <li class="indline1">Content-Disposition header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.content-disposition.1">15.5</a>, <a class="iref" href="#rfc.iref.c.30"><b>19.5.1</b></a></li>
                  <li class="indline1">Content-Encoding header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.content-encoding.1">3.5</a>, <a class="iref" href="#rfc.xref.header.content-encoding.2">7.1</a>, <a class="iref" href="#rfc.iref.c.23"><b>14.11</b></a>, <a class="iref" href="#rfc.xref.header.content-encoding.3">14.11</a></li>
                  <li class="indline1">Content-Language header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.content-language.1">7.1</a>, <a class="iref" href="#rfc.iref.c.24"><b>14.12</b></a></li>
                  <li class="indline1">Content-Length header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.content-length.1">4.4</a>, <a class="iref" href="#rfc.xref.header.content-length.2">7.1</a>, <a class="iref" href="#rfc.iref.c.25"><b>14.13</b></a>, <a class="iref" href="#rfc.xref.header.content-length.3">19.6.3</a></li>
                  <li class="indline1">Content-Location header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.content-location.1">7.1</a>, <a class="iref" href="#rfc.iref.c.26"><b>14.14</b></a>, <a class="iref" href="#rfc.xref.header.content-location.2">14.30</a></li>
                  <li class="indline1">Content-MD5 header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.content-md5.1">7.1</a>, <a class="iref" href="#rfc.iref.c.27"><b>14.15</b></a></li>
                  <li class="indline1">Content-Range header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.content-range.1">3.7.2</a>, <a class="iref" href="#rfc.xref.header.content-range.2">3.12</a>, <a class="iref" href="#rfc.xref.header.content-range.3">7.1</a>, <a class="iref" href="#rfc.xref.header.content-range.4">10.2.7</a>, <a class="iref" href="#rfc.xref.header.content-range.5">10.4.17</a>, <a class="iref" href="#rfc.iref.c.28"><b>14.16</b></a>, <a class="iref" href="#rfc.xref.header.content-range.6">19.6.3</a>, <a class="iref" href="#rfc.xref.header.content-range.7">19.6.3</a>, <a class="iref" href="#rfc.xref.header.content-range.8">19.6.3</a></li>
                  <li class="indline1">Content-Type header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.content-type.1">3.7</a>, <a class="iref" href="#rfc.xref.header.content-type.2">7.1</a>, <a class="iref" href="#rfc.iref.c.29"><b>14.17</b></a></li>
                  <li class="indline1">Content-Version header&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.31"><b>19.6.3</b></a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.D" href="#rfc.index.D"><b>D</b></a><ul class="ind">
                  <li class="indline1">Date header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.date.1">4.5</a>, <a class="iref" href="#rfc.xref.header.date.2">13.2.3</a>, <a class="iref" href="#rfc.iref.d.4"><b>14.18</b></a></li>
                  <li class="indline1">deflate&nbsp;&nbsp;<a class="iref" href="#rfc.iref.d.2">3.5</a></li>
                  <li class="indline1">DELETE method&nbsp;&nbsp;<a class="iref" href="#rfc.xref.DELETE.1">5.1.1</a>, <a class="iref" href="#rfc.iref.d.3"><b>9.7</b></a></li>
                  <li class="indline1">Derived-From header&nbsp;&nbsp;<a class="iref" href="#rfc.iref.d.5"><b>19.6.3</b></a></li>
                  <li class="indline1">downstream&nbsp;&nbsp;<a class="iref" href="#rfc.iref.d.1">1.3</a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.E" href="#rfc.index.E"><b>E</b></a><ul class="ind">
                  <li class="indline1">entity&nbsp;&nbsp;<a class="iref" href="#rfc.iref.e.1">1.3</a></li>
                  <li class="indline1">ETag header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.etag.1">3.11</a>, <a class="iref" href="#rfc.xref.header.etag.2">6.2</a>, <a class="iref" href="#rfc.xref.header.etag.3">10.2.2</a>, <a class="iref" href="#rfc.xref.header.etag.4">13.3.2</a>, <a class="iref" href="#rfc.iref.e.3"><b>14.19</b></a></li>
                  <li class="indline1">Expect header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.expect.1">5.3</a>, <a class="iref" href="#rfc.xref.header.expect.2">8.2.3</a>, <a class="iref" href="#rfc.xref.header.expect.3">8.2.3</a>, <a class="iref" href="#rfc.xref.header.expect.4">10.4.18</a>, <a class="iref" href="#rfc.iref.e.4"><b>14.20</b></a>, <a class="iref" href="#rfc.xref.header.expect.5">19.6.3</a></li>
                  <li class="indline1">Expires header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.expires.1">7.1</a>, <a class="iref" href="#rfc.xref.header.expires.2">13.4</a>, <a class="iref" href="#rfc.xref.header.expires.3">14.9.3</a>, <a class="iref" href="#rfc.iref.e.5"><b>14.21</b></a></li>
                  <li class="indline1">explicit expiration time&nbsp;&nbsp;<a class="iref" href="#rfc.iref.e.2">1.3</a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.F" href="#rfc.index.F"><b>F</b></a><ul class="ind">
                  <li class="indline1">first-hand&nbsp;&nbsp;<a class="iref" href="#rfc.iref.f.1">1.3</a></li>
                  <li class="indline1">fresh&nbsp;&nbsp;<a class="iref" href="#rfc.iref.f.3">1.3</a></li>
                  <li class="indline1">freshness lifetime&nbsp;&nbsp;<a class="iref" href="#rfc.iref.f.2">1.3</a></li>
                  <li class="indline1">From header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.from.1">5.3</a>, <a class="iref" href="#rfc.iref.f.4"><b>14.22</b></a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.G" href="#rfc.index.G"><b>G</b></a><ul class="ind">
                  <li class="indline1">gateway&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.1">1.3</a></li>
                  <li class="indline1">GET method&nbsp;&nbsp;<a class="iref" href="#rfc.xref.GET.1">5.1.1</a>, <a class="iref" href="#rfc.iref.g.94"><b>9.3</b></a></li>
                  <li class="indline1"><tt>Grammar</tt>&nbsp;&nbsp;
                     <ul class="ind">
                        <li class="indline1"><tt>Accept</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.95"><b>14.1</b></a></li>
                        <li class="indline1"><tt>Accept-Charset</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.99"><b>14.2</b></a></li>
                        <li class="indline1"><tt>Accept-Encoding</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.100"><b>14.3</b></a></li>
                        <li class="indline1"><tt>accept-extension</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.98"><b>14.1</b></a></li>
                        <li class="indline1"><tt>Accept-Language</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.102"><b>14.4</b></a></li>
                        <li class="indline1"><tt>accept-params</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.97"><b>14.1</b></a></li>
                        <li class="indline1"><tt>Accept-Ranges</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.104"><b>14.5</b></a></li>
                        <li class="indline1"><tt>acceptable-ranges</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.105"><b>14.5</b></a></li>
                        <li class="indline1"><tt>Age</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.106"><b>14.6</b></a></li>
                        <li class="indline1"><tt>age-value</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.107"><b>14.6</b></a></li>
                        <li class="indline1"><tt>Allow</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.108"><b>14.7</b></a></li>
                        <li class="indline1"><tt>ALPHA</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.6"><b>2.2</b></a></li>
                        <li class="indline1"><tt>asctime-date</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.29"><b>3.3.1</b></a></li>
                        <li class="indline1"><tt>attribute</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.44"><b>3.6</b></a></li>
                        <li class="indline1"><tt>Authorization</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.109"><b>14.8</b></a></li>
                        <li class="indline1"><tt>byte-content-range-spec</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.125"><b>14.16</b></a></li>
                        <li class="indline1"><tt>byte-range-resp-spec</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.126"><b>14.16</b></a></li>
                        <li class="indline1"><tt>byte-range-set</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.153"><b>14.35.1</b></a></li>
                        <li class="indline1"><tt>byte-range-spec</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.154"><b>14.35.1</b></a></li>
                        <li class="indline1"><tt>byte-ranges-specifier</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.152"><b>14.35.1</b></a></li>
                        <li class="indline1"><tt>bytes-unit</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.68"><b>3.12</b></a></li>
                        <li class="indline1"><tt>Cache-Control</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.110"><b>14.9</b></a></li>
                        <li class="indline1"><tt>cache-directive</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.111"><b>14.9</b></a></li>
                        <li class="indline1"><tt>cache-extension</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.114"><b>14.9</b></a></li>
                        <li class="indline1"><tt>cache-request-directive</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.112"><b>14.9</b></a></li>
                        <li class="indline1"><tt>cache-response-directive</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.113"><b>14.9</b></a></li>
                        <li class="indline1"><tt>CHAR</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.3"><b>2.2</b></a></li>
                        <li class="indline1"><tt>charset</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.38"><b>3.4</b></a></li>
                        <li class="indline1"><tt>chunk</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.47"><b>3.6.1</b></a></li>
                        <li class="indline1"><tt>chunk-data</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.53"><b>3.6.1</b></a></li>
                        <li class="indline1"><tt>chunk-ext-name</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.51"><b>3.6.1</b></a></li>
                        <li class="indline1"><tt>chunk-ext-val</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.52"><b>3.6.1</b></a></li>
                        <li class="indline1"><tt>chunk-extension</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.50"><b>3.6.1</b></a></li>
                        <li class="indline1"><tt>chunk-size</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.48"><b>3.6.1</b></a></li>
                        <li class="indline1"><tt>Chunked-Body</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.46"><b>3.6.1</b></a></li>
                        <li class="indline1"><tt>codings</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.101"><b>14.3</b></a></li>
                        <li class="indline1"><tt>comment</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.19"><b>2.2</b></a></li>
                        <li class="indline1"><tt>Connection</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.115"><b>14.10</b></a></li>
                        <li class="indline1"><tt>connection-token</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.116"><b>14.10</b></a></li>
                        <li class="indline1"><tt>content-coding</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.39"><b>3.5</b></a></li>
                        <li class="indline1"><tt>content-disposition</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.184"><b>19.5.1</b></a></li>
                        <li class="indline1"><tt>Content-Encoding</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.117"><b>14.11</b></a></li>
                        <li class="indline1"><tt>Content-Language</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.118"><b>14.12</b></a></li>
                        <li class="indline1"><tt>Content-Length</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.119"><b>14.13</b></a></li>
                        <li class="indline1"><tt>Content-Location</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.120"><b>14.14</b></a></li>
                        <li class="indline1"><tt>Content-MD5</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.121"><b>14.15</b></a></li>
                        <li class="indline1"><tt>Content-Range</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.123"><b>14.16</b></a></li>
                        <li class="indline1"><tt>content-range-spec</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.124"><b>14.16</b></a></li>
                        <li class="indline1"><tt>Content-Type</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.128"><b>14.17</b></a></li>
                        <li class="indline1"><tt>CR</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.9"><b>2.2</b></a></li>
                        <li class="indline1"><tt>CRLF</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.13"><b>2.2</b></a></li>
                        <li class="indline1"><tt>ctext</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.20"><b>2.2</b></a></li>
                        <li class="indline1"><tt>CTL</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.8"><b>2.2</b></a></li>
                        <li class="indline1"><tt>Date</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.129"><b>14.18</b></a></li>
                        <li class="indline1"><tt>date1</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.30"><b>3.3.1</b></a></li>
                        <li class="indline1"><tt>date2</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.31"><b>3.3.1</b></a></li>
                        <li class="indline1"><tt>date3</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.32"><b>3.3.1</b></a></li>
                        <li class="indline1"><tt>delta-seconds</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.37"><b>3.3.2</b></a></li>
                        <li class="indline1"><tt>DIGIT</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.7"><b>2.2</b></a></li>
                        <li class="indline1"><tt>disp-extension-parm</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.189"><b>19.5.1</b></a></li>
                        <li class="indline1"><tt>disp-extension-token</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.188"><b>19.5.1</b></a></li>
                        <li class="indline1"><tt>disposition-parm</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.186"><b>19.5.1</b></a></li>
                        <li class="indline1"><tt>disposition-type</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.185"><b>19.5.1</b></a></li>
                        <li class="indline1"><tt>entity-body</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.93"><b>7.2</b></a></li>
                        <li class="indline1"><tt>entity-header</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.91"><b>7.1</b></a></li>
                        <li class="indline1"><tt>entity-tag</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.64"><b>3.11</b></a></li>
                        <li class="indline1"><tt>ETag</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.130"><b>14.19</b></a></li>
                        <li class="indline1"><tt>Expect</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.131"><b>14.20</b></a></li>
                        <li class="indline1"><tt>expect-params</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.134"><b>14.20</b></a></li>
                        <li class="indline1"><tt>expectation</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.132"><b>14.20</b></a></li>
                        <li class="indline1"><tt>expectation-extension</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.133"><b>14.20</b></a></li>
                        <li class="indline1"><tt>Expires</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.135"><b>14.21</b></a></li>
                        <li class="indline1"><tt>extension-code</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.88"><b>6.1.1</b></a></li>
                        <li class="indline1"><tt>extension-header</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.92"><b>7.1</b></a></li>
                        <li class="indline1"><tt>extension-method</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.82"><b>5.1.1</b></a></li>
                        <li class="indline1"><tt>extension-pragma</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.148"><b>14.32</b></a></li>
                        <li class="indline1"><tt>field-content</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.76"><b>4.2</b></a></li>
                        <li class="indline1"><tt>field-name</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.74"><b>4.2</b></a></li>
                        <li class="indline1"><tt>field-value</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.75"><b>4.2</b></a></li>
                        <li class="indline1"><tt>filename-parm</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.187"><b>19.5.1</b></a></li>
                        <li class="indline1"><tt>first-byte-pos</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.155"><b>14.35.1</b></a></li>
                        <li class="indline1"><tt>From</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.136"><b>14.22</b></a></li>
                        <li class="indline1"><tt>general-header</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.78"><b>4.5</b></a></li>
                        <li class="indline1"><tt>generic-message</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.71"><b>4.1</b></a></li>
                        <li class="indline1"><tt>HEX</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.16"><b>2.2</b></a></li>
                        <li class="indline1"><tt>Host</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.137"><b>14.23</b></a></li>
                        <li class="indline1"><tt>HT</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.12"><b>2.2</b></a></li>
                        <li class="indline1"><tt>HTTP-date</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.26"><b>3.3.1</b></a></li>
                        <li class="indline1"><tt>HTTP-message</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.70"><b>4.1</b></a></li>
                        <li class="indline1"><tt>HTTP-Version</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.24"><b>3.1</b></a></li>
                        <li class="indline1"><tt>http_URL</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.25"><b>3.2.2</b></a></li>
                        <li class="indline1"><tt>If-Match</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.138"><b>14.24</b></a></li>
                        <li class="indline1"><tt>If-Modified-Since</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.139"><b>14.25</b></a></li>
                        <li class="indline1"><tt>If-None-Match</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.140"><b>14.26</b></a></li>
                        <li class="indline1"><tt>If-Range</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.141"><b>14.27</b></a></li>
                        <li class="indline1"><tt>If-Unmodified-Since</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.142"><b>14.28</b></a></li>
                        <li class="indline1"><tt>instance-length</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.127"><b>14.16</b></a></li>
                        <li class="indline1"><tt>language-range</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.103"><b>14.4</b></a></li>
                        <li class="indline1"><tt>language-tag</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.61"><b>3.10</b></a></li>
                        <li class="indline1"><tt>last-byte-pos</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.156"><b>14.35.1</b></a></li>
                        <li class="indline1"><tt>last-chunk</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.49"><b>3.6.1</b></a></li>
                        <li class="indline1"><tt>Last-Modified</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.143"><b>14.29</b></a></li>
                        <li class="indline1"><tt>LF</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.10"><b>2.2</b></a></li>
                        <li class="indline1"><tt>LOALPHA</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.5"><b>2.2</b></a></li>
                        <li class="indline1"><tt>Location</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.144"><b>14.30</b></a></li>
                        <li class="indline1"><tt>LWS</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.14"><b>2.2</b></a></li>
                        <li class="indline1"><tt>Max-Forwards</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.145"><b>14.31</b></a></li>
                        <li class="indline1"><tt>md5-digest</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.122"><b>14.15</b></a></li>
                        <li class="indline1"><tt>media-range</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.96"><b>14.1</b></a></li>
                        <li class="indline1"><tt>media-type</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.55"><b>3.7</b></a></li>
                        <li class="indline1"><tt>message-body</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.77"><b>4.3</b></a></li>
                        <li class="indline1"><tt>message-header</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.73"><b>4.2</b></a></li>
                        <li class="indline1"><tt>Method</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.81"><b>5.1.1</b></a></li>
                        <li class="indline1"><tt>MIME-Version</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.183"><b>19.4.1</b></a></li>
                        <li class="indline1"><tt>month</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.36"><b>3.3.1</b></a></li>
                        <li class="indline1"><tt>OCTET</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.2"><b>2.2</b></a></li>
                        <li class="indline1"><tt>opaque-tag</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.66"><b>3.11</b></a></li>
                        <li class="indline1"><tt>other-range-unit</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.69"><b>3.12</b></a></li>
                        <li class="indline1"><tt>parameter</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.43"><b>3.6</b></a></li>
                        <li class="indline1"><tt>Pragma</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.146"><b>14.32</b></a></li>
                        <li class="indline1"><tt>pragma-directive</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.147"><b>14.32</b></a></li>
                        <li class="indline1"><tt>primary-tag</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.62"><b>3.10</b></a></li>
                        <li class="indline1"><tt>product</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.58"><b>3.8</b></a></li>
                        <li class="indline1"><tt>product-version</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.59"><b>3.8</b></a></li>
                        <li class="indline1"><tt>protocol-name</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.172"><b>14.45</b></a></li>
                        <li class="indline1"><tt>protocol-version</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.173"><b>14.45</b></a></li>
                        <li class="indline1"><tt>Proxy-Authenticate</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.149"><b>14.33</b></a></li>
                        <li class="indline1"><tt>Proxy-Authorization</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.150"><b>14.34</b></a></li>
                        <li class="indline1"><tt>pseudonym</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.175"><b>14.45</b></a></li>
                        <li class="indline1"><tt>qdtext</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.22"><b>2.2</b></a></li>
                        <li class="indline1"><tt>quoted-pair</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.23"><b>2.2</b></a></li>
                        <li class="indline1"><tt>quoted-string</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.21"><b>2.2</b></a></li>
                        <li class="indline1"><tt>qvalue</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.60"><b>3.9</b></a></li>
                        <li class="indline1"><tt>Range</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.159"><b>14.35.2</b></a></li>
                        <li class="indline1"><tt>range-unit</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.67"><b>3.12</b></a></li>
                        <li class="indline1"><tt>ranges-specifier</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.151"><b>14.35.1</b></a></li>
                        <li class="indline1"><tt>Reason-Phrase</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.89"><b>6.1.1</b></a></li>
                        <li class="indline1"><tt>received-by</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.174"><b>14.45</b></a></li>
                        <li class="indline1"><tt>received-protocol</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.171"><b>14.45</b></a></li>
                        <li class="indline1"><tt>Referer</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.160"><b>14.36</b></a></li>
                        <li class="indline1"><tt>Request</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.79"><b>5</b></a></li>
                        <li class="indline1"><tt>request-header</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.84"><b>5.3</b></a></li>
                        <li class="indline1"><tt>Request-Line</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.80"><b>5.1</b></a></li>
                        <li class="indline1"><tt>Request-URI</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.83"><b>5.1.2</b></a></li>
                        <li class="indline1"><tt>Response</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.85"><b>6</b></a></li>
                        <li class="indline1"><tt>response-header</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.90"><b>6.2</b></a></li>
                        <li class="indline1"><tt>Retry-After</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.161"><b>14.37</b></a></li>
                        <li class="indline1"><tt>rfc1123-date</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.27"><b>3.3.1</b></a></li>
                        <li class="indline1"><tt>rfc850-date</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.28"><b>3.3.1</b></a></li>
                        <li class="indline1"><tt>separators</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.18"><b>2.2</b></a></li>
                        <li class="indline1"><tt>Server</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.162"><b>14.38</b></a></li>
                        <li class="indline1"><tt>SP</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.11"><b>2.2</b></a></li>
                        <li class="indline1"><tt>start-line</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.72"><b>4.1</b></a></li>
                        <li class="indline1"><tt>Status-Code</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.87"><b>6.1.1</b></a></li>
                        <li class="indline1"><tt>Status-Line</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.86"><b>6.1</b></a></li>
                        <li class="indline1"><tt>subtag</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.63"><b>3.10</b></a></li>
                        <li class="indline1"><tt>subtype</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.57"><b>3.7</b></a></li>
                        <li class="indline1"><tt>suffix-byte-range-spec</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.157"><b>14.35.1</b></a></li>
                        <li class="indline1"><tt>suffix-length</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.158"><b>14.35.1</b></a></li>
                        <li class="indline1"><tt>t-codings</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.164"><b>14.39</b></a></li>
                        <li class="indline1"><tt>TE</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.163"><b>14.39</b></a></li>
                        <li class="indline1"><tt>TEXT</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.15"><b>2.2</b></a></li>
                        <li class="indline1"><tt>time</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.33"><b>3.3.1</b></a></li>
                        <li class="indline1"><tt>token</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.17"><b>2.2</b></a></li>
                        <li class="indline1"><tt>trailer</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.54"><b>3.6.1</b></a></li>
                        <li class="indline1"><tt>Trailer</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.165"><b>14.40</b></a></li>
                        <li class="indline1"><tt>transfer-coding</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.41"><b>3.6</b></a></li>
                        <li class="indline1"><tt>Transfer-Encoding</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.166"><b>14.41</b></a></li>
                        <li class="indline1"><tt>transfer-extension</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.42"><b>3.6</b></a></li>
                        <li class="indline1"><tt>type</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.56"><b>3.7</b></a></li>
                        <li class="indline1"><tt>UPALPHA</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.4"><b>2.2</b></a></li>
                        <li class="indline1"><tt>Upgrade</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.167"><b>14.42</b></a></li>
                        <li class="indline1"><tt>User-Agent</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.168"><b>14.43</b></a></li>
                        <li class="indline1"><tt>value</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.45"><b>3.6</b></a></li>
                        <li class="indline1"><tt>Vary</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.169"><b>14.44</b></a></li>
                        <li class="indline1"><tt>Via</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.170"><b>14.45</b></a></li>
                        <li class="indline1"><tt>warn-agent</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.179"><b>14.46</b></a></li>
                        <li class="indline1"><tt>warn-code</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.178"><b>14.46</b></a></li>
                        <li class="indline1"><tt>warn-date</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.181"><b>14.46</b></a></li>
                        <li class="indline1"><tt>warn-text</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.180"><b>14.46</b></a></li>
                        <li class="indline1"><tt>Warning</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.176"><b>14.46</b></a></li>
                        <li class="indline1"><tt>warning-value</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.177"><b>14.46</b></a></li>
                        <li class="indline1"><tt>weak</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.65"><b>3.11</b></a></li>
                        <li class="indline1"><tt>weekday</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.35"><b>3.3.1</b></a></li>
                        <li class="indline1"><tt>wkday</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.34"><b>3.3.1</b></a></li>
                        <li class="indline1"><tt>WWW-Authenticate</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.182"><b>14.47</b></a></li>
                     </ul>
                  </li>
                  <li class="indline1">gzip&nbsp;&nbsp;<a class="iref" href="#rfc.iref.g.40">3.5</a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.H" href="#rfc.index.H"><b>H</b></a><ul class="ind">
                  <li class="indline1">HEAD method&nbsp;&nbsp;<a class="iref" href="#rfc.xref.HEAD.1">5.1.1</a>, <a class="iref" href="#rfc.iref.h.2"><b>9.4</b></a></li>
                  <li class="indline1">Headers&nbsp;&nbsp;
                     <ul class="ind">
                        <li class="indline1">Accept&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.accept.1">3.7</a>, <a class="iref" href="#rfc.xref.header.accept.2">5.3</a>, <a class="iref" href="#rfc.xref.header.accept.3">12.1</a>, <a class="iref" href="#rfc.iref.h.3"><b>14.1</b></a></li>
                        <li class="indline1">Accept-Charset&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.accept-charset.1">5.3</a>, <a class="iref" href="#rfc.xref.header.accept-charset.2">12.1</a>, <a class="iref" href="#rfc.iref.h.4"><b>14.2</b></a>, <a class="iref" href="#rfc.xref.header.accept-charset.3">19.6.3</a></li>
                        <li class="indline1">Accept-Encoding&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.accept-encoding.1">3.5</a>, <a class="iref" href="#rfc.xref.header.accept-encoding.2">5.3</a>, <a class="iref" href="#rfc.xref.header.accept-encoding.3">12.1</a>, <a class="iref" href="#rfc.iref.h.5"><b>14.3</b></a></li>
                        <li class="indline1">Accept-Language&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.accept-language.1">5.3</a>, <a class="iref" href="#rfc.xref.header.accept-language.2">12.1</a>, <a class="iref" href="#rfc.iref.h.6"><b>14.4</b></a></li>
                        <li class="indline1">Accept-Ranges&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.accept-ranges.1">6.2</a>, <a class="iref" href="#rfc.iref.h.7"><b>14.5</b></a></li>
                        <li class="indline1">Age&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.age.1">6.2</a>, <a class="iref" href="#rfc.iref.h.8"><b>14.6</b></a></li>
                        <li class="indline1">Allow&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.allow.1">5.1.1</a>, <a class="iref" href="#rfc.xref.header.allow.2">7.1</a>, <a class="iref" href="#rfc.iref.h.9"><b>14.7</b></a></li>
                        <li class="indline1">Alternate&nbsp;&nbsp;<a class="iref" href="#rfc.iref.h.52"><b>19.6.3</b></a></li>
                        <li class="indline1">Authorization&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.authorization.1">5.3</a>, <a class="iref" href="#rfc.xref.header.authorization.2">10.4.2</a>, <a class="iref" href="#rfc.xref.header.authorization.3">13.4</a>, <a class="iref" href="#rfc.iref.h.10"><b>14.8</b></a>, <a class="iref" href="#rfc.xref.header.authorization.4">14.9.1</a>, <a class="iref" href="#rfc.xref.header.authorization.5">19.6.3</a></li>
                        <li class="indline1">Cache-Control&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.cache-control.1">4.5</a>, <a class="iref" href="#rfc.xref.header.cache-control.2">13.1.1</a>, <a class="iref" href="#rfc.xref.header.cache-control.3">13.1.1</a>, <a class="iref" href="#rfc.xref.header.cache-control.4">13.1.3</a>, <a class="iref" href="#rfc.xref.header.cache-control.5">13.2.1</a>, <a class="iref" href="#rfc.xref.header.cache-control.6">13.2.5</a>, <a class="iref" href="#rfc.xref.header.cache-control.7">13.4</a>, <a class="iref" href="#rfc.xref.header.cache-control.8">13.4</a>, <a class="iref" href="#rfc.xref.header.cache-control.9">13.8</a>, <a class="iref" href="#rfc.iref.h.11"><b>14.9</b></a>, <a class="iref" href="#rfc.xref.header.cache-control.10">14.21</a>, <a class="iref" href="#rfc.xref.header.cache-control.11">14.32</a>, <a class="iref" href="#rfc.xref.header.cache-control.12">19.6.3</a></li>
                        <li class="indline1">Connection&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.connection.1">4.5</a>, <a class="iref" href="#rfc.xref.header.connection.2">8.1.2</a>, <a class="iref" href="#rfc.xref.header.connection.3">8.1.3</a>, <a class="iref" href="#rfc.xref.header.connection.4">13.5.1</a>, <a class="iref" href="#rfc.iref.h.12"><b>14.10</b></a>, <a class="iref" href="#rfc.xref.header.connection.5">14.39</a>, <a class="iref" href="#rfc.xref.header.connection.6">14.42</a>, <a class="iref" href="#rfc.xref.header.connection.7">19.6.2</a></li>
                        <li class="indline1">Content-Base&nbsp;&nbsp;<a class="iref" href="#rfc.iref.h.58"><b>19.6.3</b></a></li>
                        <li class="indline1">Content-Disposition&nbsp;&nbsp;<a class="iref" href="#rfc.xref.content-disposition.1">15.5</a>, <a class="iref" href="#rfc.iref.h.51"><b>19.5.1</b></a></li>
                        <li class="indline1">Content-Encoding&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.content-encoding.1">3.5</a>, <a class="iref" href="#rfc.xref.header.content-encoding.2">7.1</a>, <a class="iref" href="#rfc.iref.h.13"><b>14.11</b></a>, <a class="iref" href="#rfc.xref.header.content-encoding.3">14.11</a></li>
                        <li class="indline1">Content-Language&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.content-language.1">7.1</a>, <a class="iref" href="#rfc.iref.h.14"><b>14.12</b></a></li>
                        <li class="indline1">Content-Length&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.content-length.1">4.4</a>, <a class="iref" href="#rfc.xref.header.content-length.2">7.1</a>, <a class="iref" href="#rfc.iref.h.15"><b>14.13</b></a>, <a class="iref" href="#rfc.xref.header.content-length.3">19.6.3</a></li>
                        <li class="indline1">Content-Location&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.content-location.1">7.1</a>, <a class="iref" href="#rfc.iref.h.16"><b>14.14</b></a>, <a class="iref" href="#rfc.xref.header.content-location.2">14.30</a></li>
                        <li class="indline1">Content-MD5&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.content-md5.1">7.1</a>, <a class="iref" href="#rfc.iref.h.17"><b>14.15</b></a></li>
                        <li class="indline1">Content-Range&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.content-range.1">3.7.2</a>, <a class="iref" href="#rfc.xref.header.content-range.2">3.12</a>, <a class="iref" href="#rfc.xref.header.content-range.3">7.1</a>, <a class="iref" href="#rfc.xref.header.content-range.4">10.2.7</a>, <a class="iref" href="#rfc.xref.header.content-range.5">10.4.17</a>, <a class="iref" href="#rfc.iref.h.18"><b>14.16</b></a>, <a class="iref" href="#rfc.xref.header.content-range.6">19.6.3</a>, <a class="iref" href="#rfc.xref.header.content-range.7">19.6.3</a>, <a class="iref" href="#rfc.xref.header.content-range.8">19.6.3</a></li>
                        <li class="indline1">Content-Type&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.content-type.1">3.7</a>, <a class="iref" href="#rfc.xref.header.content-type.2">7.1</a>, <a class="iref" href="#rfc.iref.h.19"><b>14.17</b></a></li>
                        <li class="indline1">Content-Version&nbsp;&nbsp;<a class="iref" href="#rfc.iref.h.53"><b>19.6.3</b></a></li>
                        <li class="indline1">Date&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.date.1">4.5</a>, <a class="iref" href="#rfc.xref.header.date.2">13.2.3</a>, <a class="iref" href="#rfc.iref.h.20"><b>14.18</b></a></li>
                        <li class="indline1">Derived-From&nbsp;&nbsp;<a class="iref" href="#rfc.iref.h.54"><b>19.6.3</b></a></li>
                        <li class="indline1">ETag&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.etag.1">3.11</a>, <a class="iref" href="#rfc.xref.header.etag.2">6.2</a>, <a class="iref" href="#rfc.xref.header.etag.3">10.2.2</a>, <a class="iref" href="#rfc.xref.header.etag.4">13.3.2</a>, <a class="iref" href="#rfc.iref.h.21"><b>14.19</b></a></li>
                        <li class="indline1">Expect&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.expect.1">5.3</a>, <a class="iref" href="#rfc.xref.header.expect.2">8.2.3</a>, <a class="iref" href="#rfc.xref.header.expect.3">8.2.3</a>, <a class="iref" href="#rfc.xref.header.expect.4">10.4.18</a>, <a class="iref" href="#rfc.iref.h.22"><b>14.20</b></a>, <a class="iref" href="#rfc.xref.header.expect.5">19.6.3</a></li>
                        <li class="indline1">Expires&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.expires.1">7.1</a>, <a class="iref" href="#rfc.xref.header.expires.2">13.4</a>, <a class="iref" href="#rfc.xref.header.expires.3">14.9.3</a>, <a class="iref" href="#rfc.iref.h.23"><b>14.21</b></a></li>
                        <li class="indline1">From&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.from.1">5.3</a>, <a class="iref" href="#rfc.iref.h.24"><b>14.22</b></a></li>
                        <li class="indline1">Host&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.host.1">5.3</a>, <a class="iref" href="#rfc.xref.header.host.2">9</a>, <a class="iref" href="#rfc.iref.h.26"><b>14.23</b></a>, <a class="iref" href="#rfc.xref.header.host.3">19.6.1.1</a></li>
                        <li class="indline1">If-Match&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.if-match.1">3.11</a>, <a class="iref" href="#rfc.xref.header.if-match.2">5.3</a>, <a class="iref" href="#rfc.xref.header.if-match.3">13.3.2</a>, <a class="iref" href="#rfc.xref.header.if-match.4">14.19</a>, <a class="iref" href="#rfc.iref.h.27"><b>14.24</b></a></li>
                        <li class="indline1">If-Modified-Since&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.if-modified-since.1">5.3</a>, <a class="iref" href="#rfc.iref.h.28"><b>14.25</b></a></li>
                        <li class="indline1">If-None-Match&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.if-none-match.1">3.11</a>, <a class="iref" href="#rfc.xref.header.if-none-match.2">5.3</a>, <a class="iref" href="#rfc.xref.header.if-none-match.3">13.3.2</a>, <a class="iref" href="#rfc.xref.header.if-none-match.4">14.19</a>, <a class="iref" href="#rfc.iref.h.29"><b>14.26</b></a></li>
                        <li class="indline1">If-Range&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.if-range.1">3.11</a>, <a class="iref" href="#rfc.xref.header.if-range.2">5.3</a>, <a class="iref" href="#rfc.xref.header.if-range.3">10.2.7</a>, <a class="iref" href="#rfc.iref.h.30"><b>14.27</b></a>, <a class="iref" href="#rfc.xref.header.if-range.4">14.35.2</a>, <a class="iref" href="#rfc.xref.header.if-range.5">19.6.3</a></li>
                        <li class="indline1">If-Unmodified-Since&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.if-unmodified-since.1">5.3</a>, <a class="iref" href="#rfc.iref.h.31"><b>14.28</b></a></li>
                        <li class="indline1">Last-Modified&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.last-modified.1">7.1</a>, <a class="iref" href="#rfc.iref.h.32"><b>14.29</b></a></li>
                        <li class="indline1">Link&nbsp;&nbsp;<a class="iref" href="#rfc.iref.h.55"><b>19.6.3</b></a></li>
                        <li class="indline1">Location&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.location.1">6.2</a>, <a class="iref" href="#rfc.xref.header.location.2">9.5</a>, <a class="iref" href="#rfc.iref.h.33"><b>14.30</b></a></li>
                        <li class="indline1">Max-Forwards&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.max-forwards.1">5.3</a>, <a class="iref" href="#rfc.xref.header.max-forwards.2">9.8</a>, <a class="iref" href="#rfc.iref.h.34"><b>14.31</b></a></li>
                        <li class="indline1">Pragma&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.pragma.1">4.5</a>, <a class="iref" href="#rfc.xref.header.pragma.2">14.9</a>, <a class="iref" href="#rfc.iref.h.35"><b>14.32</b></a></li>
                        <li class="indline1">Proxy-Authenticate&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.proxy-authenticate.1">6.2</a>, <a class="iref" href="#rfc.xref.header.proxy-authenticate.2">10.4.8</a>, <a class="iref" href="#rfc.iref.h.36"><b>14.33</b></a></li>
                        <li class="indline1">Proxy-Authorization&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.proxy-authorization.1">5.3</a>, <a class="iref" href="#rfc.xref.header.proxy-authorization.2">10.4.8</a>, <a class="iref" href="#rfc.iref.h.37"><b>14.34</b></a></li>
                        <li class="indline1">Public&nbsp;&nbsp;<a class="iref" href="#rfc.iref.h.57"><b>19.6.3</b></a></li>
                        <li class="indline1">Range&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.range.1">3.12</a>, <a class="iref" href="#rfc.xref.header.range.2">5.3</a>, <a class="iref" href="#rfc.xref.header.range.3">9.3</a>, <a class="iref" href="#rfc.xref.header.range.4">10.2.7</a>, <a class="iref" href="#rfc.xref.header.range.5">10.4.17</a>, <a class="iref" href="#rfc.xref.header.range.6">14.25</a>, <a class="iref" href="#rfc.iref.h.38"><b>14.35</b></a></li>
                        <li class="indline1">Referer&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.referer.1">5.3</a>, <a class="iref" href="#rfc.iref.h.39"><b>14.36</b></a></li>
                        <li class="indline1">Retry-After&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.retry-after.1">6.2</a>, <a class="iref" href="#rfc.iref.h.40"><b>14.37</b></a></li>
                        <li class="indline1">Server&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.server.1">6.2</a>, <a class="iref" href="#rfc.iref.h.41"><b>14.38</b></a>, <a class="iref" href="#rfc.xref.header.server.2">15.1.2</a></li>
                        <li class="indline1">TE&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.te.1">3.6</a>, <a class="iref" href="#rfc.xref.header.te.2">3.6.1</a>, <a class="iref" href="#rfc.xref.header.te.3">5.3</a>, <a class="iref" href="#rfc.iref.h.42"><b>14.39</b></a>, <a class="iref" href="#rfc.xref.header.te.4">19.6.3</a></li>
                        <li class="indline1">Trailer&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.trailer.1">3.6.1</a>, <a class="iref" href="#rfc.xref.header.trailer.2">4.5</a>, <a class="iref" href="#rfc.iref.h.43"><b>14.40</b></a></li>
                        <li class="indline1">Transfer-Encoding&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.transfer-encoding.1">3.6</a>, <a class="iref" href="#rfc.xref.header.transfer-encoding.2">4.3</a>, <a class="iref" href="#rfc.xref.header.transfer-encoding.3">4.4</a>, <a class="iref" href="#rfc.xref.header.transfer-encoding.4">4.5</a>, <a class="iref" href="#rfc.iref.h.44"><b>14.41</b></a>, <a class="iref" href="#rfc.xref.header.transfer-encoding.5">19.4.6</a></li>
                        <li class="indline1">Upgrade&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.upgrade.1">4.5</a>, <a class="iref" href="#rfc.xref.header.upgrade.2">10.1.2</a>, <a class="iref" href="#rfc.iref.h.45"><b>14.42</b></a></li>
                        <li class="indline1">URI&nbsp;&nbsp;<a class="iref" href="#rfc.iref.h.56"><b>19.6.3</b></a></li>
                        <li class="indline1">User-Agent&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.user-agent.1">5.3</a>, <a class="iref" href="#rfc.xref.header.user-agent.2">12.1</a>, <a class="iref" href="#rfc.iref.h.46"><b>14.43</b></a>, <a class="iref" href="#rfc.xref.header.user-agent.3">15.1.2</a></li>
                        <li class="indline1">Vary&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.vary.1">6.2</a>, <a class="iref" href="#rfc.xref.header.vary.2">12.1</a>, <a class="iref" href="#rfc.xref.header.vary.3">13.3.2</a>, <a class="iref" href="#rfc.xref.header.vary.4">13.6</a>, <a class="iref" href="#rfc.xref.header.vary.5">14.19</a>, <a class="iref" href="#rfc.xref.header.vary.6">14.24</a>, <a class="iref" href="#rfc.xref.header.vary.7">14.26</a>, <a class="iref" href="#rfc.iref.h.47"><b>14.44</b></a></li>
                        <li class="indline1">Via&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.via.1">4.5</a>, <a class="iref" href="#rfc.xref.header.via.2">9.8</a>, <a class="iref" href="#rfc.xref.header.via.3">14.38</a>, <a class="iref" href="#rfc.iref.h.48"><b>14.45</b></a></li>
                        <li class="indline1">Warning&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.warning.1">4.5</a>, <a class="iref" href="#rfc.xref.header.warning.2">13.1.1</a>, <a class="iref" href="#rfc.xref.header.warning.3">13.1.2</a>, <a class="iref" href="#rfc.xref.header.warning.4">13.1.2</a>, <a class="iref" href="#rfc.xref.header.warning.5">13.5.2</a>, <a class="iref" href="#rfc.xref.header.warning.6">13.5.3</a>, <a class="iref" href="#rfc.iref.h.49"><b>14.46</b></a>, <a class="iref" href="#rfc.xref.header.warning.7">19.6.3</a></li>
                        <li class="indline1">WWW-Authenticate&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.www-authenticate.1">6.2</a>, <a class="iref" href="#rfc.xref.header.www-authenticate.2">10.4.2</a>, <a class="iref" href="#rfc.iref.h.50"><b>14.47</b></a></li>
                     </ul>
                  </li>
                  <li class="indline1">heuristic expiration time&nbsp;&nbsp;<a class="iref" href="#rfc.iref.h.1">1.3</a></li>
                  <li class="indline1">Host header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.host.1">5.3</a>, <a class="iref" href="#rfc.xref.header.host.2">9</a>, <a class="iref" href="#rfc.iref.h.25"><b>14.23</b></a>, <a class="iref" href="#rfc.xref.header.host.3">19.6.1.1</a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.I" href="#rfc.index.I"><b>I</b></a><ul class="ind">
                  <li class="indline1">identity&nbsp;&nbsp;<a class="iref" href="#rfc.iref.i.2">3.5</a></li>
                  <li class="indline1">If-Match header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.if-match.1">3.11</a>, <a class="iref" href="#rfc.xref.header.if-match.2">5.3</a>, <a class="iref" href="#rfc.xref.header.if-match.3">13.3.2</a>, <a class="iref" href="#rfc.xref.header.if-match.4">14.19</a>, <a class="iref" href="#rfc.iref.i.3"><b>14.24</b></a></li>
                  <li class="indline1">If-Modified-Since header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.if-modified-since.1">5.3</a>, <a class="iref" href="#rfc.iref.i.4"><b>14.25</b></a></li>
                  <li class="indline1">If-None-Match header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.if-none-match.1">3.11</a>, <a class="iref" href="#rfc.xref.header.if-none-match.2">5.3</a>, <a class="iref" href="#rfc.xref.header.if-none-match.3">13.3.2</a>, <a class="iref" href="#rfc.xref.header.if-none-match.4">14.19</a>, <a class="iref" href="#rfc.iref.i.5"><b>14.26</b></a></li>
                  <li class="indline1">If-Range header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.if-range.1">3.11</a>, <a class="iref" href="#rfc.xref.header.if-range.2">5.3</a>, <a class="iref" href="#rfc.xref.header.if-range.3">10.2.7</a>, <a class="iref" href="#rfc.iref.i.6"><b>14.27</b></a>, <a class="iref" href="#rfc.xref.header.if-range.4">14.35.2</a>, <a class="iref" href="#rfc.xref.header.if-range.5">19.6.3</a></li>
                  <li class="indline1">If-Unmodified-Since header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.if-unmodified-since.1">5.3</a>, <a class="iref" href="#rfc.iref.i.7"><b>14.28</b></a></li>
                  <li class="indline1">inbound&nbsp;&nbsp;<a class="iref" href="#rfc.iref.i.1">1.3</a></li>
                  <li class="indline1"><em>ISO-8859</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.ISO-8859.1">2.2</a>, <a class="iref" href="#ISO-8859"><b>17</b></a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.L" href="#rfc.index.L"><b>L</b></a><ul class="ind">
                  <li class="indline1">Last-Modified header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.last-modified.1">7.1</a>, <a class="iref" href="#rfc.iref.l.1"><b>14.29</b></a></li>
                  <li class="indline1">Link header&nbsp;&nbsp;<a class="iref" href="#rfc.iref.l.4"><b>19.6.3</b></a></li>
                  <li class="indline1">LINK method&nbsp;&nbsp;<a class="iref" href="#rfc.iref.l.3"><b>19.6.3</b></a></li>
                  <li class="indline1">Location header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.location.1">6.2</a>, <a class="iref" href="#rfc.xref.header.location.2">9.5</a>, <a class="iref" href="#rfc.iref.l.2"><b>14.30</b></a></li>
                  <li class="indline1"><em>Luo1998</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.Luo1998.1">9.9</a>, <a class="iref" href="#Luo1998"><b>17</b></a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.M" href="#rfc.index.M"><b>M</b></a><ul class="ind">
                  <li class="indline1">max-age&nbsp;&nbsp;
                     <ul class="ind">
                        <li class="indline1">Cache Directive&nbsp;&nbsp;<a class="iref" href="#rfc.iref.m.10"><b>14.9.3</b></a>, <a class="iref" href="#rfc.iref.m.13"><b>14.9.4</b></a></li>
                     </ul>
                  </li>
                  <li class="indline1">Max-Forwards header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.max-forwards.1">5.3</a>, <a class="iref" href="#rfc.xref.header.max-forwards.2">9.8</a>, <a class="iref" href="#rfc.iref.m.15"><b>14.31</b></a></li>
                  <li class="indline1">max-stale&nbsp;&nbsp;
                     <ul class="ind">
                        <li class="indline1">Cache Directive&nbsp;&nbsp;<a class="iref" href="#rfc.iref.m.12"><b>14.9.3</b></a></li>
                     </ul>
                  </li>
                  <li class="indline1">Media Type&nbsp;&nbsp;
                     <ul class="ind">
                        <li class="indline1">application/http&nbsp;&nbsp;<a class="iref" href="#rfc.iref.m.18"><b>19.1</b></a></li>
                        <li class="indline1">message/http&nbsp;&nbsp;<a class="iref" href="#rfc.iref.m.16"><b>19.1</b></a></li>
                        <li class="indline1">multipart/byteranges&nbsp;&nbsp;<a class="iref" href="#rfc.iref.m.19"><b>19.2</b></a></li>
                        <li class="indline1">multipart/x-byteranges&nbsp;&nbsp;<a class="iref" href="#rfc.iref.m.22">19.2</a></li>
                     </ul>
                  </li>
                  <li class="indline1">message&nbsp;&nbsp;<a class="iref" href="#rfc.iref.m.1">1.3</a></li>
                  <li class="indline1">message/http Media Type&nbsp;&nbsp;<a class="iref" href="#rfc.iref.m.17"><b>19.1</b></a></li>
                  <li class="indline1">Methods&nbsp;&nbsp;
                     <ul class="ind">
                        <li class="indline1">CONNECT&nbsp;&nbsp;<a class="iref" href="#rfc.xref.CONNECT.1">5.1.1</a>, <a class="iref" href="#rfc.xref.CONNECT.2">5.1.2</a>, <a class="iref" href="#rfc.iref.m.9"><b>9.9</b></a></li>
                        <li class="indline1">DELETE&nbsp;&nbsp;<a class="iref" href="#rfc.xref.DELETE.1">5.1.1</a>, <a class="iref" href="#rfc.iref.m.7"><b>9.7</b></a></li>
                        <li class="indline1">GET&nbsp;&nbsp;<a class="iref" href="#rfc.xref.GET.1">5.1.1</a>, <a class="iref" href="#rfc.iref.m.3"><b>9.3</b></a></li>
                        <li class="indline1">HEAD&nbsp;&nbsp;<a class="iref" href="#rfc.xref.HEAD.1">5.1.1</a>, <a class="iref" href="#rfc.iref.m.4"><b>9.4</b></a></li>
                        <li class="indline1">LINK&nbsp;&nbsp;<a class="iref" href="#rfc.iref.m.24"><b>19.6.3</b></a></li>
                        <li class="indline1">OPTIONS&nbsp;&nbsp;<a class="iref" href="#rfc.xref.OPTIONS.1">5.1.1</a>, <a class="iref" href="#rfc.iref.m.2"><b>9.2</b></a>, <a class="iref" href="#rfc.xref.OPTIONS.2">14.31</a></li>
                        <li class="indline1">PATCH&nbsp;&nbsp;<a class="iref" href="#rfc.iref.m.23"><b>19.6.3</b></a></li>
                        <li class="indline1">POST&nbsp;&nbsp;<a class="iref" href="#rfc.xref.POST.1">5.1.1</a>, <a class="iref" href="#rfc.iref.m.5"><b>9.5</b></a></li>
                        <li class="indline1">PUT&nbsp;&nbsp;<a class="iref" href="#rfc.xref.PUT.1">5.1.1</a>, <a class="iref" href="#rfc.iref.m.6"><b>9.6</b></a></li>
                        <li class="indline1">TRACE&nbsp;&nbsp;<a class="iref" href="#rfc.xref.TRACE.1">5.1.1</a>, <a class="iref" href="#rfc.iref.m.8"><b>9.8</b></a>, <a class="iref" href="#rfc.xref.TRACE.2">14.31</a></li>
                        <li class="indline1">UNLINK&nbsp;&nbsp;<a class="iref" href="#rfc.iref.m.25"><b>19.6.3</b></a></li>
                     </ul>
                  </li>
                  <li class="indline1">min-fresh&nbsp;&nbsp;
                     <ul class="ind">
                        <li class="indline1">Cache Directive&nbsp;&nbsp;<a class="iref" href="#rfc.iref.m.11"><b>14.9.3</b></a></li>
                     </ul>
                  </li>
                  <li class="indline1">multipart/byteranges Media Type&nbsp;&nbsp;<a class="iref" href="#rfc.iref.m.20"><b>19.2</b></a></li>
                  <li class="indline1">multipart/x-byteranges Media Type&nbsp;&nbsp;<a class="iref" href="#rfc.iref.m.21">19.2</a></li>
                  <li class="indline1">must-revalidate&nbsp;&nbsp;
                     <ul class="ind">
                        <li class="indline1">Cache Directive&nbsp;&nbsp;<a class="iref" href="#rfc.iref.m.14"><b>14.9.4</b></a></li>
                     </ul>
                  </li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.N" href="#rfc.index.N"><b>N</b></a><ul class="ind">
                  <li class="indline1"><em>Nie1997</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.Nie1997.1">8.1.1</a>, <a class="iref" href="#Nie1997"><b>17</b></a>, <a class="iref" href="#rfc.xref.Nie1997.2">19.6.3</a></li>
                  <li class="indline1">no-cache&nbsp;&nbsp;
                     <ul class="ind">
                        <li class="indline1">Cache Directive&nbsp;&nbsp;<a class="iref" href="#rfc.iref.n.1"><b>14.9.1</b></a></li>
                     </ul>
                  </li>
                  <li class="indline1">no-store&nbsp;&nbsp;
                     <ul class="ind">
                        <li class="indline1">Cache Directive&nbsp;&nbsp;<a class="iref" href="#rfc.iref.n.2"><b>14.9.2</b></a></li>
                     </ul>
                  </li>
                  <li class="indline1">no-transform&nbsp;&nbsp;
                     <ul class="ind">
                        <li class="indline1">Cache Directive&nbsp;&nbsp;<a class="iref" href="#rfc.iref.n.3"><b>14.9.5</b></a></li>
                     </ul>
                  </li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.O" href="#rfc.index.O"><b>O</b></a><ul class="ind">
                  <li class="indline1">only-if-cached&nbsp;&nbsp;
                     <ul class="ind">
                        <li class="indline1">Cache Directive&nbsp;&nbsp;<a class="iref" href="#rfc.iref.o.4"><b>14.9.4</b></a></li>
                     </ul>
                  </li>
                  <li class="indline1">OPTIONS method&nbsp;&nbsp;<a class="iref" href="#rfc.xref.OPTIONS.1">5.1.1</a>, <a class="iref" href="#rfc.iref.o.3"><b>9.2</b></a>, <a class="iref" href="#rfc.xref.OPTIONS.2">14.31</a></li>
                  <li class="indline1">origin server&nbsp;&nbsp;<a class="iref" href="#rfc.iref.o.1">1.3</a></li>
                  <li class="indline1">outbound&nbsp;&nbsp;<a class="iref" href="#rfc.iref.o.2">1.3</a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.P" href="#rfc.index.P"><b>P</b></a><ul class="ind">
                  <li class="indline1"><em>Pad1995</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.Pad1995.1">8.1.1</a>, <a class="iref" href="#Pad1995"><b>17</b></a></li>
                  <li class="indline1">PATCH method&nbsp;&nbsp;<a class="iref" href="#rfc.iref.p.10"><b>19.6.3</b></a></li>
                  <li class="indline1">POST method&nbsp;&nbsp;<a class="iref" href="#rfc.xref.POST.1">5.1.1</a>, <a class="iref" href="#rfc.iref.p.2"><b>9.5</b></a></li>
                  <li class="indline1">Pragma header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.pragma.1">4.5</a>, <a class="iref" href="#rfc.xref.header.pragma.2">14.9</a>, <a class="iref" href="#rfc.iref.p.7"><b>14.32</b></a></li>
                  <li class="indline1">private&nbsp;&nbsp;
                     <ul class="ind">
                        <li class="indline1">Cache Directive&nbsp;&nbsp;<a class="iref" href="#rfc.iref.p.5"><b>14.9.1</b></a></li>
                     </ul>
                  </li>
                  <li class="indline1">proxy&nbsp;&nbsp;<a class="iref" href="#rfc.iref.p.1">1.3</a></li>
                  <li class="indline1">Proxy-Authenticate header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.proxy-authenticate.1">6.2</a>, <a class="iref" href="#rfc.xref.header.proxy-authenticate.2">10.4.8</a>, <a class="iref" href="#rfc.iref.p.8"><b>14.33</b></a></li>
                  <li class="indline1">Proxy-Authorization header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.proxy-authorization.1">5.3</a>, <a class="iref" href="#rfc.xref.header.proxy-authorization.2">10.4.8</a>, <a class="iref" href="#rfc.iref.p.9"><b>14.34</b></a></li>
                  <li class="indline1">proxy-revalidate&nbsp;&nbsp;
                     <ul class="ind">
                        <li class="indline1">Cache Directive&nbsp;&nbsp;<a class="iref" href="#rfc.iref.p.6"><b>14.9.4</b></a></li>
                     </ul>
                  </li>
                  <li class="indline1">public&nbsp;&nbsp;
                     <ul class="ind">
                        <li class="indline1">Cache Directive&nbsp;&nbsp;<a class="iref" href="#rfc.iref.p.4"><b>14.9.1</b></a></li>
                     </ul>
                  </li>
                  <li class="indline1">Public header&nbsp;&nbsp;<a class="iref" href="#rfc.iref.p.11"><b>19.6.3</b></a></li>
                  <li class="indline1">PUT method&nbsp;&nbsp;<a class="iref" href="#rfc.xref.PUT.1">5.1.1</a>, <a class="iref" href="#rfc.iref.p.3"><b>9.6</b></a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.R" href="#rfc.index.R"><b>R</b></a><ul class="ind">
                  <li class="indline1">Range header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.range.1">3.12</a>, <a class="iref" href="#rfc.xref.header.range.2">5.3</a>, <a class="iref" href="#rfc.xref.header.range.3">9.3</a>, <a class="iref" href="#rfc.xref.header.range.4">10.2.7</a>, <a class="iref" href="#rfc.xref.header.range.5">10.4.17</a>, <a class="iref" href="#rfc.xref.header.range.6">14.25</a>, <a class="iref" href="#rfc.iref.r.5"><b>14.35</b></a></li>
                  <li class="indline1">Referer header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.referer.1">5.3</a>, <a class="iref" href="#rfc.iref.r.6"><b>14.36</b></a></li>
                  <li class="indline1">representation&nbsp;&nbsp;<a class="iref" href="#rfc.iref.r.4">1.3</a></li>
                  <li class="indline1">request&nbsp;&nbsp;<a class="iref" href="#rfc.iref.r.1">1.3</a></li>
                  <li class="indline1">resource&nbsp;&nbsp;<a class="iref" href="#rfc.iref.r.3">1.3</a></li>
                  <li class="indline1">response&nbsp;&nbsp;<a class="iref" href="#rfc.iref.r.2">1.3</a></li>
                  <li class="indline1">Retry-After header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.retry-after.1">6.2</a>, <a class="iref" href="#rfc.iref.r.7"><b>14.37</b></a></li>
                  <li class="indline1"><em>RFC1036</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC1036.1">3.3.1</a>, <a class="iref" href="#RFC1036"><b>17</b></a></li>
                  <li class="indline1"><em>RFC1123</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC1123.1">3.3.1</a>, <a class="iref" href="#rfc.xref.RFC1123.2">14.18</a>, <a class="iref" href="#rfc.xref.RFC1123.3">14.22</a>, <a class="iref" href="#RFC1123"><b>17</b></a></li>
                  <li class="indline1"><em>RFC1305</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC1305.1">13.2.3</a>, <a class="iref" href="#rfc.xref.RFC1305.2">14.18</a>, <a class="iref" href="#RFC1305"><b>17</b></a></li>
                  <li class="indline1"><em>RFC1436</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC1436.1">1.1</a>, <a class="iref" href="#RFC1436"><b>17</b></a></li>
                  <li class="indline1"><em>RFC1590</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC1590.1">3.7</a>, <a class="iref" href="#rfc.xref.RFC1590.2">3.7</a>, <a class="iref" href="#RFC1590"><b>17</b></a>, <a class="iref" href="#rfc.xref.RFC1590.3">19.1</a></li>
                  <li class="indline1"><em>RFC1630</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC1630.1">1.1</a>, <a class="iref" href="#rfc.xref.RFC1630.2">3.2</a>, <a class="iref" href="#RFC1630"><b>17</b></a></li>
                  <li class="indline1"><em>RFC1700</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC1700.1">1.4</a>, <a class="iref" href="#rfc.xref.RFC1700.2">3.4</a>, <a class="iref" href="#rfc.xref.RFC1700.3">3.4</a>, <a class="iref" href="#rfc.xref.RFC1700.4">3.7</a>, <a class="iref" href="#RFC1700"><b>17</b></a></li>
                  <li class="indline1"><em>RFC1737</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC1737.1">1.1</a>, <a class="iref" href="#rfc.xref.RFC1737.2">3.2</a>, <a class="iref" href="#RFC1737"><b>17</b></a></li>
                  <li class="indline1"><em>RFC1738</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC1738.1">1.1</a>, <a class="iref" href="#rfc.xref.RFC1738.2">3.2</a>, <a class="iref" href="#rfc.xref.RFC1738.3">3.2.1</a>, <a class="iref" href="#RFC1738"><b>17</b></a></li>
                  <li class="indline1"><em>RFC1766</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC1766.1">3.10</a>, <a class="iref" href="#RFC1766"><b>17</b></a></li>
                  <li class="indline1"><em>RFC1806</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC1806.1">15.5</a>, <a class="iref" href="#RFC1806"><b>17</b></a>, <a class="iref" href="#rfc.xref.RFC1806.2">19.5.1</a></li>
                  <li class="indline1"><em>RFC1808</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC1808.1">3.2.1</a>, <a class="iref" href="#rfc.xref.RFC1808.2">3.2.1</a>, <a class="iref" href="#RFC1808"><b>17</b></a></li>
                  <li class="indline1"><em>RFC1864</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC1864.1">14.15</a>, <a class="iref" href="#RFC1864"><b>17</b></a></li>
                  <li class="indline1"><em>RFC1866</em>&nbsp;&nbsp;<a class="iref" href="#RFC1866"><b>17</b></a></li>
                  <li class="indline1"><em>RFC1867</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC1867.1">3.7.2</a>, <a class="iref" href="#RFC1867"><b>17</b></a></li>
                  <li class="indline1"><em>RFC1900</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC1900.1">3.2.2</a>, <a class="iref" href="#rfc.xref.RFC1900.2">15.3</a>, <a class="iref" href="#RFC1900"><b>17</b></a></li>
                  <li class="indline1"><em>RFC1945</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC1945.1">1.1</a>, <a class="iref" href="#RFC1945"><b>17</b></a></li>
                  <li class="indline1"><em>RFC1950</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC1950.1">3.5</a>, <a class="iref" href="#RFC1950"><b>17</b></a></li>
                  <li class="indline1"><em>RFC1951</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC1951.1">3.5</a>, <a class="iref" href="#RFC1951"><b>17</b></a></li>
                  <li class="indline1"><em>RFC1952</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC1952.1">3.5</a>, <a class="iref" href="#RFC1952"><b>17</b></a></li>
                  <li class="indline1"><em>RFC2026</em>&nbsp;&nbsp;<a class="iref" href="#RFC2026"><b>17</b></a></li>
                  <li class="indline1"><em>RFC2045</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2045.1">1.1</a>, <a class="iref" href="#rfc.xref.RFC2045.2">3.6</a>, <a class="iref" href="#rfc.xref.RFC2045.3">16</a>, <a class="iref" href="#RFC2045"><b>17</b></a>, <a class="iref" href="#rfc.xref.RFC2045.4">19.4</a>, <a class="iref" href="#rfc.xref.RFC2045.5">19.4.1</a>, <a class="iref" href="#rfc.xref.RFC2045.6">19.4.2</a></li>
                  <li class="indline1"><em>RFC2046</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2046.1">3.7.2</a>, <a class="iref" href="#rfc.xref.RFC2046.2">3.7.2</a>, <a class="iref" href="#RFC2046"><b>17</b></a>, <a class="iref" href="#rfc.xref.RFC2046.3">19.2</a><ul class="ind">
                        <li class="indline1"><em>Section 5.1.1</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2046.1">3.7.2</a></li>
                     </ul>
                  </li>
                  <li class="indline1"><em>RFC2047</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2047.1">2.2</a>, <a class="iref" href="#rfc.xref.RFC2047.2">14.46</a>, <a class="iref" href="#RFC2047"><b>17</b></a></li>
                  <li class="indline1"><em>RFC2049</em>&nbsp;&nbsp;<a class="iref" href="#RFC2049"><b>17</b></a>, <a class="iref" href="#rfc.xref.RFC2049.1">19.4.2</a>, <a class="iref" href="#rfc.xref.RFC2049.2">19.4.2</a><ul class="ind">
                        <li class="indline1"><em>Section 4</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2049.1">19.4.2</a></li>
                     </ul>
                  </li>
                  <li class="indline1"><em>RFC2068</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2068.1">§</a>, <a class="iref" href="#rfc.xref.RFC2068.2">3.1</a>, <a class="iref" href="#rfc.xref.RFC2068.3">8.1.3</a>, <a class="iref" href="#rfc.xref.RFC2068.4">10.3.5</a>, <a class="iref" href="#RFC2068"><b>17</b></a>, <a class="iref" href="#rfc.xref.RFC2068.5">19.6</a>, <a class="iref" href="#rfc.xref.RFC2068.6">19.6</a>, <a class="iref" href="#rfc.xref.RFC2068.7">19.6.2</a>, <a class="iref" href="#rfc.xref.RFC2068.8">19.6.3</a>, <a class="iref" href="#rfc.xref.RFC2068.9">19.6.3</a><ul class="ind">
                        <li class="indline1"><em>Section 14.19</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2068.4">10.3.5</a></li>
                        <li class="indline1"><em>Section 19.7.1</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2068.5">19.6</a></li>
                     </ul>
                  </li>
                  <li class="indline1"><em>RFC2069</em>&nbsp;&nbsp;<a class="iref" href="#RFC2069"><b>17</b></a></li>
                  <li class="indline1"><em>RFC2076</em>&nbsp;&nbsp;<a class="iref" href="#RFC2076"><b>17</b></a>, <a class="iref" href="#rfc.xref.RFC2076.1">19.5</a></li>
                  <li class="indline1"><em>RFC2110</em>&nbsp;&nbsp;<a class="iref" href="#RFC2110"><b>17</b></a>, <a class="iref" href="#rfc.xref.RFC2110.1">19.4.7</a>, <a class="iref" href="#rfc.xref.RFC2110.2">19.6.3</a></li>
                  <li class="indline1"><em>RFC2119</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2119.1">1.2</a>, <a class="iref" href="#RFC2119"><b>17</b></a>, <a class="iref" href="#rfc.xref.RFC2119.2">19.6.3</a></li>
                  <li class="indline1"><em>RFC2145</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2145.1">3.1</a>, <a class="iref" href="#rfc.xref.RFC2145.2">3.1</a>, <a class="iref" href="#RFC2145"><b>17</b></a></li>
                  <li class="indline1"><em>RFC2183</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2183.1">15.5</a>, <a class="iref" href="#RFC2183"><b>17</b></a></li>
                  <li class="indline1"><em>RFC2277</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2277.1">3.4</a>, <a class="iref" href="#RFC2277"><b>17</b></a></li>
                  <li class="indline1"><em>RFC2279</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2279.1">3.4</a>, <a class="iref" href="#RFC2279"><b>17</b></a></li>
                  <li class="indline1"><em>RFC2324</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2324.1">§</a>, <a class="iref" href="#rfc.xref.RFC2324.2">1.1</a>, <a class="iref" href="#RFC2324"><b>17</b></a></li>
                  <li class="indline1"><em>RFC2396</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2396.1">3.2.1</a>, <a class="iref" href="#rfc.xref.RFC2396.2">3.2.3</a>, <a class="iref" href="#rfc.xref.RFC2396.3">5.1.2</a>, <a class="iref" href="#RFC2396"><b>17</b></a></li>
                  <li class="indline1"><em>RFC2617</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2617.1">10.4.2</a>, <a class="iref" href="#rfc.xref.RFC2617.2">10.4.8</a>, <a class="iref" href="#rfc.xref.RFC2617.3">11</a>, <a class="iref" href="#rfc.xref.RFC2617.4">14.8</a>, <a class="iref" href="#rfc.xref.RFC2617.5">14.33</a>, <a class="iref" href="#rfc.xref.RFC2617.6">14.34</a>, <a class="iref" href="#rfc.xref.RFC2617.7">14.47</a>, <a class="iref" href="#RFC2617"><b>17</b></a></li>
                  <li class="indline1"><em>RFC821</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC821.1">1.1</a>, <a class="iref" href="#RFC821"><b>17</b></a></li>
                  <li class="indline1"><em>RFC822</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC822.1">1.1</a>, <a class="iref" href="#rfc.xref.RFC822.2">2.1</a>, <a class="iref" href="#rfc.xref.RFC822.3">3.3.1</a>, <a class="iref" href="#rfc.xref.RFC822.4">4.1</a>, <a class="iref" href="#rfc.xref.RFC822.5">4.2</a>, <a class="iref" href="#rfc.xref.RFC822.6">4.2</a>, <a class="iref" href="#rfc.xref.RFC822.7">14.22</a>, <a class="iref" href="#rfc.xref.RFC822.8">14.45</a>, <a class="iref" href="#rfc.xref.RFC822.9">16</a>, <a class="iref" href="#RFC822"><b>17</b></a>, <a class="iref" href="#rfc.xref.RFC822.10">19.4</a><ul class="ind">
                        <li class="indline1"><em>Section 3.1</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC822.5">4.2</a></li>
                     </ul>
                  </li>
                  <li class="indline1"><em>RFC959</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC959.1">1.1</a>, <a class="iref" href="#RFC959"><b>17</b></a></li>
                  <li class="indline1"><em>RFC977</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC977.1">1.1</a>, <a class="iref" href="#RFC977"><b>17</b></a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.S" href="#rfc.index.S"><b>S</b></a><ul class="ind">
                  <li class="indline1">s-maxage&nbsp;&nbsp;
                     <ul class="ind">
                        <li class="indline1">Cache Directive&nbsp;&nbsp;<a class="iref" href="#rfc.iref.s.45"><b>14.9.3</b></a></li>
                     </ul>
                  </li>
                  <li class="indline1">semantically transparent&nbsp;&nbsp;<a class="iref" href="#rfc.iref.s.3">1.3</a></li>
                  <li class="indline1">server&nbsp;&nbsp;<a class="iref" href="#rfc.iref.s.1">1.3</a></li>
                  <li class="indline1">Server header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.server.1">6.2</a>, <a class="iref" href="#rfc.iref.s.46"><b>14.38</b></a>, <a class="iref" href="#rfc.xref.header.server.2">15.1.2</a></li>
                  <li class="indline1"><em>Spe</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.Spe.1">8.1.1</a>, <a class="iref" href="#Spe"><b>17</b></a></li>
                  <li class="indline1">stale&nbsp;&nbsp;<a class="iref" href="#rfc.iref.s.2">1.3</a></li>
                  <li class="indline1">Status Codes&nbsp;&nbsp;
                     <ul class="ind">
                        <li class="indline1">100 Continue&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.100.1">6.1.1</a>, <a class="iref" href="#rfc.xref.status.100.2">8.2.3</a>, <a class="iref" href="#rfc.iref.s.4"><b>10.1.1</b></a></li>
                        <li class="indline1">101 Switching Protocols&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.101.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.5"><b>10.1.2</b></a></li>
                        <li class="indline1">200 OK&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.200.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.6"><b>10.2.1</b></a></li>
                        <li class="indline1">201 Created&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.201.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.7"><b>10.2.2</b></a>, <a class="iref" href="#rfc.xref.status.201.2">19.6.3</a></li>
                        <li class="indline1">202 Accepted&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.202.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.8"><b>10.2.3</b></a></li>
                        <li class="indline1">203 Non-Authoritative Information&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.203.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.9"><b>10.2.4</b></a></li>
                        <li class="indline1">204 No Content&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.204.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.10"><b>10.2.5</b></a></li>
                        <li class="indline1">205 Reset Content&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.205.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.11"><b>10.2.6</b></a></li>
                        <li class="indline1">206 Partial Content&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.206.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.12"><b>10.2.7</b></a>, <a class="iref" href="#rfc.xref.status.206.2">19.6.3</a></li>
                        <li class="indline1">300 Multiple Choices&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.300.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.13"><b>10.3.1</b></a></li>
                        <li class="indline1">301 Moved Permanently&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.301.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.14"><b>10.3.2</b></a></li>
                        <li class="indline1">302 Found&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.302.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.15"><b>10.3.3</b></a></li>
                        <li class="indline1">303 See Other&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.303.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.16"><b>10.3.4</b></a></li>
                        <li class="indline1">304 Not Modified&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.304.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.17"><b>10.3.5</b></a></li>
                        <li class="indline1">305 Use Proxy&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.305.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.18"><b>10.3.6</b></a></li>
                        <li class="indline1">306 (Unused)&nbsp;&nbsp;<a class="iref" href="#rfc.iref.s.19"><b>10.3.7</b></a></li>
                        <li class="indline1">307 Temporary Redirect&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.307.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.20"><b>10.3.8</b></a></li>
                        <li class="indline1">400 Bad Request&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.400.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.21"><b>10.4.1</b></a></li>
                        <li class="indline1">401 Unauthorized&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.401.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.22"><b>10.4.2</b></a></li>
                        <li class="indline1">402 Payment Required&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.402.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.23"><b>10.4.3</b></a></li>
                        <li class="indline1">403 Forbidden&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.403.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.24"><b>10.4.4</b></a>, <a class="iref" href="#rfc.xref.status.403.2">19.6.3</a></li>
                        <li class="indline1">404 Not Found&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.404.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.25"><b>10.4.5</b></a>, <a class="iref" href="#rfc.xref.status.404.2">19.6.3</a></li>
                        <li class="indline1">405 Method Not Allowed&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.405.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.26"><b>10.4.6</b></a></li>
                        <li class="indline1">406 Not Acceptable&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.406.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.27"><b>10.4.7</b></a></li>
                        <li class="indline1">407 Proxy Authentication Required&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.407.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.28"><b>10.4.8</b></a></li>
                        <li class="indline1">408 Request Timeout&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.408.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.29"><b>10.4.9</b></a></li>
                        <li class="indline1">409 Conflict&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.409.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.30"><b>10.4.10</b></a></li>
                        <li class="indline1">410 Gone&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.410.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.31"><b>10.4.11</b></a>, <a class="iref" href="#rfc.xref.status.410.2">19.6.3</a></li>
                        <li class="indline1">411 Length Required&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.411.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.32"><b>10.4.12</b></a></li>
                        <li class="indline1">412 Precondition Failed&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.412.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.33"><b>10.4.13</b></a></li>
                        <li class="indline1">413 Request Entity Too Large&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.413.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.34"><b>10.4.14</b></a></li>
                        <li class="indline1">414 Request-URI Too Long&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.414.1">3.2.1</a>, <a class="iref" href="#rfc.xref.status.414.2">6.1.1</a>, <a class="iref" href="#rfc.iref.s.35"><b>10.4.15</b></a></li>
                        <li class="indline1">415 Unsupported Media Type&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.415.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.36"><b>10.4.16</b></a></li>
                        <li class="indline1">416 Requested Range Not Satisfiable&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.416.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.37"><b>10.4.17</b></a>, <a class="iref" href="#rfc.xref.status.416.2">14.16</a>, <a class="iref" href="#rfc.xref.status.416.3">19.6.3</a></li>
                        <li class="indline1">417 Expectation Failed&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.417.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.38"><b>10.4.18</b></a>, <a class="iref" href="#rfc.xref.status.417.2">19.6.3</a></li>
                        <li class="indline1">500 Internal Server Error&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.500.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.39"><b>10.5.1</b></a></li>
                        <li class="indline1">501 Not Implemented&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.501.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.40"><b>10.5.2</b></a></li>
                        <li class="indline1">502 Bad Gateway&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.502.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.41"><b>10.5.3</b></a></li>
                        <li class="indline1">503 Service Unavailable&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.503.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.42"><b>10.5.4</b></a></li>
                        <li class="indline1">504 Gateway Timeout&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.504.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.43"><b>10.5.5</b></a>, <a class="iref" href="#rfc.xref.status.504.2">19.6.3</a></li>
                        <li class="indline1">505 HTTP Version Not Supported&nbsp;&nbsp;<a class="iref" href="#rfc.xref.status.505.1">6.1.1</a>, <a class="iref" href="#rfc.iref.s.44"><b>10.5.6</b></a></li>
                     </ul>
                  </li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.T" href="#rfc.index.T"><b>T</b></a><ul class="ind">
                  <li class="indline1">TE header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.te.1">3.6</a>, <a class="iref" href="#rfc.xref.header.te.2">3.6.1</a>, <a class="iref" href="#rfc.xref.header.te.3">5.3</a>, <a class="iref" href="#rfc.iref.t.3"><b>14.39</b></a>, <a class="iref" href="#rfc.xref.header.te.4">19.6.3</a></li>
                  <li class="indline1"><em>Tou1998</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.Tou1998.1">8.1.1</a>, <a class="iref" href="#Tou1998"><b>17</b></a></li>
                  <li class="indline1">TRACE method&nbsp;&nbsp;<a class="iref" href="#rfc.xref.TRACE.1">5.1.1</a>, <a class="iref" href="#rfc.iref.t.2"><b>9.8</b></a>, <a class="iref" href="#rfc.xref.TRACE.2">14.31</a></li>
                  <li class="indline1">Trailer header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.trailer.1">3.6.1</a>, <a class="iref" href="#rfc.xref.header.trailer.2">4.5</a>, <a class="iref" href="#rfc.iref.t.4"><b>14.40</b></a></li>
                  <li class="indline1">Transfer-Encoding header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.transfer-encoding.1">3.6</a>, <a class="iref" href="#rfc.xref.header.transfer-encoding.2">4.3</a>, <a class="iref" href="#rfc.xref.header.transfer-encoding.3">4.4</a>, <a class="iref" href="#rfc.xref.header.transfer-encoding.4">4.5</a>, <a class="iref" href="#rfc.iref.t.5"><b>14.41</b></a>, <a class="iref" href="#rfc.xref.header.transfer-encoding.5">19.4.6</a></li>
                  <li class="indline1">tunnel&nbsp;&nbsp;<a class="iref" href="#rfc.iref.t.1">1.3</a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.U" href="#rfc.index.U"><b>U</b></a><ul class="ind">
                  <li class="indline1">UNLINK method&nbsp;&nbsp;<a class="iref" href="#rfc.iref.u.5"><b>19.6.3</b></a></li>
                  <li class="indline1">Upgrade header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.upgrade.1">4.5</a>, <a class="iref" href="#rfc.xref.header.upgrade.2">10.1.2</a>, <a class="iref" href="#rfc.iref.u.3"><b>14.42</b></a></li>
                  <li class="indline1">upstream&nbsp;&nbsp;<a class="iref" href="#rfc.iref.u.2">1.3</a></li>
                  <li class="indline1">URI header&nbsp;&nbsp;<a class="iref" href="#rfc.iref.u.6"><b>19.6.3</b></a></li>
                  <li class="indline1"><em>USASCII</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.USASCII.1">2.2</a>, <a class="iref" href="#USASCII"><b>17</b></a></li>
                  <li class="indline1">user agent&nbsp;&nbsp;<a class="iref" href="#rfc.iref.u.1">1.3</a></li>
                  <li class="indline1">User-Agent header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.user-agent.1">5.3</a>, <a class="iref" href="#rfc.xref.header.user-agent.2">12.1</a>, <a class="iref" href="#rfc.iref.u.4"><b>14.43</b></a>, <a class="iref" href="#rfc.xref.header.user-agent.3">15.1.2</a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.V" href="#rfc.index.V"><b>V</b></a><ul class="ind">
                  <li class="indline1">validator&nbsp;&nbsp;<a class="iref" href="#rfc.iref.v.2">1.3</a></li>
                  <li class="indline1">variant&nbsp;&nbsp;<a class="iref" href="#rfc.iref.v.1">1.3</a></li>
                  <li class="indline1">Vary header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.vary.1">6.2</a>, <a class="iref" href="#rfc.xref.header.vary.2">12.1</a>, <a class="iref" href="#rfc.xref.header.vary.3">13.3.2</a>, <a class="iref" href="#rfc.xref.header.vary.4">13.6</a>, <a class="iref" href="#rfc.xref.header.vary.5">14.19</a>, <a class="iref" href="#rfc.xref.header.vary.6">14.24</a>, <a class="iref" href="#rfc.xref.header.vary.7">14.26</a>, <a class="iref" href="#rfc.iref.v.3"><b>14.44</b></a></li>
                  <li class="indline1">Via header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.via.1">4.5</a>, <a class="iref" href="#rfc.xref.header.via.2">9.8</a>, <a class="iref" href="#rfc.xref.header.via.3">14.38</a>, <a class="iref" href="#rfc.iref.v.4"><b>14.45</b></a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.W" href="#rfc.index.W"><b>W</b></a><ul class="ind">
                  <li class="indline1"><em>WAIS</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.WAIS.1">1.1</a>, <a class="iref" href="#WAIS"><b>17</b></a></li>
                  <li class="indline1">Warning header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.warning.1">4.5</a>, <a class="iref" href="#rfc.xref.header.warning.2">13.1.1</a>, <a class="iref" href="#rfc.xref.header.warning.3">13.1.2</a>, <a class="iref" href="#rfc.xref.header.warning.4">13.1.2</a>, <a class="iref" href="#rfc.xref.header.warning.5">13.5.2</a>, <a class="iref" href="#rfc.xref.header.warning.6">13.5.3</a>, <a class="iref" href="#rfc.iref.w.1"><b>14.46</b></a>, <a class="iref" href="#rfc.xref.header.warning.7">19.6.3</a></li>
                  <li class="indline1">WWW-Authenticate header&nbsp;&nbsp;<a class="iref" href="#rfc.xref.header.www-authenticate.1">6.2</a>, <a class="iref" href="#rfc.xref.header.www-authenticate.2">10.4.2</a>, <a class="iref" href="#rfc.iref.w.2"><b>14.47</b></a></li>
               </ul>
            </li>
         </ul>
      </div>
   </body>
</html>