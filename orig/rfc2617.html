<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en">
   <head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>HTTP Authentication: Basic and Digest Access Authentication</title><style type="text/css" title="Xml2Rfc (sans serif)">
a {
  text-decoration: none;
}
a.smpl {
  color: black;
}
a:hover {
  text-decoration: underline;
}
a:active {
  text-decoration: underline;
}
address {
  margin-top: 1em;
  margin-left: 2em;
  font-style: normal;
}
body {
  color: black;
  font-family: verdana, helvetica, arial, sans-serif;
  font-size: 10pt;
}
cite {
  font-style: normal;
}
dd {
  margin-right: 2em;
}
dl {
  margin-left: 2em;
}

dl.empty dd {
  margin-top: .5em;
}
dl p {
  margin-left: 0em;
}
dt {
  margin-top: .5em;
}
h1 {
  font-size: 14pt;
  line-height: 21pt;
  page-break-after: avoid;
}
h1.np {
  page-break-before: always;
}
h1 a {
  color: #333333;
}
h2 {
  font-size: 12pt;
  line-height: 15pt;
  page-break-after: avoid;
}
h3, h4, h5, h6 {
  font-size: 10pt;
  page-break-after: avoid;
}
h2 a, h3 a, h4 a, h5 a, h6 a {
  color: black;
}
img {
  margin-left: 3em;
}
li {
  margin-left: 2em;
  margin-right: 2em;
}
ol {
  margin-left: 2em;
  margin-right: 2em;
}
ol p {
  margin-left: 0em;
}
p {
  margin-left: 2em;
  margin-right: 2em;
}
pre {
  margin-left: 3em;
  background-color: lightyellow;
  padding: .25em;
}
pre.text2 {
  border-style: dotted;
  border-width: 1px;
  background-color: #f0f0f0;
  width: 69em;
}
pre.inline {
  background-color: white;
  padding: 0em;
}
pre.text {
  border-style: dotted;
  border-width: 1px;
  background-color: #f8f8f8;
  width: 69em;
}
pre.drawing {
  border-style: solid;
  border-width: 1px;
  background-color: #f8f8f8;
  padding: 2em;
}
table {
  margin-left: 2em;
}
table.header {
  width: 95%;
  font-size: 10pt;
  color: white;
}
td.top {
  vertical-align: top;
}
td.topnowrap {
  vertical-align: top;
  white-space: nowrap; 
}
td.header {
  background-color: gray;
  width: 50%;
}
td.header a {
  color: white;
}
td.reference {
  vertical-align: top;
  white-space: nowrap;
  padding-right: 1em;
}
thead {
  display:table-header-group;
}
ul.toc {
  list-style: none;
  margin-left: 1.5em;
  margin-right: 0em;
  padding-left: 0em;
}
li.tocline0 {
  line-height: 150%;
  font-weight: bold;
  font-size: 10pt;
  margin-left: 0em;
  margin-right: 0em;
}
li.tocline1 {
  line-height: normal;
  font-weight: normal;
  font-size: 9pt;
  margin-left: 0em;
  margin-right: 0em;
}
li.tocline2 {
  font-size: 0pt;
}
ul p {
  margin-left: 0em;
}
ul.ind {
  list-style: none;
  margin-left: 1.5em;
  margin-right: 0em;
  padding-left: 0em;
  page-break-before: avoid;
}
li.indline0 {
  font-weight: bold;
  line-height: 200%;
  margin-left: 0em;
  margin-right: 0em;
}
li.indline1 {
  font-weight: normal;
  line-height: 150%;
  margin-left: 0em;
  margin-right: 0em;
}
.bcp14 {
  font-style: normal;
  text-transform: lowercase;
  font-variant: small-caps;
}
.comment {
  background-color: yellow;
}
.center {
  text-align: center;
}
.error {
  color: red;
  font-style: italic;
  font-weight: bold;
}
.figure {
  font-weight: bold;
  text-align: center;
  font-size: 9pt;
}
.filename {
  color: #333333;
  font-weight: bold;
  font-size: 12pt;
  line-height: 21pt;
  text-align: center;
}
.fn {
  font-weight: bold;
}
.hidden {
  display: none;
}
.left {
  text-align: left;
}
.right {
  text-align: right;
}
.title {
  color: #990000;
  font-size: 18pt;
  line-height: 18pt;
  font-weight: bold;
  text-align: center;
  margin-top: 36pt;
}
.vcardline {
  display: block;
}
.warning {
  font-size: 14pt;
  background-color: yellow;
}


@media print {
  .noprint {
    display: none;
  }
  
  a {
    color: black;
    text-decoration: none;
  }

  table.header {
    width: 90%;
  }

  td.header {
    width: 50%;
    color: black;
    background-color: white;
    vertical-align: top;
    font-size: 12pt;
  }

  ul.toc a::after {
    content: leader('.') target-counter(attr(href), page);
  }
  
  a.iref {
    content: target-counter(attr(href), page);
  }
  
  .print2col {
    column-count: 2;
    -moz-column-count: 2;
    column-fill: auto;
  }
}

@page {
  @top-left {
       content: "RFC 2617"; 
  } 
  @top-right {
       content: "June 1999"; 
  } 
  @top-center {
       content: "HTTP Authentication"; 
  } 
  @bottom-left {
       content: "Franks, et al."; 
  } 
  @bottom-center {
       content: "Standards Track"; 
  } 
  @bottom-right {
       content: "[Page " counter(page) "]"; 
  } 
}

@page:first { 
    @top-left {
      content: normal;
    }
    @top-right {
      content: normal;
    }
    @top-center {
      content: normal;
    }
}
</style><link rel="Contents" href="#rfc.toc">
      <link rel="Author" href="#rfc.authors">
      <link rel="Copyright" href="#rfc.copyright">
      <link rel="Index" href="#rfc.index">
      <link rel="Chapter" title="1 Access Authentication" href="#rfc.section.1">
      <link rel="Chapter" title="2 Basic Authentication Scheme" href="#rfc.section.2">
      <link rel="Chapter" title="3 Digest Access Authentication Scheme" href="#rfc.section.3">
      <link rel="Chapter" title="4 Security Considerations" href="#rfc.section.4">
      <link rel="Chapter" title="5 Sample implementation" href="#rfc.section.5">
      <link rel="Chapter" title="6 Acknowledgments" href="#rfc.section.6">
      <link rel="Chapter" href="#rfc.section.7" title="7 References">
      <link rel="Alternate" title="Authorative ASCII Version" href="http://www.ietf.org/rfc/rfc2617.txt">
      <link rel="Help" title="Additional Information on tools.ietf.org" href="http://tools.ietf.org/html/rfc2617">
      <meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.438, 2009-05-27 13:34:05, XSLT vendor: SAXON 8.9 from Saxonica http://www.saxonica.com/">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.Creator" content="Franks, J.">
      <meta name="DC.Creator" content="Hallam-Baker, P.M.">
      <meta name="DC.Creator" content="Hostetler, J.L.">
      <meta name="DC.Creator" content="Lawrence, S.D.">
      <meta name="DC.Creator" content="Leach, P.J.">
      <meta name="DC.Creator" content="Luotonen, A.">
      <meta name="DC.Creator" content="Stewart, L.">
      <meta name="DC.Identifier" content="urn:ietf:rfc:2617">
      <meta name="DC.Date.Issued" scheme="ISO8601" content="1999-06">
      <meta name="DC.Relation.Replaces" content="urn:ietf:rfc:2069">
      <meta name="DC.Description.Abstract" content="&#34;HTTP/1.0&#34;, includes the specification for a Basic Access Authentication scheme. This scheme is not considered to be a secure method of user authentication (unless used in conjunction with some external secure system such as SSL ), as the user name and password are passed over the network as cleartext. This document also provides the specification for HTTP's authentication framework, the original Basic authentication scheme and a scheme based on cryptographic hashes, referred to as &#34;Digest Access Authentication&#34;. It is therefore also intended to serve as a replacement for RFC 2069 . Some optional elements specified by RFC 2069 have been removed from this specification due to problems found since its publication; other new elements have been added for compatibility, those new elements have been made optional, but are strongly recommended. Like Basic, Digest access authentication verifies that both parties to a communication know a shared secret (a password); unlike Basic, this verification can be done without sending the password in the clear, which is Basic's biggest weakness. As with most other authentication protocols, the greatest sources of risks are usually found not in the core protocol itself but in policies and procedures surrounding its use.">
      <meta name="DC.isPartOf" content="urn:ISSN:2070-1721">
   </head>
   <body>
      <table summary="header information" class="header" border="0" cellpadding="1" cellspacing="1">
         <tr>
            <td class="header left">Network Working Group</td>
            <td class="header right">J. Franks</td>
         </tr>
         <tr>
            <td class="header left">Request for Comments: 2617</td>
            <td class="header right">Northwestern University, Department of Mathematics</td>
         </tr>
         <tr>
            <td class="header left">Obsoletes: <a href="http://tools.ietf.org/html/rfc2069">2069</a></td>
            <td class="header right">P.M. Hallam-Baker</td>
         </tr>
         <tr>
            <td class="header left">Category: Standards Track</td>
            <td class="header right">Verisign Inc.</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">J.L. Hostetler</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">AbiSource, Inc.</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">S.D. Lawrence</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">Agranat Systems, Inc.</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">P.J. Leach</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">Microsoft Corporation</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">A. Luotonen</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">Netscape Communications Corporation</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">L. Stewart</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">Open Market, Inc.</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">June 1999</td>
         </tr>
      </table>
      <p class="title">HTTP Authentication: Basic and Digest Access Authentication</p>
      <h1><a id="rfc.status" href="#rfc.status">Status of this Memo</a></h1>
      <p>This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions
         for improvements. Please refer to the current edition of the “Internet Official Protocol Standards” (STD 1) for the standardization
         state and status of this protocol. Distribution of this memo is unlimited.
      </p>
      <h1><a id="rfc.copyrightnotice" href="#rfc.copyrightnotice">Copyright Notice</a></h1>
      <p>Copyright © The Internet Society (1999). All Rights Reserved.</p>
      <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1> 
      <p>"HTTP/1.0", includes the specification for a Basic Access Authentication scheme. This scheme is not considered to be a secure
         method of user authentication (unless used in conjunction with some external secure system such as SSL <a href="#RFC2246" id="rfc.xref.RFC2246.1"><cite title="The TLS Protocol Version 1.0">[5]</cite></a>), as the user name and password are passed over the network as cleartext.
      </p>
      <p>This document also provides the specification for HTTP's authentication framework, the original Basic authentication scheme
         and a scheme based on cryptographic hashes, referred to as "Digest Access Authentication". It is therefore also intended to
         serve as a replacement for RFC 2069 <a href="#RFC2069" id="rfc.xref.RFC2069.1"><cite title="An Extension to HTTP : Digest Access Authentication">[6]</cite></a>. Some optional elements specified by RFC 2069 have been removed from this specification due to problems found since its publication;
         other new elements have been added for compatibility, those new elements have been made optional, but are strongly recommended.
      </p>
      <p>Like Basic, Digest access authentication verifies that both parties to a communication know a shared secret (a password);
         unlike Basic, this verification can be done without sending the password in the clear, which is Basic's biggest weakness.
         As with most other authentication protocols, the greatest sources of risks are usually found not in the core protocol itself
         but in policies and procedures surrounding its use.
      </p> 
      <hr class="noprint">
      <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
      <ul class="toc">
         <li class="tocline0">1.&nbsp;&nbsp;&nbsp;<a href="#rfc.section.1">Access Authentication</a><ul class="toc">
               <li class="tocline1">1.1&nbsp;&nbsp;&nbsp;<a href="#rfc.section.1.1">Reliance on the HTTP/1.1 Specification</a></li>
               <li class="tocline1">1.2&nbsp;&nbsp;&nbsp;<a href="#access.authentication.framework">Access Authentication Framework</a></li>
            </ul>
         </li>
         <li class="tocline0">2.&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2">Basic Authentication Scheme</a></li>
         <li class="tocline0">3.&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3">Digest Access Authentication Scheme</a><ul class="toc">
               <li class="tocline1">3.1&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.1">Introduction</a><ul class="toc">
                     <li class="tocline1">3.1.1&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.1.1">Purpose</a></li>
                     <li class="tocline1">3.1.2&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.1.2">Overall Operation</a></li>
                     <li class="tocline1">3.1.3&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.1.3">Representation of digest values</a></li>
                     <li class="tocline1">3.1.4&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.1.4">Limitations</a></li>
                  </ul>
               </li>
               <li class="tocline1">3.2&nbsp;&nbsp;&nbsp;<a href="#specification.of.digest.headers">Specification of Digest Headers</a><ul class="toc">
                     <li class="tocline1">3.2.1&nbsp;&nbsp;&nbsp;<a href="#the.www-authenticate.response.header">The WWW-Authenticate Response Header</a></li>
                     <li class="tocline1">3.2.2&nbsp;&nbsp;&nbsp;<a href="#the.authorization.request.header">The Authorization Request Header</a><ul class="toc">
                           <li class="tocline1">3.2.2.1&nbsp;&nbsp;&nbsp;<a href="#request-digest">Request-Digest</a></li>
                           <li class="tocline1">3.2.2.2&nbsp;&nbsp;&nbsp;<a href="#A1">A1</a></li>
                           <li class="tocline1">3.2.2.3&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.2.2.3">A2</a></li>
                           <li class="tocline1">3.2.2.4&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.2.2.4">Directive values and quoted-string</a></li>
                           <li class="tocline1">3.2.2.5&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.2.2.5">Various considerations</a></li>
                        </ul>
                     </li>
                     <li class="tocline1">3.2.3&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.2.3">The Authentication-Info Header</a></li>
                  </ul>
               </li>
               <li class="tocline1">3.3&nbsp;&nbsp;&nbsp;<a href="#digest.operation">Digest Operation</a></li>
               <li class="tocline1">3.4&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.4">Security Protocol Negotiation</a></li>
               <li class="tocline1">3.5&nbsp;&nbsp;&nbsp;<a href="#specification.of.digest.headers.example">Example</a></li>
               <li class="tocline1">3.6&nbsp;&nbsp;&nbsp;<a href="#proxy-authentication.and.proxy-authorization">Proxy-Authentication and Proxy-Authorization</a></li>
            </ul>
         </li>
         <li class="tocline0">4.&nbsp;&nbsp;&nbsp;<a href="#security.considerations">Security Considerations</a><ul class="toc">
               <li class="tocline1">4.1&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.1">Authentication of Clients using Basic Authentication</a></li>
               <li class="tocline1">4.2&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.2">Authentication of Clients using Digest Authentication</a></li>
               <li class="tocline1">4.3&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.3">Limited Use Nonce Values</a></li>
               <li class="tocline1">4.4&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.4">Comparison of Digest with Basic Authentication</a></li>
               <li class="tocline1">4.5&nbsp;&nbsp;&nbsp;<a href="#replay.attacks">Replay Attacks</a></li>
               <li class="tocline1">4.6&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.6">Weakness Created by Multiple Authentication Schemes</a></li>
               <li class="tocline1">4.7&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.7">Online dictionary attacks</a></li>
               <li class="tocline1">4.8&nbsp;&nbsp;&nbsp;<a href="#man.in.the.middle">Man in the Middle</a></li>
               <li class="tocline1">4.9&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.9">Chosen plaintext attacks</a></li>
               <li class="tocline1">4.10&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.10">Precomputed dictionary attacks</a></li>
               <li class="tocline1">4.11&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.11">Batch brute force attacks</a></li>
               <li class="tocline1">4.12&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.12">Spoofing by Counterfeit Servers</a></li>
               <li class="tocline1">4.13&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.13">Storing passwords</a></li>
               <li class="tocline1">4.14&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.14">Summary</a></li>
            </ul>
         </li>
         <li class="tocline0">5.&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5">Sample implementation</a></li>
         <li class="tocline0">6.&nbsp;&nbsp;&nbsp;<a href="#rfc.section.6">Acknowledgments</a></li>
         <li class="tocline0">7.&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a></li>
         <li class="tocline0"><a href="#rfc.authors">Authors' Addresses</a></li>
         <li class="tocline0"><a href="#rfc.ipr">Intellectual Property and Copyright Statements</a></li>
         <li class="tocline0"><a href="#rfc.index">Index</a></li>
      </ul>
      <h1 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;Access Authentication
      </h1>
      <h2 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1</a>&nbsp;Reliance on the HTTP/1.1 Specification
      </h2>
      <p id="rfc.section.1.1.p.1">This specification is a companion to the HTTP/1.1 specification <a href="#RFC2616" id="rfc.xref.RFC2616.1"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite></a>. It uses the augmented BNF section <a href="http://tools.ietf.org/html/rfc2616#section-2.1" title="Augmented BNF" id="rfc.xref.RFC2616.2">2.1</a> of that document, and relies on both the non-terminals defined in that document and other aspects of the HTTP/1.1 specification.
      </p>
      <h2 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2</a>&nbsp;<a id="access.authentication.framework" href="#access.authentication.framework">Access Authentication Framework</a></h2>
      <p id="rfc.section.1.2.p.1">HTTP provides a simple challenge-response authentication mechanism that <em class="bcp14">MAY</em> be used by a server to challenge a client request and by a client to provide authentication information. It uses an extensible,
         case-insensitive token to identify the authentication scheme, followed by a comma-separated list of attribute-value pairs
         which carry the parameters necessary for achieving authentication via that scheme.
      </p>
      <div id="rfc.figure.u.1"></div><pre class="inline"><span id="rfc.iref.a.1"></span>      auth-scheme    = token
<span id="rfc.iref.a.2"></span>      auth-param     = token "=" ( token | quoted-string )
</pre><p id="rfc.section.1.2.p.3">The 401 (Unauthorized) response message is used by an origin server to challenge the authorization of a user agent. This response <em class="bcp14">MUST</em> include a WWW-Authenticate header field containing at least one challenge applicable to the requested resource. The 407 (Proxy
         Authentication Required) response message is used by a proxy to challenge the authorization of a client and <em class="bcp14">MUST</em> include a Proxy-Authenticate header field containing at least one challenge applicable to the proxy for the requested resource.
      </p>
      <div id="rfc.figure.u.2"></div><pre class="inline"><span id="rfc.iref.c.1"></span>      challenge   = auth-scheme 1*SP 1#auth-param
</pre><p id="rfc.section.1.2.p.5">Note: User agents will need to take special care in parsing the WWW-Authenticate or Proxy-Authenticate header field value
         if it contains more than one challenge, or if more than one WWW-Authenticate header field is provided, since the contents
         of a challenge may itself contain a comma-separated list of authentication parameters.
      </p>
      <p id="rfc.section.1.2.p.6">The authentication parameter realm is defined for all authentication schemes:</p>
      <div id="rfc.figure.u.3"></div><pre class="inline"><span id="rfc.iref.r.1"></span>      realm       = "realm" "=" realm-value
<span id="rfc.iref.r.2"></span>      realm-value = quoted-string
</pre><p id="rfc.section.1.2.p.8">The realm directive (case-insensitive) is required for all authentication schemes that issue a challenge. The realm value
         (case-sensitive), in combination with the canonical root URL (the absoluteURI for the server whose abs_path is empty; see
         section <a href="http://tools.ietf.org/html/rfc2616#section-5.1.2" title="Request-URI" id="rfc.xref.RFC2616.3">5.1.2</a> of <a href="#RFC2616" id="rfc.xref.RFC2616.4"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite></a>) of the server being accessed, defines the protection space. These realms allow the protected resources on a server to be
         partitioned into a set of protection spaces, each with its own authentication scheme and/or authorization database. The realm
         value is a string, generally assigned by the origin server, which may have additional semantics specific to the authentication
         scheme. Note that there may be multiple challenges with the same auth-scheme but different realms.
      </p>
      <p id="rfc.section.1.2.p.9">A user agent that wishes to authenticate itself with an origin server--usually, but not necessarily, after receiving a 401
         (Unauthorized)--MAY do so by including an Authorization header field with the request. A client that wishes to authenticate
         itself with a proxy--usually, but not necessarily, after receiving a 407 (Proxy Authentication Required)--MAY do so by including
         a Proxy-Authorization header field with the request. Both the Authorization field value and the Proxy-Authorization field
         value consist of credentials containing the authentication information of the client for the realm of the resource being requested.
         The user agent <em class="bcp14">MUST</em> choose to use one of the challenges with the strongest auth-scheme it understands and request credentials from the user based
         upon that challenge.
      </p>
      <div id="rfc.figure.u.4"></div><pre class="inline"><span id="rfc.iref.c.2"></span>   credentials = auth-scheme #auth-param
</pre><p id="rfc.section.1.2.p.11"> </p>
      <dl class="empty">
         <dd>Note that many browsers will only recognize Basic and will require that it be the first auth-scheme presented. Servers should
            only include Basic if it is minimally acceptable.
         </dd>
      </dl>
      <p id="rfc.section.1.2.p.12">The protection space determines the domain over which credentials can be automatically applied. If a prior request has been
         authorized, the same credentials <em class="bcp14">MAY</em> be reused for all other requests within that protection space for a period of time determined by the authentication scheme,
         parameters, and/or user preference. Unless otherwise defined by the authentication scheme, a single protection space cannot
         extend outside the scope of its server.
      </p>
      <p id="rfc.section.1.2.p.13">If the origin server does not wish to accept the credentials sent with a request, it <em class="bcp14">SHOULD</em> return a 401 (Unauthorized) response. The response <em class="bcp14">MUST</em> include a WWW-Authenticate header field containing at least one (possibly new) challenge applicable to the requested resource.
         If a proxy does not accept the credentials sent with a request, it <em class="bcp14">SHOULD</em> return a 407 (Proxy Authentication Required). The response <em class="bcp14">MUST</em> include a Proxy-Authenticate header field containing a (possibly new) challenge applicable to the proxy for the requested
         resource.
      </p>
      <p id="rfc.section.1.2.p.14">The HTTP protocol does not restrict applications to this simple challenge-response mechanism for access authentication. Additional
         mechanisms <em class="bcp14">MAY</em> be used, such as encryption at the transport level or via message encapsulation, and with additional header fields specifying
         authentication information. However, these additional mechanisms are not defined by this specification.
      </p>
      <p id="rfc.section.1.2.p.15">Proxies <em class="bcp14">MUST</em> be completely transparent regarding user agent authentication by origin servers. That is, they must forward the WWW-Authenticate
         and Authorization headers untouched, and follow the rules found in section <a href="http://tools.ietf.org/html/rfc2616#section-14.8" title="Authorization" id="rfc.xref.RFC2616.5">14.8</a> of <a href="#RFC2616" id="rfc.xref.RFC2616.6"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite></a>. Both the Proxy-Authenticate and the Proxy-Authorization header fields are hop-by-hop headers (see section <a href="http://tools.ietf.org/html/rfc2616#section-13.5.1" title="End-to-end and Hop-by-hop Headers" id="rfc.xref.RFC2616.7">13.5.1</a> of <a href="#RFC2616" id="rfc.xref.RFC2616.8"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite></a>).
      </p>
      <h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;Basic Authentication Scheme
      </h1>
      <p id="rfc.section.2.p.1">The "basic" authentication scheme is based on the model that the client must authenticate itself with a user-ID and a password
         for each realm. The realm value should be considered an opaque string which can only be compared for equality with other realms
         on that server. The server will service the request only if it can validate the user-ID and password for the protection space
         of the Request-URI. There are no optional authentication parameters.
      </p>
      <p id="rfc.section.2.p.2">For Basic, the framework above is utilized as follows:</p>
      <div id="rfc.figure.u.5"></div><pre class="inline"><span id="rfc.iref.c.3"></span>      challenge   = "Basic" realm
<span id="rfc.iref.c.4"></span>      credentials = "Basic" basic-credentials
</pre><p id="rfc.section.2.p.4">Upon receipt of an unauthorized request for a URI within the protection space, the origin server <em class="bcp14">MAY</em> respond with a challenge like the following:
      </p>
      <div id="rfc.figure.u.6"></div><pre class="text">      WWW-Authenticate: Basic realm="WallyWorld"
</pre><p id="rfc.section.2.p.6">where "WallyWorld" is the string assigned by the server to identify the protection space of the Request-URI. A proxy may respond
         with the same challenge using the Proxy-Authenticate header field.
      </p>
      <p id="rfc.section.2.p.7">To receive authorization, the client sends the userid and password, separated by a single colon (":") character, within a
         base64 <a href="#RFC2396" id="rfc.xref.RFC2396.1"><cite title="Uniform Resource Identifiers (URI): Generic Syntax">[7]</cite></a> encoded string in the credentials.
      </p>
      <div id="rfc.figure.u.7"></div><pre class="inline"><span id="rfc.iref.b.1"></span>      basic-credentials = base64-user-pass
<span id="rfc.iref.b.2"></span>      base64-user-pass  = &lt;base64 [4] encoding of user-pass,
                       except not limited to 76 char/line&gt;
<span id="rfc.iref.u.1"></span>      user-pass   = userid ":" password
<span id="rfc.iref.u.2"></span>      userid      = *&lt;TEXT excluding ":"&gt;
<span id="rfc.iref.p.1"></span>      password    = *TEXT
</pre><p id="rfc.section.2.p.9">Userids might be case sensitive.</p>
      <p id="rfc.section.2.p.10">If the user agent wishes to send the userid "Aladdin" and password "open sesame", it would use the following header field:</p>
      <div id="rfc.figure.u.8"></div><pre class="text">      Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
</pre><p id="rfc.section.2.p.12">A client <em class="bcp14">SHOULD</em> assume that all paths at or deeper than the depth of the last symbolic element in the path field of the Request-URI also are
         within the protection space specified by the Basic realm value of the current challenge. A client <em class="bcp14">MAY</em> preemptively send the corresponding Authorization header with requests for resources in that space without receipt of another
         challenge from the server. Similarly, when a client sends a request to a proxy, it may reuse a userid and password in the
         Proxy-Authorization header field without receiving another challenge from the proxy server. See <a href="#security.considerations" title="Security Considerations">Section&nbsp;4</a> for security considerations associated with Basic authentication.
      </p>
      <h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;Digest Access Authentication Scheme
      </h1>
      <h2 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1</a>&nbsp;Introduction
      </h2>
      <h3 id="rfc.section.3.1.1"><a href="#rfc.section.3.1.1">3.1.1</a>&nbsp;Purpose
      </h3>
      <p id="rfc.section.3.1.1.p.1">The protocol referred to as "HTTP/1.0" includes the specification for a Basic Access Authentication scheme<a href="#RFC1945" id="rfc.xref.RFC1945.1"><cite title="Hypertext Transfer Protocol -- HTTP/1.0">[1]</cite></a>. That scheme is not considered to be a secure method of user authentication, as the user name and password are passed over
         the network in an unencrypted form. This section provides the specification for a scheme that does not send the password in
         cleartext, referred to as "Digest Access Authentication".
      </p>
      <p id="rfc.section.3.1.1.p.2">The Digest Access Authentication scheme is not intended to be a complete answer to the need for security in the World Wide
         Web. This scheme provides no encryption of message content. The intent is simply to create an access authentication method
         that avoids the most serious flaws of Basic authentication.
      </p>
      <h3 id="rfc.section.3.1.2"><a href="#rfc.section.3.1.2">3.1.2</a>&nbsp;Overall Operation
      </h3>
      <p id="rfc.section.3.1.2.p.1">Like Basic Access Authentication, the Digest scheme is based on a simple challenge-response paradigm. The Digest scheme challenges
         using a nonce value. A valid response contains a checksum (by default, the MD5 checksum) of the username, the password, the
         given nonce value, the HTTP method, and the requested URI. In this way, the password is never sent in the clear. Just as with
         the Basic scheme, the username and password must be prearranged in some fashion not addressed by this document.
      </p>
      <h3 id="rfc.section.3.1.3"><a href="#rfc.section.3.1.3">3.1.3</a>&nbsp;Representation of digest values
      </h3>
      <p id="rfc.section.3.1.3.p.1">An optional header allows the server to specify the algorithm used to create the checksum or digest. By default the MD5 algorithm
         is used and that is the only algorithm described in this document.
      </p>
      <p id="rfc.section.3.1.3.p.2">For the purposes of this document, an MD5 digest of 128 bits is represented as 32 ASCII printable characters. The bits in
         the 128 bit digest are converted from most significant to least significant bit, four bits at a time to their ASCII presentation
         as follows. Each four bits is represented by its familiar hexadecimal notation from the characters 0123456789abcdef. That
         is, binary 0000 gets represented by the character '0', 0001, by '1', and so on up to the representation of 1111 as 'f'.
      </p>
      <h3 id="rfc.section.3.1.4"><a href="#rfc.section.3.1.4">3.1.4</a>&nbsp;Limitations
      </h3>
      <p id="rfc.section.3.1.4.p.1">The Digest authentication scheme described in this document suffers from many known limitations. It is intended as a replacement
         for Basic authentication and nothing more. It is a password-based system and (on the server side) suffers from all the same
         problems of any password system. In particular, no provision is made in this protocol for the initial secure arrangement between
         user and server to establish the user's password.
      </p>
      <p id="rfc.section.3.1.4.p.2">Users and implementors should be aware that this protocol is not as secure as Kerberos, and not as secure as any client-side
         private-key scheme. Nevertheless it is better than nothing, better than what is commonly used with telnet and ftp, and better
         than Basic authentication.
      </p>
      <h2 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2</a>&nbsp;<a id="specification.of.digest.headers" href="#specification.of.digest.headers">Specification of Digest Headers</a></h2>
      <p id="rfc.section.3.2.p.1">The Digest Access Authentication scheme is conceptually similar to the Basic scheme. The formats of the modified WWW-Authenticate
         header line and the Authorization header line are specified below. In addition, a new header, Authentication-Info, is specified.
      </p>
      <div id="rfc.iref.h.1"></div>
      <div id="rfc.iref.w.1"></div>
      <h3 id="rfc.section.3.2.1"><a href="#rfc.section.3.2.1">3.2.1</a>&nbsp;<a id="the.www-authenticate.response.header" href="#the.www-authenticate.response.header">The WWW-Authenticate Response Header</a></h3>
      <p id="rfc.section.3.2.1.p.1">If a server receives a request for an access-protected object, and an acceptable Authorization header is not sent, the server
         responds with a "401 Unauthorized" status code, and a WWW-Authenticate header as per the framework defined above, which for
         the digest scheme is utilized as follows:
      </p>
      <div id="rfc.figure.u.9"></div><pre class="inline"><span id="rfc.iref.c.5"></span>      challenge        =  "Digest" digest-challenge

<span id="rfc.iref.d.1"></span>      digest-challenge  = 1#( realm | [ domain ] | nonce |
                          [ opaque ] |[ stale ] | [ algorithm ] |
                          [ qop-options ] | [auth-param] )


<span id="rfc.iref.d.2"></span>      domain            = "domain" "=" &lt;"&gt; URI ( 1*SP URI ) &lt;"&gt;
<span id="rfc.iref.u.3"></span>      URI               = absoluteURI | abs_path
<span id="rfc.iref.n.1"></span>      nonce             = "nonce" "=" nonce-value
<span id="rfc.iref.n.2"></span>      nonce-value       = quoted-string
<span id="rfc.iref.o.1"></span>      opaque            = "opaque" "=" quoted-string
<span id="rfc.iref.s.1"></span>      stale             = "stale" "=" ( "true" | "false" )
<span id="rfc.iref.a.3"></span>      algorithm         = "algorithm" "=" ( "MD5" | "MD5-sess" |
                           token )
<span id="rfc.iref.q.1"></span>      qop-options       = "qop" "=" &lt;"&gt; 1#qop-value &lt;"&gt;
<span id="rfc.iref.q.2"></span>      qop-value         = "auth" | "auth-int" | token
</pre><p id="rfc.section.3.2.1.p.3">The meanings of the values of the directives used above are as follows:</p>
      <p id="rfc.section.3.2.1.p.4">realm </p>
      <dl class="empty">
         <dd>A string to be displayed to users so they know which username and password to use. This string should contain at least the
            name of the host performing the authentication and might additionally indicate the collection of users who might have access.
            An example might be "registered_users@gotham.news.com".
         </dd>
      </dl>
      <p id="rfc.section.3.2.1.p.5">domain </p>
      <dl class="empty">
         <dd>A quoted, space-separated list of URIs, as specified in RFC XURI <a href="#RFC2396" id="rfc.xref.RFC2396.2"><cite title="Uniform Resource Identifiers (URI): Generic Syntax">[7]</cite></a>, that define the protection space. If a URI is an abs_path, it is relative to the canonical root URL (see <a href="#access.authentication.framework" title="Access Authentication Framework">Section&nbsp;1.2</a> above) of the server being accessed. An absoluteURI in this list may refer to a different server than the one being accessed.
            The client can use this list to determine the set of URIs for which the same authentication information may be sent: any URI
            that has a URI in this list as a prefix (after both have been made absolute) may be assumed to be in the same protection space.
            If this directive is omitted or its value is empty, the client should assume that the protection space consists of all URIs
            on the responding server. This directive is not meaningful in Proxy-Authenticate headers, for which the protection space is
            always the entire proxy; if present it should be ignored.
         </dd>
      </dl>
      <p id="rfc.section.3.2.1.p.6">nonce </p>
      <dl class="empty">
         <dd>A server-specified data string which should be uniquely generated each time a 401 response is made. It is recommended that
            this string be base64 or hexadecimal data. Specifically, since the string is passed in the header lines as a quoted string,
            the double-quote character is not allowed.
         </dd>
         <dd>The contents of the nonce are implementation dependent. The quality of the implementation depends on a good choice. A nonce
            might, for example, be constructed as the base 64 encoding of
         </dd>
         <dd>
            <div id="rfc.figure.u.10"></div><pre class="text">         time-stamp H(time-stamp ":" ETag ":" private-key)
  </pre></dd>
         <dd>where time-stamp is a server-generated time or other non-repeating value, ETag is the value of the HTTP ETag header associated
            with the requested entity, and private-key is data known only to the server. With a nonce of this form a server would recalculate
            the hash portion after receiving the client authentication header and reject the request if it did not match the nonce from
            that header or if the time-stamp value is not recent enough. In this way the server can limit the time of the nonce's validity.
            The inclusion of the ETag prevents a replay request for an updated version of the resource. (Note: including the IP address
            of the client in the nonce would appear to offer the server the ability to limit the reuse of the nonce to the same client
            that originally got it. However, that would break proxy farms, where requests from a single user often go through different
            proxies in the farm. Also, IP address spoofing is not that hard.)
         </dd>
         <dd>An implementation might choose not to accept a previously used nonce or a previously used digest, in order to protect against
            a replay attack. Or, an implementation might choose to use one-time nonces or digests for POST or PUT requests and a time-stamp
            for GET requests. For more details on the issues involved see <a href="#security.considerations" title="Security Considerations">Section&nbsp;4</a> of this document.
         </dd>
         <dd>The nonce is opaque to the client.</dd>
      </dl>
      <p id="rfc.section.3.2.1.p.7">opaque </p>
      <dl class="empty">
         <dd>A string of data, specified by the server, which should be returned by the client unchanged in the Authorization header of
            subsequent requests with URIs in the same protection space. It is recommended that this string be base64 or hexadecimal data.
         </dd>
      </dl>
      <p id="rfc.section.3.2.1.p.8">stale </p>
      <dl class="empty">
         <dd>A flag, indicating that the previous request from the client was rejected because the nonce value was stale. If stale is TRUE
            (case-insensitive), the client may wish to simply retry the request with a new encrypted response, without reprompting the
            user for a new username and password. The server should only set stale to TRUE if it receives a request for which the nonce
            is invalid but with a valid digest for that nonce (indicating that the client knows the correct username/password). If stale
            is FALSE, or anything other than TRUE, or the stale directive is not present, the username and/or password are invalid, and
            new values must be obtained.
         </dd>
      </dl>
      <p id="rfc.section.3.2.1.p.9">algorithm </p>
      <dl class="empty">
         <dd>A string indicating a pair of algorithms used to produce the digest and a checksum. If this is not present it is assumed to
            be "MD5". If the algorithm is not understood, the challenge should be ignored (and a different one used, if there is more
            than one).
         </dd>
         <dd>In this document the string obtained by applying the digest algorithm to the data "data" with secret "secret" will be denoted
            by KD(secret, data), and the string obtained by applying the checksum algorithm to the data "data" will be denoted H(data).
            The notation unq(X) means the value of the quoted-string X without the surrounding quotes.
         </dd>
         <dd>For the "MD5" and "MD5-sess" algorithms</dd>
         <dd>
            <div id="rfc.figure.u.11"></div><pre class="text">         H(data) = MD5(data)
    </pre></dd>
         <dd>and</dd>
         <dd>
            <div id="rfc.figure.u.12"></div><pre class="text">         KD(secret, data) = H(concat(secret, ":", data))
    </pre></dd>
         <dd>i.e., the digest is the MD5 of the secret concatenated with a colon concatenated with the data. The "MD5-sess" algorithm is
            intended to allow efficient 3rd party authentication servers; for the difference in usage, see the description in <a href="#A1" title="A1">Section&nbsp;3.2.2.2</a>.
         </dd>
      </dl>
      <p id="rfc.section.3.2.1.p.10">qop-options </p>
      <dl class="empty">
         <dd>This directive is optional, but is made so only for backward compatibility with RFC 2069 <a href="#RFC2069" id="rfc.xref.RFC2069.2"><cite title="An Extension to HTTP : Digest Access Authentication">[6]</cite></a>; it <em class="bcp14">SHOULD</em> be used by all implementations compliant with this version of the Digest scheme. If present, it is a quoted string of one
            or more tokens indicating the "quality of protection" values supported by the server. The value "auth" indicates authentication;
            the value "auth-int" indicates authentication with integrity protection; see the descriptions below for calculating the response
            directive value for the application of this choice. Unrecognized options <em class="bcp14">MUST</em> be ignored.
         </dd>
      </dl>
      <p id="rfc.section.3.2.1.p.11">auth-param </p>
      <dl class="empty">
         <dd>This directive allows for future extensions. Any unrecognized directive <em class="bcp14">MUST</em> be ignored.
         </dd>
      </dl>
      <div id="rfc.iref.h.2"></div>
      <div id="rfc.iref.a.4"></div>
      <h3 id="rfc.section.3.2.2"><a href="#rfc.section.3.2.2">3.2.2</a>&nbsp;<a id="the.authorization.request.header" href="#the.authorization.request.header">The Authorization Request Header</a></h3>
      <p id="rfc.section.3.2.2.p.1">The client is expected to retry the request, passing an Authorization header line, which is defined according to the framework
         above, utilized as follows.
      </p>
      <div id="rfc.figure.u.13"></div><pre class="inline"><span id="rfc.iref.c.6"></span>       credentials      = "Digest" digest-response
<span id="rfc.iref.d.3"></span>       digest-response  = 1#( username | realm | nonce | digest-uri
                       | response | [ algorithm ] | [cnonce] |
                       [opaque] | [message-qop] |
                           [nonce-count]  | [auth-param] )

<span id="rfc.iref.u.4"></span>       username         = "username" "=" username-value
<span id="rfc.iref.u.5"></span>       username-value   = quoted-string
<span id="rfc.iref.d.4"></span>       digest-uri       = "uri" "=" digest-uri-value
<span id="rfc.iref.d.5"></span>       digest-uri-value = request-uri   ; As specified by HTTP/1.1
<span id="rfc.iref.m.1"></span>       message-qop      = "qop" "=" qop-value
<span id="rfc.iref.c.7"></span>       cnonce           = "cnonce" "=" cnonce-value
<span id="rfc.iref.c.8"></span>       cnonce-value     = nonce-value
<span id="rfc.iref.n.3"></span>       nonce-count      = "nc" "=" nc-value
<span id="rfc.iref.n.4"></span>       nc-value         = 8LHEX
<span id="rfc.iref.r.3"></span>       response         = "response" "=" request-digest
<span id="rfc.iref.r.4"></span>       request-digest = &lt;"&gt; 32LHEX &lt;"&gt;
<span id="rfc.iref.l.1"></span>       LHEX             =  "0" | "1" | "2" | "3" |
                           "4" | "5" | "6" | "7" |
                           "8" | "9" | "a" | "b" |
                           "c" | "d" | "e" | "f"
</pre><p id="rfc.section.3.2.2.p.3">The values of the opaque and algorithm fields must be those supplied in the WWW-Authenticate response header for the entity
         being requested.
      </p>
      <p id="rfc.section.3.2.2.p.4">response </p>
      <dl class="empty">
         <dd>A string of 32 hex digits computed as defined below, which proves that the user knows a password</dd>
      </dl>
      <p id="rfc.section.3.2.2.p.5">username </p>
      <dl class="empty">
         <dd>The user's name in the specified realm.</dd>
      </dl>
      <p id="rfc.section.3.2.2.p.6">digest-uri </p>
      <dl class="empty">
         <dd>The URI from Request-URI of the Request-Line; duplicated here because proxies are allowed to change the Request-Line in transit.</dd>
      </dl>
      <p id="rfc.section.3.2.2.p.7">qop </p>
      <dl class="empty">
         <dd>Indicates what "quality of protection" the client has applied to the message. If present, its value <em class="bcp14">MUST</em> be one of the alternatives the server indicated it supports in the WWW-Authenticate header. These values affect the computation
            of the request-digest. Note that this is a single token, not a quoted list of alternatives as in WWW-Authenticate. This directive
            is optional in order to preserve backward compatibility with a minimal implementation of RFC 2069 <a href="#RFC2069" id="rfc.xref.RFC2069.3"><cite title="An Extension to HTTP : Digest Access Authentication">[6]</cite></a>, but <em class="bcp14">SHOULD</em> be used if the server indicated that qop is supported by providing a qop directive in the WWW-Authenticate header field.
         </dd>
      </dl>
      <p id="rfc.section.3.2.2.p.8">cnonce </p>
      <dl class="empty">
         <dd>This <em class="bcp14">MUST</em> be specified if a qop directive is sent (see above), and <em class="bcp14">MUST NOT</em> be specified if the server did not send a qop directive in the WWW-Authenticate header field. The cnonce-value is an opaque
            quoted string value provided by the client and used by both client and server to avoid chosen plaintext attacks, to provide
            mutual authentication, and to provide some message integrity protection. See the descriptions below of the calculation of
            the response-digest and request-digest values.
         </dd>
      </dl>
      <p id="rfc.section.3.2.2.p.9">nonce-count </p>
      <dl class="empty">
         <dd>This <em class="bcp14">MUST</em> be specified if a qop directive is sent (see above), and <em class="bcp14">MUST NOT</em> be specified if the server did not send a qop directive in the WWW-Authenticate header field. The nc-value is the hexadecimal
            count of the number of requests (including the current request) that the client has sent with the nonce value in this request.
            For example, in the first request sent in response to a given nonce value, the client sends "nc=00000001". The purpose of
            this directive is to allow the server to detect request replays by maintaining its own copy of this count - if the same nc-value
            is seen twice, then the request is a replay. See the description below of the construction of the request-digest value.
         </dd>
      </dl>
      <p id="rfc.section.3.2.2.p.10">auth-param </p>
      <dl class="empty">
         <dd>This directive allows for future extensions. Any unrecognized directive <em class="bcp14">MUST</em> be ignored.
         </dd>
      </dl>
      <p id="rfc.section.3.2.2.p.11">If a directive or its value is improper, or required directives are missing, the proper response is 400 Bad Request. If the
         request-digest is invalid, then a login failure should be logged, since repeated login failures from a single client may indicate
         an attacker attempting to guess passwords.
      </p>
      <p id="rfc.section.3.2.2.p.12">The definition of request-digest above indicates the encoding for its value. The following definitions show how the value
         is computed.
      </p>
      <h4 id="rfc.section.3.2.2.1"><a href="#rfc.section.3.2.2.1">3.2.2.1</a>&nbsp;<a id="request-digest" href="#request-digest">Request-Digest</a></h4>
      <p id="rfc.section.3.2.2.1.p.1">If the "qop" value is "auth" or "auth-int":</p>
      <div id="rfc.figure.u.14"></div><pre class="inline">      request-digest  = &lt;"&gt; &lt; KD ( H(A1),     unq(nonce-value)
                                          ":" nc-value
                                          ":" unq(cnonce-value)
                                          ":" unq(qop-value)
                                          ":" H(A2)
                                  ) &lt;"&gt;
</pre><p id="rfc.section.3.2.2.1.p.3">If the "qop" directive is not present (this construction is for compatibility with RFC 2069):</p>
      <div id="rfc.figure.u.15"></div><pre class="inline">      request-digest  =
                 &lt;"&gt; &lt; KD ( H(A1), unq(nonce-value) ":" H(A2) ) &gt;
   &lt;"&gt;
</pre><p id="rfc.section.3.2.2.1.p.5">See below for the definitions for A1 and A2.</p>
      <h4 id="rfc.section.3.2.2.2"><a href="#rfc.section.3.2.2.2">3.2.2.2</a>&nbsp;<a id="A1" href="#A1">A1</a></h4>
      <p id="rfc.section.3.2.2.2.p.1">If the "algorithm" directive's value is "MD5" or is unspecified, then A1 is:</p>
      <div id="rfc.figure.u.16"></div><pre class="inline">      A1       = unq(username-value) ":" unq(realm-value) ":" passwd
</pre><p id="rfc.section.3.2.2.2.p.3">where</p>
      <div id="rfc.figure.u.17"></div><pre class="inline">      passwd   = &lt; user's password &gt;
</pre><p id="rfc.section.3.2.2.2.p.5">If the "algorithm" directive's value is "MD5-sess", then A1 is calculated only once - on the first request by the client following
         receipt of a WWW-Authenticate challenge from the server. It uses the server nonce from that challenge, and the first client
         nonce value to construct A1 as follows:
      </p>
      <div id="rfc.figure.u.18"></div><pre class="inline">      A1       = H( unq(username-value) ":" unq(realm-value)
                     ":" passwd )
                     ":" unq(nonce-value) ":" unq(cnonce-value)
</pre><p id="rfc.section.3.2.2.2.p.7">This creates a 'session key' for the authentication of subsequent requests and responses which is different for each "authentication
         session", thus limiting the amount of material hashed with any one key. (Note: see further discussion of the authentication
         session in <a href="#digest.operation" title="Digest Operation">Section&nbsp;3.3</a>) Because the server need only use the hash of the user credentials in order to create the A1 value, this construction could
         be used in conjunction with a third party authentication service so that the web server would not need the actual password
         value. The specification of such a protocol is beyond the scope of this specification.
      </p>
      <h4 id="rfc.section.3.2.2.3"><a href="#rfc.section.3.2.2.3">3.2.2.3</a>&nbsp;A2
      </h4>
      <p id="rfc.section.3.2.2.3.p.1">If the "qop" directive's value is "auth" or is unspecified, then A2 is:</p>
      <div id="rfc.figure.u.19"></div><pre class="inline">      A2       = Method ":" digest-uri-value
</pre><p id="rfc.section.3.2.2.3.p.3">If the "qop" value is "auth-int", then A2 is:</p>
      <div id="rfc.figure.u.20"></div><pre class="inline">      A2       = Method ":" digest-uri-value ":" H(entity-body)
</pre><h4 id="rfc.section.3.2.2.4"><a href="#rfc.section.3.2.2.4">3.2.2.4</a>&nbsp;Directive values and quoted-string
      </h4>
      <p id="rfc.section.3.2.2.4.p.1">Note that the value of many of the directives, such as "username-value", are defined as a "quoted-string". However, the "unq"
         notation indicates that surrounding quotation marks are removed in forming the string A1. Thus if the Authorization header
         includes the fields
      </p>
      <div id="rfc.figure.u.21"></div><pre class="text">     username="Mufasa", realm=myhost@testrealm.com
</pre><p id="rfc.section.3.2.2.4.p.3">and the user Mufasa has password "Circle Of Life" then H(A1) would be H(Mufasa:myhost@testrealm.com:Circle Of Life) with no
         quotation marks in the digested string.
      </p>
      <p id="rfc.section.3.2.2.4.p.4">No white space is allowed in any of the strings to which the digest function H() is applied unless that white space exists
         in the quoted strings or entity body whose contents make up the string to be digested. For example, the string A1 illustrated
         above must be
      </p>
      <div id="rfc.figure.u.22"></div><pre class="text">        Mufasa:myhost@testrealm.com:Circle Of Life
</pre><p id="rfc.section.3.2.2.4.p.6">with no white space on either side of the colons, but with the white space between the words used in the password value. Likewise,
         the other strings digested by H() must not have white space on either side of the colons which delimit their fields unless
         that white space was in the quoted strings or entity body being digested.
      </p>
      <p id="rfc.section.3.2.2.4.p.7">Also note that if integrity protection is applied (qop=auth-int), the H(entity-body) is the hash of the entity body, not the
         message body - it is computed before any transfer encoding is applied by the sender and after it has been removed by the recipient.
         Note that this includes multipart boundaries and embedded headers in each part of any multipart content-type.
      </p>
      <h4 id="rfc.section.3.2.2.5"><a href="#rfc.section.3.2.2.5">3.2.2.5</a>&nbsp;Various considerations
      </h4>
      <p id="rfc.section.3.2.2.5.p.1">The "Method" value is the HTTP request method as specified in section <a href="http://tools.ietf.org/html/rfc2616#section-5.1.1" title="Method" id="rfc.xref.RFC2616.9">5.1.1</a> of <a href="#RFC2616" id="rfc.xref.RFC2616.10"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite></a>. The "request-uri" value is the Request-URI from the request line as specified in section <a href="http://tools.ietf.org/html/rfc2616#section-5.1.2" title="Request-URI" id="rfc.xref.RFC2616.11">5.1.2</a> of <a href="#RFC2616" id="rfc.xref.RFC2616.12"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite></a>. This may be "*", an "absoluteURL" or an "abs_path" as specified in section <a href="http://tools.ietf.org/html/rfc2616#section-5.1.2" title="Request-URI" id="rfc.xref.RFC2616.13">5.1.2</a> of <a href="#RFC2616" id="rfc.xref.RFC2616.14"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite></a>, but it <em class="bcp14">MUST</em> agree with the Request-URI. In particular, it <em class="bcp14">MUST</em> be an "absoluteURL" if the Request-URI is an "absoluteURL". The "cnonce-value" is an optional client-chosen value whose purpose
         is to foil chosen plaintext attacks.
      </p>
      <p id="rfc.section.3.2.2.5.p.2">The authenticating server must assure that the resource designated by the "uri" directive is the same as the resource specified
         in the Request-Line; if they are not, the server <em class="bcp14">SHOULD</em> return a 400 Bad Request error. (Since this may be a symptom of an attack, server implementers may want to consider logging
         such errors.) The purpose of duplicating information from the request URL in this field is to deal with the possibility that
         an intermediate proxy may alter the client's Request-Line. This altered (but presumably semantically equivalent) request would
         not result in the same digest as that calculated by the client.
      </p>
      <p id="rfc.section.3.2.2.5.p.3">Implementers should be aware of how authenticated transactions interact with shared caches. The HTTP/1.1 protocol specifies
         that when a shared cache (see section <a href="http://tools.ietf.org/html/rfc2616#section-13.7" title="Shared and Non-Shared Caches" id="rfc.xref.RFC2616.15">13.7</a> of <a href="#RFC2616" id="rfc.xref.RFC2616.16"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite></a>) has received a request containing an Authorization header and a response from relaying that request, it <em class="bcp14">MUST NOT</em> return that response as a reply to any other request, unless one of two Cache-Control (see section <a href="http://tools.ietf.org/html/rfc2616#section-14.9" title="Cache-Control" id="rfc.xref.RFC2616.17">14.9</a> of <a href="#RFC2616" id="rfc.xref.RFC2616.18"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite></a>) directives was present in the response. If the original response included the "must-revalidate" Cache-Control directive,
         the cache <em class="bcp14">MAY</em> use the entity of that response in replying to a subsequent request, but <em class="bcp14">MUST</em> first revalidate it with the origin server, using the request headers from the new request to allow the origin server to authenticate
         the new request. Alternatively, if the original response included the "public" Cache-Control directive, the response entity <em class="bcp14">MAY</em> be returned in reply to any subsequent request.
      </p>
      <div id="rfc.iref.h.3"></div>
      <div id="rfc.iref.a.5"></div>
      <h3 id="rfc.section.3.2.3"><a href="#rfc.section.3.2.3">3.2.3</a>&nbsp;The Authentication-Info Header
      </h3>
      <p id="rfc.section.3.2.3.p.1">The Authentication-Info header is used by the server to communicate some information regarding the successful authentication
         in the response.
      </p>
      <div id="rfc.figure.u.23"></div><pre class="inline"><span id="rfc.iref.a.6"></span>        AuthenticationInfo = "Authentication-Info" ":" auth-info
<span id="rfc.iref.a.7"></span>        auth-info          = 1#(nextnonce | [ message-qop ]
                               | [ response-auth ] | [ cnonce ]
                               | [nonce-count] )
<span id="rfc.iref.n.5"></span>        nextnonce          = "nextnonce" "=" nonce-value
<span id="rfc.iref.r.5"></span>        response-auth      = "rspauth" "=" response-digest
<span id="rfc.iref.r.6"></span>        response-digest    = &lt;"&gt; *LHEX &lt;"&gt;
</pre><p id="rfc.section.3.2.3.p.3">The value of the nextnonce directive is the nonce the server wishes the client to use for a future authentication response.
         The server may send the Authentication-Info header with a nextnonce field as a means of implementing one-time or otherwise
         changing nonces. If the nextnonce field is present the client <em class="bcp14">SHOULD</em> use it when constructing the Authorization header for its next request. Failure of the client to do so may result in a request
         to re-authenticate from the server with the "stale=TRUE".
      </p>
      <p id="rfc.section.3.2.3.p.4"> </p>
      <dl class="empty">
         <dd>Server implementations should carefully consider the performance implications of the use of this mechanism; pipelined requests
            will not be possible if every response includes a nextnonce directive that must be used on the next request received by the
            server. Consideration should be given to the performance vs. security tradeoffs of allowing an old nonce value to be used
            for a limited time to permit request pipelining. Use of the nonce-count can retain most of the security advantages of a new
            server nonce without the deleterious affects on pipelining.
         </dd>
      </dl>
      <p id="rfc.section.3.2.3.p.5">message-qop</p>
      <dl class="empty">
         <dd>Indicates the "quality of protection" options applied to the response by the server. The value "auth" indicates authentication;
            the value "auth-int" indicates authentication with integrity protection. The server <em class="bcp14">SHOULD</em> use the same value for the message-qop directive in the response as was sent by the client in the corresponding request.
         </dd>
      </dl>
      <p id="rfc.section.3.2.3.p.7">The optional response digest in the "response-auth" directive supports mutual authentication -- the server proves that it
         knows the user's secret, and with qop=auth-int also provides limited integrity protection of the response. The "response-digest"
         value is calculated as for the "request-digest" in the Authorization header, except that if "qop=auth" or is not specified
         in the Authorization header for the request, A2 is
      </p>
      <div id="rfc.figure.u.24"></div><pre class="inline">      A2       = ":" digest-uri-value
</pre><p id="rfc.section.3.2.3.p.9">and if "qop=auth-int", then A2 is</p>
      <div id="rfc.figure.u.25"></div><pre class="inline">      A2       = ":" digest-uri-value ":" H(entity-body)
</pre><p id="rfc.section.3.2.3.p.11">where "digest-uri-value" is the value of the "uri" directive on the Authorization header in the request. The "cnonce-value"
         and "nc-value" <em class="bcp14">MUST</em> be the ones for the client request to which this message is the response. The "response-auth", "cnonce", and "nonce-count"
         directives <em class="bcp14">MUST</em> BE present if "qop=auth" or "qop=auth-int" is specified.
      </p>
      <p id="rfc.section.3.2.3.p.12">The Authentication-Info header is allowed in the trailer of an HTTP message transferred via chunked transfer-coding.</p>
      <h2 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3</a>&nbsp;<a id="digest.operation" href="#digest.operation">Digest Operation</a></h2>
      <p id="rfc.section.3.3.p.1">Upon receiving the Authorization header, the server may check its validity by looking up the password that corresponds to
         the submitted username. Then, the server must perform the same digest operation (e.g., MD5) performed by the client, and compare
         the result to the given request-digest value.
      </p>
      <p id="rfc.section.3.3.p.2">Note that the HTTP server does not actually need to know the user's cleartext password. As long as H(A1) is available to the
         server, the validity of an Authorization header may be verified.
      </p>
      <p id="rfc.section.3.3.p.3">The client response to a WWW-Authenticate challenge for a protection space starts an authentication session with that protection
         space. The authentication session lasts until the client receives another WWW-Authenticate challenge from any server in the
         protection space. A client should remember the username, password, nonce, nonce count and opaque values associated with an
         authentication session to use to construct the Authorization header in future requests within that protection space. The Authorization
         header may be included preemptively; doing so improves server efficiency and avoids extra round trips for authentication challenges.
         The server may choose to accept the old Authorization header information, even though the nonce value included might not be
         fresh. Alternatively, the server may return a 401 response with a new nonce value, causing the client to retry the request;
         by specifying stale=TRUE with this response, the server tells the client to retry with the new nonce, but without prompting
         for a new username and password.
      </p>
      <p id="rfc.section.3.3.p.4">Because the client is required to return the value of the opaque directive given to it by the server for the duration of a
         session, the opaque data may be used to transport authentication session state information. (Note that any such use can also
         be accomplished more easily and safely by including the state in the nonce.) For example, a server could be responsible for
         authenticating content that actually sits on another server. It would achieve this by having the first 401 response include
         a domain directive whose value includes a URI on the second server, and an opaque directive whose value contains the state
         information. The client will retry the request, at which time the server might respond with a 301/302 redirection, pointing
         to the URI on the second server. The client will follow the redirection, and pass an Authorization header , including the
         &lt;opaque&gt; data.
      </p>
      <p id="rfc.section.3.3.p.5">As with the basic scheme, proxies must be completely transparent in the Digest access authentication scheme. That is, they
         must forward the WWW-Authenticate, Authentication-Info and Authorization headers untouched. If a proxy wants to authenticate
         a client before a request is forwarded to the server, it can be done using the Proxy-Authenticate and Proxy-Authorization
         headers described in <a href="#proxy-authentication.and.proxy-authorization" title="Proxy-Authentication and Proxy-Authorization">Section&nbsp;3.6</a> below.
      </p>
      <h2 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4</a>&nbsp;Security Protocol Negotiation
      </h2>
      <p id="rfc.section.3.4.p.1">It is useful for a server to be able to know which security schemes a client is capable of handling.</p>
      <p id="rfc.section.3.4.p.2">It is possible that a server may want to require Digest as its authentication method, even if the server does not know that
         the client supports it. A client is encouraged to fail gracefully if the server specifies only authentication schemes it cannot
         handle.
      </p>
      <h2 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5</a>&nbsp;<a id="specification.of.digest.headers.example" href="#specification.of.digest.headers.example">Example</a></h2>
      <p id="rfc.section.3.5.p.1">The following example assumes that an access-protected document is being requested from the server via a GET request. The
         URI of the document is "http://www.nowhere.org/dir/index.html". Both client and server know that the username for this document
         is "Mufasa", and the password is "Circle Of Life" (with one space between each of the three words).
      </p>
      <p id="rfc.section.3.5.p.2">The first time the client requests the document, no Authorization header is sent, so the server responds with:</p>
      <div id="rfc.figure.u.26"></div><pre class="text">         HTTP/1.1 401 Unauthorized
         WWW-Authenticate: Digest
                 realm="testrealm@host.com",
                 qop="auth,auth-int",
                 nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
                 opaque="5ccc069c403ebaf9f0171e9517f40e41"
</pre><p id="rfc.section.3.5.p.4">The client may prompt the user for the username and password, after which it will respond with a new request, including the
         following Authorization header:
      </p>
      <div id="rfc.figure.u.27"></div><pre class="text">         Authorization: Digest username="Mufasa",
                 realm="testrealm@host.com",
                 nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
                 uri="/dir/index.html",
                 qop=auth,
                 nc=00000001,
                 cnonce="0a4f113b",
                 response="6629fae49393a05397450978507c4ef1",
                 opaque="5ccc069c403ebaf9f0171e9517f40e41"
</pre><h2 id="rfc.section.3.6"><a href="#rfc.section.3.6">3.6</a>&nbsp;<a id="proxy-authentication.and.proxy-authorization" href="#proxy-authentication.and.proxy-authorization">Proxy-Authentication and Proxy-Authorization</a></h2>
      <p id="rfc.section.3.6.p.1">The digest authentication scheme may also be used for authenticating users to proxies, proxies to proxies, or proxies to origin
         servers by use of the Proxy-Authenticate and Proxy-Authorization headers. These headers are instances of the Proxy-Authenticate
         and Proxy-Authorization headers specified in sections <a href="http://tools.ietf.org/html/rfc2616#section-10.33" id="rfc.xref.RFC2616.19">10.33</a> and <a href="http://tools.ietf.org/html/rfc2616#section-10.34" id="rfc.xref.RFC2616.20">10.34</a> of the HTTP/1.1 specification <a href="#RFC2616" id="rfc.xref.RFC2616.21"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite></a> and their behavior is subject to restrictions described there. The transactions for proxy authentication are very similar
         to those already described. Upon receiving a request which requires authentication, the proxy/server must issue the "407 Proxy
         Authentication Required" response with a "Proxy-Authenticate" header. The digest-challenge used in the Proxy-Authenticate
         header is the same as that for the WWW-Authenticate header as defined above in <a href="#the.www-authenticate.response.header" title="The WWW-Authenticate Response Header">Section&nbsp;3.2.1</a>.
      </p>
      <p id="rfc.section.3.6.p.2">The client/proxy must then re-issue the request with a Proxy-Authorization header, with directives as specified for the Authorization
         header in <a href="#the.authorization.request.header" title="The Authorization Request Header">Section&nbsp;3.2.2</a> above.
      </p>
      <p id="rfc.section.3.6.p.3">On subsequent responses, the server sends Proxy-Authentication-Info with directives the same as those for the Authentication-Info
         header field.
      </p>
      <p id="rfc.section.3.6.p.4">Note that in principle a client could be asked to authenticate itself to both a proxy and an end-server, but never in the
         same response.
      </p>
      <h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a id="security.considerations" href="#security.considerations">Security Considerations</a></h1>
      <h2 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1</a>&nbsp;Authentication of Clients using Basic Authentication
      </h2>
      <p id="rfc.section.4.1.p.1">The Basic authentication scheme is not a secure method of user authentication, nor does it in any way protect the entity,
         which is transmitted in cleartext across the physical network used as the carrier. HTTP does not prevent additional authentication
         schemes and encryption mechanisms from being employed to increase security or the addition of enhancements (such as schemes
         to use one-time passwords) to Basic authentication.
      </p>
      <p id="rfc.section.4.1.p.2">The most serious flaw in Basic authentication is that it results in the essentially cleartext transmission of the user's password
         over the physical network. It is this problem which Digest Authentication attempts to address.
      </p>
      <p id="rfc.section.4.1.p.3">Because Basic authentication involves the cleartext transmission of passwords it <em class="bcp14">SHOULD NOT</em> be used (without enhancements) to protect sensitive or valuable information.
      </p>
      <p id="rfc.section.4.1.p.4">A common use of Basic authentication is for identification purposes -- requiring the user to provide a user name and password
         as a means of identification, for example, for purposes of gathering accurate usage statistics on a server. When used in this
         way it is tempting to think that there is no danger in its use if illicit access to the protected documents is not a major
         concern. This is only correct if the server issues both user name and password to the users and in particular does not allow
         the user to choose his or her own password. The danger arises because naive users frequently reuse a single password to avoid
         the task of maintaining multiple passwords.
      </p>
      <p id="rfc.section.4.1.p.5">If a server permits users to select their own passwords, then the threat is not only unauthorized access to documents on the
         server but also unauthorized access to any other resources on other systems that the user protects with the same password.
         Furthermore, in the server's password database, many of the passwords may also be users' passwords for other sites. The owner
         or administrator of such a system could therefore expose all users of the system to the risk of unauthorized access to all
         those sites if this information is not maintained in a secure fashion.
      </p>
      <p id="rfc.section.4.1.p.6">Basic Authentication is also vulnerable to spoofing by counterfeit servers. If a user can be led to believe that he is connecting
         to a host containing information protected by Basic authentication when, in fact, he is connecting to a hostile server or
         gateway, then the attacker can request a password, store it for later use, and feign an error. This type of attack is not
         possible with Digest Authentication. Server implementers <em class="bcp14">SHOULD</em> guard against the possibility of this sort of counterfeiting by gateways or CGI scripts. In particular it is very dangerous
         for a server to simply turn over a connection to a gateway. That gateway can then use the persistent connection mechanism
         to engage in multiple transactions with the client while impersonating the original server in a way that is not detectable
         by the client.
      </p>
      <h2 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2</a>&nbsp;Authentication of Clients using Digest Authentication
      </h2>
      <p id="rfc.section.4.2.p.1">Digest Authentication does not provide a strong authentication mechanism, when compared to public key based mechanisms, for
         example. However, it is significantly stronger than (e.g.) CRAM-MD5, which has been proposed for use with LDAP <a href="#ref10" id="rfc.xref.ref10.1"><cite title="Authentication Methods for LDAP">[10]</cite></a>, POP and IMAP (see RFC 2195 <a href="#RFC2195" id="rfc.xref.RFC2195.1"><cite title="IMAP/POP AUTHorize Extension for Simple Challenge/Response">[9]</cite></a>). It is intended to replace the much weaker and even more dangerous Basic mechanism.
      </p>
      <p id="rfc.section.4.2.p.2">Digest Authentication offers no confidentiality protection beyond protecting the actual password. All of the rest of the request
         and response are available to an eavesdropper.
      </p>
      <p id="rfc.section.4.2.p.3">Digest Authentication offers only limited integrity protection for the messages in either direction. If qop=auth-int mechanism
         is used, those parts of the message used in the calculation of the WWW-Authenticate and Authorization header field response
         directive values (see <a href="#specification.of.digest.headers" title="Specification of Digest Headers">Section&nbsp;3.2</a> above) are protected. Most header fields and their values could be modified as a part of a man-in-the-middle attack.
      </p>
      <p id="rfc.section.4.2.p.4">Many needs for secure HTTP transactions cannot be met by Digest Authentication. For those needs TLS or SHTTP are more appropriate
         protocols. In particular Digest authentication cannot be used for any transaction requiring confidentiality protection. Nevertheless
         many functions remain for which Digest authentication is both useful and appropriate. Any service in present use that uses
         Basic should be switched to Digest as soon as practical.
      </p>
      <h2 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3</a>&nbsp;Limited Use Nonce Values
      </h2>
      <p id="rfc.section.4.3.p.1">The Digest scheme uses a server-specified nonce to seed the generation of the request-digest value (as specified in <a href="#request-digest" title="Request-Digest">Section&nbsp;3.2.2.1</a> above). As shown in the example nonce in <a href="#the.www-authenticate.response.header" title="The WWW-Authenticate Response Header">Section&nbsp;3.2.1</a>, the server is free to construct the nonce such that it may only be used from a particular client, for a particular resource,
         for a limited period of time or number of uses, or any other restrictions. Doing so strengthens the protection provided against,
         for example, replay attacks (see <a href="#replay.attacks" title="Replay Attacks">4.5</a>). However, it should be noted that the method chosen for generating and checking the nonce also has performance and resource
         implications. For example, a server may choose to allow each nonce value to be used only once by maintaining a record of whether
         or not each recently issued nonce has been returned and sending a next-nonce directive in the Authentication-Info header field
         of every response. This protects against even an immediate replay attack, but has a high cost checking nonce values, and perhaps
         more important will cause authentication failures for any pipelined requests (presumably returning a stale nonce indication).
         Similarly, incorporating a request-specific element such as the Etag value for a resource limits the use of the nonce to that
         version of the resource and also defeats pipelining. Thus it may be useful to do so for methods with side effects but have
         unacceptable performance for those that do not.
      </p>
      <h2 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4</a>&nbsp;Comparison of Digest with Basic Authentication
      </h2>
      <p id="rfc.section.4.4.p.1">Both Digest and Basic Authentication are very much on the weak end of the security strength spectrum. But a comparison between
         the two points out the utility, even necessity, of replacing Basic by Digest.
      </p>
      <p id="rfc.section.4.4.p.2">The greatest threat to the type of transactions for which these protocols are used is network snooping. This kind of transaction
         might involve, for example, online access to a database whose use is restricted to paying subscribers. With Basic authentication
         an eavesdropper can obtain the password of the user. This not only permits him to access anything in the database, but, often
         worse, will permit access to anything else the user protects with the same password.
      </p>
      <p id="rfc.section.4.4.p.3">By contrast, with Digest Authentication the eavesdropper only gets access to the transaction in question and not to the user's
         password. The information gained by the eavesdropper would permit a replay attack, but only with a request for the same document,
         and even that may be limited by the server's choice of nonce.
      </p>
      <h2 id="rfc.section.4.5"><a href="#rfc.section.4.5">4.5</a>&nbsp;<a id="replay.attacks" href="#replay.attacks">Replay Attacks</a></h2>
      <p id="rfc.section.4.5.p.1">A replay attack against Digest authentication would usually be pointless for a simple GET request since an eavesdropper would
         already have seen the only document he could obtain with a replay. This is because the URI of the requested document is digested
         in the client request and the server will only deliver that document. By contrast under Basic Authentication once the eavesdropper
         has the user's password, any document protected by that password is open to him.
      </p>
      <p id="rfc.section.4.5.p.2">Thus, for some purposes, it is necessary to protect against replay attacks. A good Digest implementation can do this in various
         ways. The server created "nonce" value is implementation dependent, but if it contains a digest of the client IP, a time-stamp,
         the resource ETag, and a private server key (as recommended above) then a replay attack is not simple. An attacker must convince
         the server that the request is coming from a false IP address and must cause the server to deliver the document to an IP address
         different from the address to which it believes it is sending the document. An attack can only succeed in the period before
         the time-stamp expires. Digesting the client IP and time-stamp in the nonce permits an implementation which does not maintain
         state between transactions.
      </p>
      <p id="rfc.section.4.5.p.3">For applications where no possibility of replay attack can be tolerated the server can use one-time nonce values which will
         not be honored for a second use. This requires the overhead of the server remembering which nonce values have been used until
         the nonce time-stamp (and hence the digest built with it) has expired, but it effectively protects against replay attacks.
      </p>
      <p id="rfc.section.4.5.p.4">An implementation must give special attention to the possibility of replay attacks with POST and PUT requests. Unless the
         server employs one-time or otherwise limited-use nonces and/or insists on the use of the integrity protection of qop=auth-int,
         an attacker could replay valid credentials from a successful request with counterfeit form data or other message body. Even
         with the use of integrity protection most metadata in header fields is not protected. Proper nonce generation and checking
         provides some protection against replay of previously used valid credentials, but see 4.8.
      </p>
      <h2 id="rfc.section.4.6"><a href="#rfc.section.4.6">4.6</a>&nbsp;Weakness Created by Multiple Authentication Schemes
      </h2>
      <p id="rfc.section.4.6.p.1">An HTTP/1.1 server may return multiple challenges with a 401 (Authenticate) response, and each challenge may use a different
         auth-scheme. A user agent <em class="bcp14">MUST</em> choose to use the strongest auth-scheme it understands and request credentials from the user based upon that challenge.
      </p>
      <p id="rfc.section.4.6.p.2"> </p>
      <dl class="empty">
         <dd>Note that many browsers will only recognize Basic and will require that it be the first auth-scheme presented. Servers should
            only include Basic if it is minimally acceptable.
         </dd>
      </dl>
      <p id="rfc.section.4.6.p.3">When the server offers choices of authentication schemes using the WWW-Authenticate header, the strength of the resulting
         authentication is only as good as that of the of the weakest of the authentication schemes. See <a href="#man.in.the.middle" title="Man in the Middle">Section&nbsp;4.8</a> below for discussion of particular attack scenarios that exploit multiple authentication schemes.
      </p>
      <h2 id="rfc.section.4.7"><a href="#rfc.section.4.7">4.7</a>&nbsp;Online dictionary attacks
      </h2>
      <p id="rfc.section.4.7.p.1">If the attacker can eavesdrop, then it can test any overheard nonce/response pairs against a list of common words. Such a
         list is usually much smaller than the total number of possible passwords. The cost of computing the response for each password
         on the list is paid once for each challenge.
      </p>
      <p id="rfc.section.4.7.p.2">The server can mitigate this attack by not allowing users to select passwords that are in a dictionary.</p>
      <h2 id="rfc.section.4.8"><a href="#rfc.section.4.8">4.8</a>&nbsp;<a id="man.in.the.middle" href="#man.in.the.middle">Man in the Middle</a></h2>
      <p id="rfc.section.4.8.p.1">Both Basic and Digest authentication are vulnerable to "man in the middle" (MITM) attacks, for example, from a hostile or
         compromised proxy. Clearly, this would present all the problems of eavesdropping. But it also offers some additional opportunities
         to the attacker.
      </p>
      <p id="rfc.section.4.8.p.2">A possible man-in-the-middle attack would be to add a weak authentication scheme to the set of choices, hoping that the client
         will use one that exposes the user's credentials (e.g. password). For this reason, the client should always use the strongest
         scheme that it understands from the choices offered.
      </p>
      <p id="rfc.section.4.8.p.3">An even better MITM attack would be to remove all offered choices, replacing them with a challenge that requests only Basic
         authentication, then uses the cleartext credentials from the Basic authentication to authenticate to the origin server using
         the stronger scheme it requested. A particularly insidious way to mount such a MITM attack would be to offer a "free" proxy
         caching service to gullible users.
      </p>
      <p id="rfc.section.4.8.p.4">User agents should consider measures such as presenting a visual indication at the time of the credentials request of what
         authentication scheme is to be used, or remembering the strongest authentication scheme ever requested by a server and produce
         a warning message before using a weaker one. It might also be a good idea for the user agent to be configured to demand Digest
         authentication in general, or from specific sites.
      </p>
      <p id="rfc.section.4.8.p.5">Or, a hostile proxy might spoof the client into making a request the attacker wanted rather than one the client wanted. Of
         course, this is still much harder than a comparable attack against Basic Authentication.
      </p>
      <h2 id="rfc.section.4.9"><a href="#rfc.section.4.9">4.9</a>&nbsp;Chosen plaintext attacks
      </h2>
      <p id="rfc.section.4.9.p.1">With Digest authentication, a MITM or a malicious server can arbitrarily choose the nonce that the client will use to compute
         the response. This is called a "chosen plaintext" attack. The ability to choose the nonce is known to make cryptanalysis much
         easier <a href="#ref8" id="rfc.xref.ref8.1"><cite title="Message Authentication with MD5">[8]</cite></a>.
      </p>
      <p id="rfc.section.4.9.p.2">However, no way to analyze the MD5 one-way function used by Digest using chosen plaintext is currently known.</p>
      <p id="rfc.section.4.9.p.3">The countermeasure against this attack is for clients to be configured to require the use of the optional "cnonce" directive;
         this allows the client to vary the input to the hash in a way not chosen by the attacker.
      </p>
      <h2 id="rfc.section.4.10"><a href="#rfc.section.4.10">4.10</a>&nbsp;Precomputed dictionary attacks
      </h2>
      <p id="rfc.section.4.10.p.1">With Digest authentication, if the attacker can execute a chosen plaintext attack, the attacker can precompute the response
         for many common words to a nonce of its choice, and store a dictionary of (response, password) pairs. Such precomputation
         can often be done in parallel on many machines. It can then use the chosen plaintext attack to acquire a response corresponding
         to that challenge, and just look up the password in the dictionary. Even if most passwords are not in the dictionary, some
         might be. Since the attacker gets to pick the challenge, the cost of computing the response for each password on the list
         can be amortized over finding many passwords. A dictionary with 100 million password/response pairs would take about 3.2 gigabytes
         of disk storage.
      </p>
      <p id="rfc.section.4.10.p.2">The countermeasure against this attack is to for clients to be configured to require the use of the optional "cnonce" directive.</p>
      <h2 id="rfc.section.4.11"><a href="#rfc.section.4.11">4.11</a>&nbsp;Batch brute force attacks
      </h2>
      <p id="rfc.section.4.11.p.1">With Digest authentication, a MITM can execute a chosen plaintext attack, and can gather responses from many users to the
         same nonce. It can then find all the passwords within any subset of password space that would generate one of the nonce/response
         pairs in a single pass over that space. It also reduces the time to find the first password by a factor equal to the number
         of nonce/response pairs gathered. This search of the password space can often be done in parallel on many machines, and even
         a single machine can search large subsets of the password space very quickly -- reports exist of searching all passwords with
         six or fewer letters in a few hours.
      </p>
      <p id="rfc.section.4.11.p.2">The countermeasure against this attack is to for clients to be configured to require the use of the optional "cnonce" directive.</p>
      <h2 id="rfc.section.4.12"><a href="#rfc.section.4.12">4.12</a>&nbsp;Spoofing by Counterfeit Servers
      </h2>
      <p id="rfc.section.4.12.p.1">Basic Authentication is vulnerable to spoofing by counterfeit servers. If a user can be led to believe that she is connecting
         to a host containing information protected by a password she knows, when in fact she is connecting to a hostile server, then
         the hostile server can request a password, store it away for later use, and feign an error. This type of attack is more difficult
         with Digest Authentication -- but the client must know to demand that Digest authentication be used, perhaps using some of
         the techniques described above to counter "man-in-the-middle" attacks. Again, the user can be helped in detecting this attack
         by a visual indication of the authentication mechanism in use with appropriate guidance in interpreting the implications of
         each scheme.
      </p>
      <h2 id="rfc.section.4.13"><a href="#rfc.section.4.13">4.13</a>&nbsp;Storing passwords
      </h2>
      <p id="rfc.section.4.13.p.1">Digest authentication requires that the authenticating agent (usually the server) store some data derived from the user's
         name and password in a "password file" associated with a given realm. Normally this might contain pairs consisting of username
         and H(A1), where H(A1) is the digested value of the username, realm, and password as described above.
      </p>
      <p id="rfc.section.4.13.p.2">The security implications of this are that if this password file is compromised, then an attacker gains immediate access to
         documents on the server using this realm. Unlike, say a standard UNIX password file, this information need not be decrypted
         in order to access documents in the server realm associated with this file. On the other hand, decryption, or more likely
         a brute force attack, would be necessary to obtain the user's password. This is the reason that the realm is part of the digested
         data stored in the password file. It means that if one Digest authentication password file is compromised, it does not automatically
         compromise others with the same username and password (though it does expose them to brute force attack).
      </p>
      <p id="rfc.section.4.13.p.3">There are two important security consequences of this. First the password file must be protected as if it contained unencrypted
         passwords, because for the purpose of accessing documents in its realm, it effectively does.
      </p>
      <p id="rfc.section.4.13.p.4">A second consequence of this is that the realm string should be unique among all realms which any single user is likely to
         use. In particular a realm string should include the name of the host doing the authentication. The inability of the client
         to authenticate the server is a weakness of Digest Authentication.
      </p>
      <h2 id="rfc.section.4.14"><a href="#rfc.section.4.14">4.14</a>&nbsp;Summary
      </h2>
      <p id="rfc.section.4.14.p.1">By modern cryptographic standards Digest Authentication is weak. But for a large range of purposes it is valuable as a replacement
         for Basic Authentication. It remedies some, but not all, weaknesses of Basic Authentication. Its strength may vary depending
         on the implementation. In particular the structure of the nonce (which is dependent on the server implementation) may affect
         the ease of mounting a replay attack. A range of server options is appropriate since, for example, some implementations may
         be willing to accept the server overhead of one-time nonces or digests to eliminate the possibility of replay. Others may
         satisfied with a nonce like the one recommended above restricted to a single IP address and a single ETag or with a limited
         lifetime.
      </p>
      <p id="rfc.section.4.14.p.2">The bottom line is that *any* compliant implementation will be relatively weak by cryptographic standards, but *any* compliant
         implementation will be far superior to Basic Authentication.
      </p>
      <h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a>&nbsp;Sample implementation
      </h1>
      <p id="rfc.section.5.p.1">The following code implements the calculations of H(A1), H(A2), request-digest and response-digest, and a test program which
         computes the values used in the example of <a href="#specification.of.digest.headers.example" title="Example">Section&nbsp;3.5</a>. It uses the MD5 implementation from RFC 1321.
      </p>
      <div id="rfc.figure.u.28"></div>
      <p>File "digcalc.h":</p><pre class="text">#define HASHLEN 16
typedef char HASH[HASHLEN];
#define HASHHEXLEN 32
typedef char HASHHEX[HASHHEXLEN+1];
#define IN
#define OUT

/* calculate H(A1) as per HTTP Digest spec */
void DigestCalcHA1(
    IN char * pszAlg,
    IN char * pszUserName,
    IN char * pszRealm,
    IN char * pszPassword,
    IN char * pszNonce,
    IN char * pszCNonce,
    OUT HASHHEX SessionKey
    );

/* calculate request-digest/response-digest as per HTTP Digest spec */
void DigestCalcResponse(
    IN HASHHEX HA1,           /* H(A1) */
    IN char * pszNonce,       /* nonce from server */
    IN char * pszNonceCount,  /* 8 hex digits */
    IN char * pszCNonce,      /* client nonce */
    IN char * pszQop,         /* qop-value: "", "auth", "auth-int" */
    IN char * pszMethod,      /* method from the request */
    IN char * pszDigestUri,   /* requested URL */
    IN HASHHEX HEntity,       /* H(entity body) if qop="auth-int" */
    OUT HASHHEX Response      /* request-digest or response-digest */
    );
</pre><div id="rfc.figure.u.29"></div>
      <p>File "digcalc.c":</p><pre class="text">#include &lt;global.h&gt;
#include &lt;md5.h&gt;
#include &lt;string.h&gt;
#include "digcalc.h"

void CvtHex(
    IN HASH Bin,
    OUT HASHHEX Hex
    )
{
    unsigned short i;
    unsigned char j;

    for (i = 0; i &lt; HASHLEN; i++) {
        j = (Bin[i] &gt;&gt; 4) &amp; 0xf;
        if (j &lt;= 9)
            Hex[i*2] = (j + '0');
         else
            Hex[i*2] = (j + 'a' - 10);
        j = Bin[i] &amp; 0xf;
        if (j &lt;= 9)
            Hex[i*2+1] = (j + '0');
         else
            Hex[i*2+1] = (j + 'a' - 10);
    };
    Hex[HASHHEXLEN] = '\0';
};

/* calculate H(A1) as per spec */
void DigestCalcHA1(
    IN char * pszAlg,
    IN char * pszUserName,
    IN char * pszRealm,
    IN char * pszPassword,
    IN char * pszNonce,
    IN char * pszCNonce,
    OUT HASHHEX SessionKey
    )
{
      MD5_CTX Md5Ctx;
      HASH HA1;

      MD5Init(&amp;Md5Ctx);
      MD5Update(&amp;Md5Ctx, pszUserName, strlen(pszUserName));
      MD5Update(&amp;Md5Ctx, ":", 1);
      MD5Update(&amp;Md5Ctx, pszRealm, strlen(pszRealm));
      MD5Update(&amp;Md5Ctx, ":", 1);
      MD5Update(&amp;Md5Ctx, pszPassword, strlen(pszPassword));
      MD5Final(HA1, &amp;Md5Ctx);
      if (stricmp(pszAlg, "md5-sess") == 0) {
            MD5Init(&amp;Md5Ctx);
            MD5Update(&amp;Md5Ctx, HA1, HASHLEN);
            MD5Update(&amp;Md5Ctx, ":", 1);
            MD5Update(&amp;Md5Ctx, pszNonce, strlen(pszNonce));
            MD5Update(&amp;Md5Ctx, ":", 1);
            MD5Update(&amp;Md5Ctx, pszCNonce, strlen(pszCNonce));
            MD5Final(HA1, &amp;Md5Ctx);
      };
      CvtHex(HA1, SessionKey);
};

/* calculate request-digest/response-digest as per HTTP Digest spec */
void DigestCalcResponse(
    IN HASHHEX HA1,           /* H(A1) */
    IN char * pszNonce,       /* nonce from server */
    IN char * pszNonceCount,  /* 8 hex digits */
    IN char * pszCNonce,      /* client nonce */
    IN char * pszQop,         /* qop-value: "", "auth", "auth-int" */
    IN char * pszMethod,      /* method from the request */
    IN char * pszDigestUri,   /* requested URL */
    IN HASHHEX HEntity,       /* H(entity body) if qop="auth-int" */
    OUT HASHHEX Response      /* request-digest or response-digest */
    )
{
      MD5_CTX Md5Ctx;
      HASH HA2;
      HASH RespHash;
       HASHHEX HA2Hex;

      // calculate H(A2)
      MD5Init(&amp;Md5Ctx);
      MD5Update(&amp;Md5Ctx, pszMethod, strlen(pszMethod));
      MD5Update(&amp;Md5Ctx, ":", 1);
      MD5Update(&amp;Md5Ctx, pszDigestUri, strlen(pszDigestUri));
      if (stricmp(pszQop, "auth-int") == 0) {
            MD5Update(&amp;Md5Ctx, ":", 1);
            MD5Update(&amp;Md5Ctx, HEntity, HASHHEXLEN);
      };
      MD5Final(HA2, &amp;Md5Ctx);
       CvtHex(HA2, HA2Hex);

      // calculate response
      MD5Init(&amp;Md5Ctx);
      MD5Update(&amp;Md5Ctx, HA1, HASHHEXLEN);
      MD5Update(&amp;Md5Ctx, ":", 1);
      MD5Update(&amp;Md5Ctx, pszNonce, strlen(pszNonce));
      MD5Update(&amp;Md5Ctx, ":", 1);
      if (*pszQop) {
          MD5Update(&amp;Md5Ctx, pszNonceCount, strlen(pszNonceCount));
          MD5Update(&amp;Md5Ctx, ":", 1);
          MD5Update(&amp;Md5Ctx, pszCNonce, strlen(pszCNonce));
          MD5Update(&amp;Md5Ctx, ":", 1);
          MD5Update(&amp;Md5Ctx, pszQop, strlen(pszQop));
          MD5Update(&amp;Md5Ctx, ":", 1);
      };
      MD5Update(&amp;Md5Ctx, HA2Hex, HASHHEXLEN);
      MD5Final(RespHash, &amp;Md5Ctx);
      CvtHex(RespHash, Response);
};
</pre><div id="rfc.figure.u.30"></div>
      <p>File "digtest.c":</p><pre class="text">#include &lt;stdio.h&gt;
#include "digcalc.h"

void main(int argc, char ** argv) {

      char * pszNonce = "dcd98b7102dd2f0e8b11d0f600bfb0c093";
      char * pszCNonce = "0a4f113b";
      char * pszUser = "Mufasa";
      char * pszRealm = "testrealm@host.com";
      char * pszPass = "Circle Of Life";
      char * pszAlg = "md5";
      char szNonceCount[9] = "00000001";
      char * pszMethod = "GET";
      char * pszQop = "auth";
      char * pszURI = "/dir/index.html";
      HASHHEX HA1;
      HASHHEX HA2 = "";
      HASHHEX Response;

      DigestCalcHA1(pszAlg, pszUser, pszRealm, pszPass, pszNonce,
pszCNonce, HA1);
      DigestCalcResponse(HA1, pszNonce, szNonceCount, pszCNonce, pszQop,
       pszMethod, pszURI, HA2, Response);
      printf("Response = %s\n", Response);
};
</pre><h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a>&nbsp;Acknowledgments
      </h1>
      <p id="rfc.section.6.p.1">Eric W. Sink, of AbiSource, Inc., was one of the original authors before the specification underwent substantial revision.</p>
      <p id="rfc.section.6.p.2">In addition to the authors, valuable discussion instrumental in creating this document has come from Peter J. Churchyard,
         Ned Freed, and David M. Kristol.
      </p>
      <p id="rfc.section.6.p.3">Jim Gettys and Larry Masinter edited this document for update.</p>
      <h1 id="rfc.references"><a href="#rfc.section.7" id="rfc.section.7">7.</a> References
      </h1>
      <table summary="References"> 
         <tr>
            <td class="reference"><b id="RFC1945">[1]</b></td>
            <td class="top"><a href="mailto:timbl@w3.org" title="MIT, Laboratory for Computer Science">Berners-Lee, T.</a>, <a href="mailto:fielding@ics.uci.edu" title="University of California, Irvine, Department of Information and Computer Science">Fielding, R.T.</a>, and <a href="mailto:frystyk@w3.org" title="W3 Consortium, MIT Laboratory for Computer Science">H.F. Nielsen</a>, “<a href="http://tools.ietf.org/html/rfc1945">Hypertext Transfer Protocol -- HTTP/1.0</a>”, RFC&nbsp;1945, May&nbsp;1996.
            </td>
         </tr>  
         <tr>
            <td class="reference"><b id="RFC2616">[2]</b></td>
            <td class="top"><a href="mailto:fielding@ics.uci.edu" title="University of California, Irvine, Information and Computer Science">Fielding, R.T.</a>, <a href="mailto:jg@w3.org" title="World Wide Web Consortium, MIT Laboratory for Computer Science">Gettys, J.</a>, <a href="mailto:mogul@wrl.dec.com" title="Compaq Computer Corporation, Western Research Laboratory">Mogul, J.C.</a>, <a href="mailto:frystyk@w3.org" title="World Wide Web Consortium, MIT Laboratory for Computer Science">Nielsen, H.F.</a>, <a href="mailto:masinter@parc.xerox.com" title="Xerox Corporation">Masinter, L.</a>, <a href="mailto:paulle@microsoft.com" title="Microsoft Corporation">Leach, P.J.</a>, and <a href="mailto:timbl@w3.org" title="World Wide Web Consortium, MIT Laboratory for Computer Science">T. Berners-Lee</a>, “<a href="http://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>”, RFC&nbsp;2616, June&nbsp;1999.
            </td>
         </tr>  
         <!--WARNING: unused reference 'RFC1321'-->
         <tr>
            <td class="reference"><b id="RFC1321">[3]</b></td>
            <td class="top"><a href="mailto:rivest@theory.lcs.mit.edu" title="Massachusetts Institute of Technology, (MIT) Laboratory for Computer Science">Rivest, R.</a>, “<a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a>”, RFC&nbsp;1321, April&nbsp;1992.
            </td>
         </tr>  
         <!--WARNING: unused reference 'RFC2045'-->
         <tr>
            <td class="reference"><b id="RFC2045">[4]</b></td>
            <td class="top"><a href="mailto:ned@innosoft.com" title="Innosoft International, Inc.">Freed, N.</a> and <a href="mailto:nsb@nsb.fv.com" title="First Virtual Holdings">N.S. Borenstein</a>, “<a href="http://tools.ietf.org/html/rfc2045">Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</a>”, RFC&nbsp;2045, November&nbsp;1996.
            </td>
         </tr>  
         <tr>
            <td class="reference"><b id="RFC2246">[5]</b></td>
            <td class="top"><a href="mailto:tdierks@certicom.com" title="Certicom">Dierks, T.</a> and <a href="mailto:callen@certicom.com" title="Certicom">C. Allen</a>, “<a href="http://tools.ietf.org/html/rfc2246">The TLS Protocol Version 1.0</a>”, RFC&nbsp;2246, January&nbsp;1999.
            </td>
         </tr>  
         <tr>
            <td class="reference"><b id="RFC2069">[6]</b></td>
            <td class="top"><a href="mailto:john@math.nwu.edu" title="Northwestern University,  Department of Mathematics">Franks, J.</a>, <a href="mailto:hallam@w3.org" title="CERN">Hallam-Baker, P.</a>, <a href="mailto:jeff@spyglass.com" title="Spyglass, Inc.">Hostetler, J.</a>, <a href="mailto:paulle@microsoft.com" title="Microsoft Corporation">Leach, P.</a>, <a href="mailto:luotonen@netscape.com" title="Netscape Communications Corporation">Luotonen, A.</a>, <a href="mailto:eric@spyglass.com" title="Spyglass, Inc.">Sink, E.</a>, and <a href="mailto:stewart@OpenMarket.com" title="Open Market, Inc.">L. Stewart</a>, “<a href="http://tools.ietf.org/html/rfc2069">An Extension to HTTP : Digest Access Authentication</a>”, RFC&nbsp;2069, January&nbsp;1997.
            </td>
         </tr>  
         <tr>
            <td class="reference"><b id="RFC2396">[7]</b></td>
            <td class="top"><a href="mailto:timbl@w3.org" title="World Wide Web Consortium">Berners-Lee, T.</a>, <a href="mailto:fielding@ics.uci.edu" title="Department of Information and Computer Science">Fielding, R.T.</a>, and <a href="mailto:masinter@parc.xerox.com" title="Xerox PARC">L. Masinter</a>, “<a href="http://tools.ietf.org/html/rfc2396">Uniform Resource Identifiers (URI): Generic Syntax</a>”, RFC&nbsp;2396, August&nbsp;1998.
            </td>
         </tr>  
         <tr>
            <td class="reference"><b id="ref8">[8]</b></td>
            <td class="top">Kaliski, B. and M. Robshaw, “<a href="http://www.rsa.com/rsalabs/pubs/cryptobytes/spring95/md5.htm">Message Authentication with MD5</a>”, 1995, &lt;<a href="http://www.rsa.com/rsalabs/pubs/cryptobytes/spring95/md5.htm">http://www.rsa.com/rsalabs/pubs/cryptobytes/spring95/md5.htm</a>&gt;.<br>CryptoBytes, Spring 1995
            </td>
         </tr>  
         <tr>
            <td class="reference"><b id="RFC2195">[9]</b></td>
            <td class="top"><a href="mailto:klensin@mci.net" title="MCI">Klensin, J.C.</a>, <a href="mailto:randy@mci.net" title="MCI">Catoe, R.</a>, and <a href="mailto:paul@mci.net" title="MCI">P. Krumviede</a>, “<a href="http://tools.ietf.org/html/rfc2195">IMAP/POP AUTHorize Extension for Simple Challenge/Response</a>”, RFC&nbsp;2195, September&nbsp;1997.
            </td>
         </tr>  
         <tr>
            <td class="reference"><b id="ref10">[10]</b></td>
            <td class="top">Morgan, B., Alvestrand, H., Hodges, J., and M. Wahl, “Authentication Methods for LDAP”.<br>Work in progress.
            </td>
         </tr> 
      </table>
      <h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
      <address class="vcard"><span class="vcardline"><span class="fn">John Franks</span><span class="n hidden"><span class="family-name">Franks</span><span class="given-name">John</span></span></span><span class="org vcardline">Northwestern University, Department of Mathematics</span><span class="adr"><span class="street-address vcardline">Northwestern University</span><span class="vcardline"><span class="locality">Evanston</span>, <span class="region">IL</span>&nbsp;<span class="postal-code">60208-2730</span></span><span class="country-name vcardline">USA</span></span><span class="vcardline">EMail: <a href="mailto:john@math.nwu.edu"><span class="email">john@math.nwu.edu</span></a></span></address>
      <address class="vcard"><span class="vcardline"><span class="fn">Phillip M. Hallam-Baker</span><span class="n hidden"><span class="family-name">Hallam-Baker</span><span class="given-name">Phillip M.</span></span></span><span class="org vcardline">Verisign Inc.</span><span class="adr"><span class="street-address vcardline">301 Edgewater Place</span><span class="street-address vcardline">Suite 210</span><span class="vcardline"><span class="locality">Wakefield</span>, <span class="region">MA</span>&nbsp;<span class="postal-code">01880</span></span><span class="country-name vcardline">USA</span></span><span class="vcardline">EMail: <a href="mailto:pbaker@verisign.com"><span class="email">pbaker@verisign.com</span></a></span></address>
      <address class="vcard"><span class="vcardline"><span class="fn">Jeffery L. Hostetler</span><span class="n hidden"><span class="family-name">Hostetler</span><span class="given-name">Jeffery L.</span></span></span><span class="org vcardline">AbiSource, Inc.</span><span class="adr"><span class="street-address vcardline">6 Dunlap Court</span><span class="vcardline"><span class="locality">Savoy</span>, <span class="region">IL</span>&nbsp;<span class="postal-code">61874</span></span><span class="country-name vcardline">USA</span></span><span class="vcardline">EMail: <a href="mailto:jeff@AbiSource.com"><span class="email">jeff@AbiSource.com</span></a></span></address>
      <address class="vcard"><span class="vcardline"><span class="fn">Scott D. Lawrence</span><span class="n hidden"><span class="family-name">Lawrence</span><span class="given-name">Scott D.</span></span></span><span class="org vcardline">Agranat Systems, Inc.</span><span class="adr"><span class="street-address vcardline">5 Clocktower Place</span><span class="street-address vcardline">Suite 400</span><span class="vcardline"><span class="locality">Maynard</span>, <span class="region">MA</span>&nbsp;<span class="postal-code">01754</span></span><span class="country-name vcardline">USA</span></span><span class="vcardline">EMail: <a href="mailto:lawrence@agranat.com"><span class="email">lawrence@agranat.com</span></a></span></address>
      <address class="vcard"><span class="vcardline"><span class="fn">Paul J. Leach</span><span class="n hidden"><span class="family-name">Leach</span><span class="given-name">Paul J.</span></span></span><span class="org vcardline">Microsoft Corporation</span><span class="adr"><span class="street-address vcardline">1 Microsoft Way</span><span class="vcardline"><span class="locality">Redmond</span>, <span class="region">WA</span>&nbsp;<span class="postal-code">98052</span></span><span class="country-name vcardline">USA</span></span><span class="vcardline">EMail: <a href="mailto:paulle@microsoft.com"><span class="email">paulle@microsoft.com</span></a></span></address>
      <address class="vcard"><span class="vcardline"><span class="fn">Ari Luotonen</span><span class="n hidden"><span class="family-name">Luotonen</span><span class="given-name">Ari</span></span></span><span class="org vcardline">Netscape Communications Corporation</span><span class="adr"><span class="street-address vcardline">501 East Middlefield Road</span><span class="vcardline"><span class="locality">Mountain View</span>, <span class="region">CA</span>&nbsp;<span class="postal-code">94043</span></span><span class="country-name vcardline">USA</span></span></address>
      <address class="vcard"><span class="vcardline"><span class="fn">Lawrence C. Stewart</span><span class="n hidden"><span class="family-name">Stewart</span><span class="given-name">Lawrence C.</span></span></span><span class="org vcardline">Open Market, Inc.</span><span class="adr"><span class="street-address vcardline">215 First Street</span><span class="vcardline"><span class="locality">Cambridge</span>, <span class="region">MA</span>&nbsp;<span class="postal-code">02142</span></span><span class="country-name vcardline">USA</span></span><span class="vcardline">EMail: <a href="mailto:stewart@OpenMarket.com"><span class="email">stewart@OpenMarket.com</span></a></span></address>
      <h1><a id="rfc.copyright" href="#rfc.copyright">Full Copyright Statement</a></h1>
      <p>Copyright © The Internet Society (1999). All Rights Reserved.</p>
      <p>This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise
         explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without
         restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative
         works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references
         to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards
         in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to
         translate it into languages other than English.
      </p>
      <p>The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assignees.</p>
      <p>This document and the information contained herein is provided on an “AS IS” basis and THE INTERNET SOCIETY AND THE INTERNET
         ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE
         OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
         PURPOSE.
      </p>
      <h1><a id="rfc.ipr" href="#rfc.ipr">Intellectual Property</a></h1>
      <p>The IETF takes no position regarding the validity or scope of any intellectual property or other rights that might be claimed
         to pertain to the implementation or use of the technology described in this document or the extent to which any license under
         such rights might or might not be available; neither does it represent that it has made any effort to identify any such rights.
         Information on the IETF's procedures with respect to rights in standards-track and standards-related documentation can be
         found in BCP-11. Copies of claims of rights made available for publication and any assurances of licenses to be made available,
         or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementors
         or users of this specification can be obtained from the IETF Secretariat.
      </p>
      <p>The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary
         rights which may cover technology that may be required to practice this standard. Please address the information to the IETF
         Executive Director.
      </p>
      <h1>Acknowledgment</h1>
      <p>Funding for the RFC Editor function is currently provided by the Internet Society.</p>
      <h1 id="rfc.index"><a href="#rfc.index">Index</a></h1>
      <p class="noprint"><a href="#rfc.index.A">A</a> <a href="#rfc.index.B">B</a> <a href="#rfc.index.C">C</a> <a href="#rfc.index.D">D</a> <a href="#rfc.index.H">H</a> <a href="#rfc.index.L">L</a> <a href="#rfc.index.M">M</a> <a href="#rfc.index.N">N</a> <a href="#rfc.index.O">O</a> <a href="#rfc.index.P">P</a> <a href="#rfc.index.Q">Q</a> <a href="#rfc.index.R">R</a> <a href="#rfc.index.S">S</a> <a href="#rfc.index.U">U</a> <a href="#rfc.index.W">W</a> 
      </p>
      <div class="print2col">
         <ul class="ind">
            <li class="indline0"><a id="rfc.index.A" href="#rfc.index.A"><b>A</b></a><ul class="ind">
                  <li class="indline1"><tt>algorithm</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.a.3"><b>3.2.1</b></a></li>
                  <li class="indline1"><tt>auth-info</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.a.7"><b>3.2.3</b></a></li>
                  <li class="indline1"><tt>auth-param</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.a.2"><b>1.2</b></a></li>
                  <li class="indline1"><tt>auth-scheme</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.a.1"><b>1.2</b></a></li>
                  <li class="indline1"><tt>Authentication-Info</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.a.6"><b>3.2.3</b></a></li>
                  <li class="indline1">Authentication-Info header&nbsp;&nbsp;<a class="iref" href="#rfc.iref.a.5"><b>3.2.3</b></a></li>
                  <li class="indline1">Authorization header&nbsp;&nbsp;<a class="iref" href="#rfc.iref.a.4"><b>3.2.2</b></a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.B" href="#rfc.index.B"><b>B</b></a><ul class="ind">
                  <li class="indline1"><tt>base64-user-pass</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.b.2"><b>2</b></a></li>
                  <li class="indline1"><tt>basic-credentials</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.b.1"><b>2</b></a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.C" href="#rfc.index.C"><b>C</b></a><ul class="ind">
                  <li class="indline1"><tt>challenge</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.1"><b>1.2</b></a>, <a class="iref" href="#rfc.iref.c.3">2</a>, <a class="iref" href="#rfc.iref.c.5">3.2.1</a></li>
                  <li class="indline1"><tt>cnonce</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.7"><b>3.2.2</b></a></li>
                  <li class="indline1"><tt>cnonce-value</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.8"><b>3.2.2</b></a></li>
                  <li class="indline1"><tt>credentials</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.c.2"><b>1.2</b></a>, <a class="iref" href="#rfc.iref.c.4">2</a>, <a class="iref" href="#rfc.iref.c.6">3.2.2</a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.D" href="#rfc.index.D"><b>D</b></a><ul class="ind">
                  <li class="indline1"><tt>digest-challenge</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.d.1"><b>3.2.1</b></a></li>
                  <li class="indline1"><tt>digest-response</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.d.3"><b>3.2.2</b></a></li>
                  <li class="indline1"><tt>digest-uri</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.d.4"><b>3.2.2</b></a></li>
                  <li class="indline1"><tt>digest-uri-value</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.d.5"><b>3.2.2</b></a></li>
                  <li class="indline1"><tt>domain</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.d.2"><b>3.2.1</b></a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.H" href="#rfc.index.H"><b>H</b></a><ul class="ind">
                  <li class="indline1">Headers&nbsp;&nbsp;
                     <ul class="ind">
                        <li class="indline1">Authentication-Info&nbsp;&nbsp;<a class="iref" href="#rfc.iref.h.3"><b>3.2.3</b></a></li>
                        <li class="indline1">Authorization&nbsp;&nbsp;<a class="iref" href="#rfc.iref.h.2"><b>3.2.2</b></a></li>
                        <li class="indline1">WWW-Authenticate&nbsp;&nbsp;<a class="iref" href="#rfc.iref.h.1"><b>3.2.1</b></a></li>
                     </ul>
                  </li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.L" href="#rfc.index.L"><b>L</b></a><ul class="ind">
                  <li class="indline1"><tt>LHEX</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.l.1"><b>3.2.2</b></a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.M" href="#rfc.index.M"><b>M</b></a><ul class="ind">
                  <li class="indline1"><tt>message-qop</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.m.1"><b>3.2.2</b></a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.N" href="#rfc.index.N"><b>N</b></a><ul class="ind">
                  <li class="indline1"><tt>nc-value</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.n.4"><b>3.2.2</b></a></li>
                  <li class="indline1"><tt>nextnonce</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.n.5"><b>3.2.3</b></a></li>
                  <li class="indline1"><tt>nonce</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.n.1"><b>3.2.1</b></a></li>
                  <li class="indline1"><tt>nonce-count</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.n.3"><b>3.2.2</b></a></li>
                  <li class="indline1"><tt>nonce-value</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.n.2"><b>3.2.1</b></a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.O" href="#rfc.index.O"><b>O</b></a><ul class="ind">
                  <li class="indline1"><tt>opaque</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.o.1"><b>3.2.1</b></a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.P" href="#rfc.index.P"><b>P</b></a><ul class="ind">
                  <li class="indline1"><tt>password</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.p.1"><b>2</b></a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.Q" href="#rfc.index.Q"><b>Q</b></a><ul class="ind">
                  <li class="indline1"><tt>qop-options</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.q.1"><b>3.2.1</b></a></li>
                  <li class="indline1"><tt>qop-value</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.q.2"><b>3.2.1</b></a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.R" href="#rfc.index.R"><b>R</b></a><ul class="ind">
                  <li class="indline1"><tt>realm</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.r.1"><b>1.2</b></a></li>
                  <li class="indline1"><tt>realm-value</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.r.2"><b>1.2</b></a></li>
                  <li class="indline1"><em>ref10</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.ref10.1">4.2</a>, <a class="iref" href="#ref10"><b>7</b></a></li>
                  <li class="indline1"><em>ref8</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.ref8.1">4.9</a>, <a class="iref" href="#ref8"><b>7</b></a></li>
                  <li class="indline1"><tt>request-digest</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.r.4"><b>3.2.2</b></a></li>
                  <li class="indline1"><tt>response</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.r.3"><b>3.2.2</b></a></li>
                  <li class="indline1"><tt>response-auth</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.r.5"><b>3.2.3</b></a></li>
                  <li class="indline1"><tt>response-digest</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.r.6"><b>3.2.3</b></a></li>
                  <li class="indline1"><em>RFC1321</em>&nbsp;&nbsp;<a class="iref" href="#RFC1321"><b>7</b></a></li>
                  <li class="indline1"><em>RFC1945</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC1945.1">3.1.1</a>, <a class="iref" href="#RFC1945"><b>7</b></a></li>
                  <li class="indline1"><em>RFC2045</em>&nbsp;&nbsp;<a class="iref" href="#RFC2045"><b>7</b></a></li>
                  <li class="indline1"><em>RFC2069</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2069.1">§</a>, <a class="iref" href="#rfc.xref.RFC2069.2">3.2.1</a>, <a class="iref" href="#rfc.xref.RFC2069.3">3.2.2</a>, <a class="iref" href="#RFC2069"><b>7</b></a></li>
                  <li class="indline1"><em>RFC2195</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2195.1">4.2</a>, <a class="iref" href="#RFC2195"><b>7</b></a></li>
                  <li class="indline1"><em>RFC2246</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2246.1">§</a>, <a class="iref" href="#RFC2246"><b>7</b></a></li>
                  <li class="indline1"><em>RFC2396</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2396.1">2</a>, <a class="iref" href="#rfc.xref.RFC2396.2">3.2.1</a>, <a class="iref" href="#RFC2396"><b>7</b></a></li>
                  <li class="indline1"><em>RFC2616</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2616.1">1.1</a>, <a class="iref" href="#rfc.xref.RFC2616.2">1.1</a>, <a class="iref" href="#rfc.xref.RFC2616.3">1.2</a>, <a class="iref" href="#rfc.xref.RFC2616.4">1.2</a>, <a class="iref" href="#rfc.xref.RFC2616.5">1.2</a>, <a class="iref" href="#rfc.xref.RFC2616.6">1.2</a>, <a class="iref" href="#rfc.xref.RFC2616.7">1.2</a>, <a class="iref" href="#rfc.xref.RFC2616.8">1.2</a>, <a class="iref" href="#rfc.xref.RFC2616.9">3.2.2.5</a>, <a class="iref" href="#rfc.xref.RFC2616.10">3.2.2.5</a>, <a class="iref" href="#rfc.xref.RFC2616.11">3.2.2.5</a>, <a class="iref" href="#rfc.xref.RFC2616.12">3.2.2.5</a>, <a class="iref" href="#rfc.xref.RFC2616.13">3.2.2.5</a>, <a class="iref" href="#rfc.xref.RFC2616.14">3.2.2.5</a>, <a class="iref" href="#rfc.xref.RFC2616.15">3.2.2.5</a>, <a class="iref" href="#rfc.xref.RFC2616.16">3.2.2.5</a>, <a class="iref" href="#rfc.xref.RFC2616.17">3.2.2.5</a>, <a class="iref" href="#rfc.xref.RFC2616.18">3.2.2.5</a>, <a class="iref" href="#rfc.xref.RFC2616.19">3.6</a>, <a class="iref" href="#rfc.xref.RFC2616.20">3.6</a>, <a class="iref" href="#rfc.xref.RFC2616.21">3.6</a>, <a class="iref" href="#RFC2616"><b>7</b></a><ul class="ind">
                        <li class="indline1"><em>Section 10.33</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2616.19">3.6</a></li>
                        <li class="indline1"><em>Section 10.34</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2616.20">3.6</a></li>
                     </ul>
                     <ul class="ind">
                        <li class="indline1"><em>Section 2.1</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2616.2">1.1</a></li>
                        <li class="indline1"><em>Section 5.1.1</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2616.9">3.2.2.5</a></li>
                        <li class="indline1"><em>Section 5.1.2</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2616.3">1.2</a>, <a class="iref" href="#rfc.xref.RFC2616.11">3.2.2.5</a>, <a class="iref" href="#rfc.xref.RFC2616.13">3.2.2.5</a></li>
                        <li class="indline1"><em>Section 13.5.1</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2616.7">1.2</a></li>
                        <li class="indline1"><em>Section 13.7</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2616.15">3.2.2.5</a></li>
                        <li class="indline1"><em>Section 14.8</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2616.5">1.2</a></li>
                        <li class="indline1"><em>Section 14.9</em>&nbsp;&nbsp;<a class="iref" href="#rfc.xref.RFC2616.17">3.2.2.5</a></li>
                     </ul>
                  </li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.S" href="#rfc.index.S"><b>S</b></a><ul class="ind">
                  <li class="indline1"><tt>stale</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.s.1"><b>3.2.1</b></a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.U" href="#rfc.index.U"><b>U</b></a><ul class="ind">
                  <li class="indline1"><tt>URI</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.u.3"><b>3.2.1</b></a></li>
                  <li class="indline1"><tt>user-pass</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.u.1"><b>2</b></a></li>
                  <li class="indline1"><tt>userid</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.u.2"><b>2</b></a></li>
                  <li class="indline1"><tt>username</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.u.4"><b>3.2.2</b></a></li>
                  <li class="indline1"><tt>username-value</tt>&nbsp;&nbsp;<a class="iref" href="#rfc.iref.u.5"><b>3.2.2</b></a></li>
               </ul>
            </li>
            <li class="indline0"><a id="rfc.index.W" href="#rfc.index.W"><b>W</b></a><ul class="ind">
                  <li class="indline1">WWW-Authenticate header&nbsp;&nbsp;<a class="iref" href="#rfc.iref.w.1"><b>3.2.1</b></a></li>
               </ul>
            </li>
         </ul>
      </div>
   </body>
</html>