--- draft-ietf-httpbis-semantics-latest.txt	2022-03-11 09:35:14.028942700 +0100
+++ rfc9110-to-be.txt	2022-03-11 09:35:04.041380900 +0100
@@ -2,17 +2,17 @@
 
 
 
-HTTP Working Group                                      R. Fielding, Ed.
-Internet-Draft                                                     Adobe
-Obsoletes: 2818, 7230, 7231, 7232, 7233, 7235,        M. Nottingham, Ed.
-           7538, 7615, 7694 (if approved)                         Fastly
-Updates: 3864 (if approved)                              J. Reschke, Ed.
-Intended status: Standards Track                              greenbytes
-Expires: 12 September 2022                                 11 March 2022
+Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
+Request for Comments: 9110                                         Adobe
+STD: 97                                               M. Nottingham, Ed.
+Obsoletes: 2818, 7230, 7231, 7232, 7233, 7235,                    Fastly
+           7538, 7615, 7694                              J. Reschke, Ed.
+Updates: 3864                                                 greenbytes
+Category: Standards Track                                  February 2022
+ISSN: 2070-1721
 
 
                              HTTP Semantics
-                  draft-ietf-httpbis-semantics-latest
 
 Abstract
 
@@ -27,36 +27,19 @@
    This document updates RFC 3864 and obsoletes RFCs 2818, 7231, 7232,
    7233, 7235, 7538, 7615, 7694, and portions of 7230.
 
-Editorial Note
-
-   This note is to be removed before publishing as an RFC.
-
-   Discussion of this draft takes place on the HTTP working group
-   mailing list (ietf-http-wg@w3.org), which is archived at
-   <https://lists.w3.org/Archives/Public/ietf-http-wg/>.
-
-   Working Group information can be found at <https://httpwg.org/>;
-   source code and issues list for this draft can be found at
-   <https://github.com/httpwg/http-core>.
-
-   The changes in this draft are summarized in Appendix C.1.
-
 Status of This Memo
 
-   This Internet-Draft is submitted in full conformance with the
-   provisions of BCP 78 and BCP 79.
-
-   Internet-Drafts are working documents of the Internet Engineering
-   Task Force (IETF).  Note that other groups may also distribute
-   working documents as Internet-Drafts.  The list of current Internet-
-   Drafts is at https://datatracker.ietf.org/drafts/current/.
-
-   Internet-Drafts are draft documents valid for a maximum of six months
-   and may be updated, replaced, or obsoleted by other documents at any
-   time.  It is inappropriate to use Internet-Drafts as reference
-   material or to cite them other than as "work in progress."
+   This is an Internet Standards Track document.
 
-   This Internet-Draft will expire on 12 September 2022.
+   This document is a product of the Internet Engineering Task Force
+   (IETF).  It represents the consensus of the IETF community.  It has
+   received public review and has been approved for publication by the
+   Internet Engineering Steering Group (IESG).  Further information on
+   Internet Standards is available in Section 2 of RFC 7841.
+
+   Information about the current status of this document, any errata,
+   and how to provide feedback on it may be obtained at
+   https://www.rfc-editor.org/info/rfc9110.
 
 Copyright Notice
 
@@ -64,13 +47,14 @@
    document authors.  All rights reserved.
 
    This document is subject to BCP 78 and the IETF Trust's Legal
-   Provisions Relating to IETF Documents (https://trustee.ietf.org/
-   license-info) in effect on the date of publication of this document.
-   Please review these documents carefully, as they describe your rights
-   and restrictions with respect to this document.  Code Components
-   extracted from this document must include Revised BSD License text as
-   described in Section 4.e of the Trust Legal Provisions and are
-   provided without warranty as described in the Revised BSD License.
+   Provisions Relating to IETF Documents
+   (https://trustee.ietf.org/license-info) in effect on the date of
+   publication of this document.  Please review these documents
+   carefully, as they describe your rights and restrictions with respect
+   to this document.  Code Components extracted from this document must
+   include Revised BSD License text as described in Section 4.e of the
+   Trust Legal Provisions and are provided without warranty as described
+   in the Revised BSD License.
 
    This document may contain material from IETF Documents or IETF
    Contributions published or made publicly available before November
@@ -189,7 +173,7 @@
        8.8.3.  ETag
          8.8.3.1.  Generation
          8.8.3.2.  Comparison
-         8.8.3.3.  Example: Entity Tags Varying on Content-Negotiated
+         8.8.3.3.  Example: Entity-Tags Varying on Content-Negotiated
                  Resources
    9.  Methods
      9.1.  Overview
@@ -389,8 +373,6 @@
      B.7.  Changes from RFC 7538
      B.8.  Changes from RFC 7615
      B.9.  Changes from RFC 7694
-   Appendix C.  Change Log
-     C.1.  Since draft-ietf-httpbis-semantics-19
    Acknowledgements
    Index
    Authors' Addresses
@@ -566,8 +548,8 @@
 
    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
    "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
-   "OPTIONAL" in this document are to be interpreted as described in BCP
-   14 [RFC2119] [RFC8174] when, and only when, they appear in all
+   "OPTIONAL" in this document are to be interpreted as described in
+   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
    capitals, as shown here.
 
    This specification targets conformance criteria according to the role
@@ -1175,9 +1157,9 @@
 
 4.2.3.  http(s) Normalization and Comparison
 
-   URIs with an "http" or "https" scheme are normalized and compared
-   according to the methods defined in Section 6 of [URI], using the
-   defaults described above for each scheme.
+   The "http" and "https" URI are normalized and compared according to
+   the methods defined in Section 6 of [URI], using the defaults
+   described above for each scheme.
 
    HTTP does not require the use of a specific method for determining
    equivalence.  For example, a cache key might be compared as a simple
@@ -1469,7 +1451,7 @@
 
 5.  Fields
 
-   HTTP uses "fields" to provide data in the form of extensible name/
+   HTTP uses "fields" to provide data in the form of extensible key/
    value pairs with a registered key namespace.  Fields are sent and
    received within the header and trailer sections of messages
    (Section 6).
@@ -1828,7 +1810,7 @@
 
 5.6.6.  Parameters
 
-   Parameters are instances of name/value pairs; they are often used in
+   Parameters are instances of name=value pairs; they are often used in
    field values as a common syntax for appending auxiliary information
    to an item.  Each parameter is usually delimited by an immediately
    preceding semicolon.
@@ -1969,13 +1951,13 @@
 
    *  control data to describe and route the message,
 
-   *  a headers lookup table of name/value pairs for extending that
+   *  a headers lookup table of key/value pairs for extending that
       control data and conveying additional information about the
       sender, message, content, or context,
 
    *  a potentially unbounded stream of content, and
 
-   *  a trailers lookup table of name/value pairs for communicating
+   *  a trailers lookup table of key/value pairs for communicating
       information obtained while sending the content.
 
    Framing and control data is sent first, followed by a header section
@@ -2244,8 +2226,8 @@
 
    A trailer section is only possible when supported by the version of
    HTTP in use and enabled by an explicit framing mechanism.  For
-   example, the chunked transfer coding in HTTP/1.1 allows a trailer
-   section to be sent after the content (Section 7.1.2 of [HTTP/1.1]).
+   example, the chunked coding in HTTP/1.1 allows a trailer section to
+   be sent after the content (Section 7.1.2 of [HTTP/1.1]).
 
    Many fields cannot be processed outside the header section because
    their evaluation is necessary prior to receiving the content, such as
@@ -2297,7 +2279,7 @@
    if each member value is only processed once per field line received.
 
    At the end of a message, a recipient MAY treat the set of received
-   trailer fields as a data structure of name/value pairs, similar to
+   trailer fields as a data structure of key/value pairs, similar to
    (but separate from) the header fields.  Additional processing
    expectations, if any, can be defined within the field specification
    for a field intended for use in trailers.
@@ -3002,7 +2984,7 @@
    The type and subtype tokens are case-insensitive.
 
    The type/subtype MAY be followed by semicolon-delimited parameters
-   (Section 5.6.6) in the form of name/value pairs.  The presence or
+   (Section 5.6.6) in the form of name=value pairs.  The presence or
    absence of a parameter might be significant to the processing of a
    media type, depending on its definition within the media type
    registry.  Parameter values might or might not be case-sensitive,
@@ -3396,8 +3378,8 @@
    selected representation as a result of processing the request.
 
    For example, an ETag field in a 201 (Created) response communicates
-   the entity tag of the newly created resource's representation, so
-   that the entity tag can be used as a validator in later conditional
+   the entity-tag of the newly created resource's representation, so
+   that the entity-tag can be used as a validator in later conditional
    requests to prevent the "lost update" problem.
 
    This specification defines two forms of metadata that are commonly
@@ -3461,9 +3443,9 @@
    owner to group representations by some self-determined set of
    equivalency rather than unique sequences of data.
 
-   An origin server SHOULD change a weak entity tag whenever it
+   An origin server SHOULD change a weak entity-tag whenever it
    considers prior representations to be unacceptable as a substitute
-   for the current representation.  In other words, a weak entity tag
+   for the current representation.  In other words, a weak entity-tag
    ought to change whenever the origin server wants caches to invalidate
    old responses.
 
@@ -3587,14 +3569,14 @@
 
 8.8.3.  ETag
 
-   The "ETag" field in a response provides the current entity tag for
+   The "ETag" field in a response provides the current entity-tag for
    the selected representation, as determined at the conclusion of
-   handling the request.  An entity tag is an opaque validator for
+   handling the request.  An entity-tag is an opaque validator for
    differentiating between multiple representations of the same
    resource, regardless of whether those multiple representations are
    due to resource state changes over time, content negotiation
    resulting in multiple representations being valid at the same time,
-   or both.  An entity tag consists of an opaque quoted string, possibly
+   or both.  An entity-tag consists of an opaque quoted string, possibly
    prefixed by a weakness indicator.
 
      ETag       = entity-tag
@@ -3610,9 +3592,9 @@
       |  perform backslash unescaping.  Servers therefore ought to avoid
       |  backslash characters in entity tags.
 
-   An entity tag can be more reliable for validation than a modification
+   An entity-tag can be more reliable for validation than a modification
    date in situations where it is inconvenient to store modification
-   dates, where the one-second resolution of HTTP-date values is not
+   dates, where the one-second resolution of HTTP date values is not
    sufficient, or where modification dates are not consistently
    maintained.
 
@@ -3622,26 +3604,26 @@
    ETag: W/"xyzzy"
    ETag: ""
 
-   An entity tag can be either a weak or strong validator, with strong
-   being the default.  If an origin server provides an entity tag for a
-   representation and the generation of that entity tag does not satisfy
+   An entity-tag can be either a weak or strong validator, with strong
+   being the default.  If an origin server provides an entity-tag for a
+   representation and the generation of that entity-tag does not satisfy
    all of the characteristics of a strong validator (Section 8.8.1),
-   then the origin server MUST mark the entity tag as weak by prefixing
+   then the origin server MUST mark the entity-tag as weak by prefixing
    its opaque value with "W/" (case-sensitive).
 
    A sender MAY send the ETag field in a trailer section (see
    Section 6.5).  However, since trailers are often ignored, it is
-   preferable to send ETag as a header field unless the entity tag is
+   preferable to send ETag as a header field unless the entity-tag is
    generated while sending the content.
 
 8.8.3.1.  Generation
 
-   The principle behind entity tags is that only the service author
+   The principle behind entity-tags is that only the service author
    knows the implementation of a resource well enough to select the most
    accurate and efficient validation mechanism for that resource, and
    that any such mechanism can be mapped to a simple sequence of octets
    for easy comparison.  Since the value is opaque, there is no need for
-   the client to be aware of how each entity tag is constructed.
+   the client to be aware of how each entity-tag is constructed.
 
    For example, a resource that has implementation-specific versioning
    applied to all changes might use an internal revision number, perhaps
@@ -3653,24 +3635,24 @@
 
    An origin server SHOULD send an ETag for any selected representation
    for which detection of changes can be reasonably and consistently
-   determined, since the entity tag's use in conditional requests and
+   determined, since the entity-tag's use in conditional requests and
    evaluating cache freshness ([CACHING]) can substantially reduce
    unnecessary transfers and significantly improve service availability,
    scalability, and reliability.
 
 8.8.3.2.  Comparison
 
-   There are two entity tag comparison functions, depending on whether
+   There are two entity-tag comparison functions, depending on whether
    or not the comparison context allows the use of weak validators:
 
-   "Strong comparison":  two entity tags are equivalent if both are not
+   "Strong comparison":  two entity-tags are equivalent if both are not
       weak and their opaque-tags match character-by-character.
 
-   "Weak comparison":  two entity tags are equivalent if their opaque-
+   "Weak comparison":  two entity-tags are equivalent if their opaque-
       tags match character-by-character, regardless of either or both
       being tagged as "weak".
 
-   The example below shows the results for a set of entity tag pairs and
+   The example below shows the results for a set of entity-tag pairs and
    both the weak and strong comparison function results:
 
    +========+========+===================+=================+
@@ -3687,7 +3669,7 @@
 
                             Table 3
 
-8.8.3.3.  Example: Entity Tags Varying on Content-Negotiated Resources
+8.8.3.3.  Example: Entity-Tags Varying on Content-Negotiated Resources
 
    Consider a resource that is subject to content negotiation
    (Section 12), and where the representations sent in response to a GET
@@ -3734,12 +3716,12 @@
    ...binary data...
 
       |  *Note:* Content codings are a property of the representation
-      |  data, so a strong entity tag for a content-encoded
+      |  data, so a strong entity-tag for a content-encoded
       |  representation has to be distinct from the entity tag of an
       |  unencoded representation to prevent potential conflicts during
       |  cache updates and range requests.  In contrast, transfer
       |  codings (Section 7 of [HTTP/1.1]) apply only during message
-      |  transfer and do not result in distinct entity tags.
+      |  transfer and do not result in distinct entity-tags.
 
 9.  Methods
 
@@ -4642,7 +4624,7 @@
 10.1.4.  TE
 
    The "TE" header field describes capabilities of the client with
-   regard to transfer codings and trailer sections.
+   regard to transfer encodings and trailer sections.
 
    As described in Section 6.5, a TE field with a "trailers" member sent
    in a request indicates that the client will not discard trailer
@@ -4906,7 +4888,7 @@
    filename safe alphabet), base32, or base16 (hex) encoding, with or
    without padding, but excluding whitespace ([RFC4648]).
 
-   Authentication parameters are name/value pairs, where the name token
+   Authentication parameters are name=value pairs, where the name token
    is matched case-insensitively and each parameter name MUST only occur
    once per challenge.
 
@@ -5805,11 +5787,11 @@
    the recipient origin server either having at least one current
    representation of the target resource, when the field value is "*",
    or having a current representation of the target resource that has an
-   entity tag matching a member of the list of entity tags provided in
+   entity-tag matching a member of the list of entity-tags provided in
    the field value.
 
    An origin server MUST use the strong comparison function when
-   comparing entity tags for If-Match (Section 8.8.3.2), since the
+   comparing entity-tags for If-Match (Section 8.8.3.2), since the
    client intends this precondition to prevent the method from being
    applied if there have been any changes to the representation data.
 
@@ -5827,7 +5809,7 @@
    prevent the "lost update" problem).  In general, it can be used with
    any method that involves the selection or modification of a
    representation to abort the request if the selected representation's
-   current entity tag is not a member within the If-Match field value.
+   current entity-tag is not a member within the If-Match field value.
 
    When an origin server receives a request that selects a
    representation and that request includes an If-Match header field,
@@ -5839,8 +5821,8 @@
    1.  If the field value is "*", the condition is true if the origin
        server has a current representation for the target resource.
 
-   2.  If the field value is a list of entity tags, the condition is
-       true if any of the listed tags match the entity tag of the
+   2.  If the field value is a list of entity-tags, the condition is
+       true if any of the listed tags match the entity-tag of the
        selected representation.
 
    3.  Otherwise, the condition is false.
@@ -5891,11 +5873,11 @@
    The "If-None-Match" header field makes the request method conditional
    on a recipient cache or origin server either not having any current
    representation of the target resource, when the field value is "*",
-   or having a selected representation with an entity tag that does not
+   or having a selected representation with an entity-tag that does not
    match any of those listed in the field value.
 
    A recipient MUST use the weak comparison function when comparing
-   entity tags for If-None-Match (Section 8.8.3.2), since weak entity
+   entity-tags for If-None-Match (Section 8.8.3.2), since weak entity-
    tags can be used for cache validation even if there have been changes
    to the representation data.
 
@@ -5912,8 +5894,8 @@
    If-None-Match is primarily used in conditional GET requests to enable
    efficient updates of cached information with a minimum amount of
    transaction overhead.  When a client desires to update one or more
-   stored responses that have entity tags, the client SHOULD generate an
-   If-None-Match header field containing a list of those entity tags
+   stored responses that have entity-tags, the client SHOULD generate an
+   If-None-Match header field containing a list of those entity-tags
    when making a GET request; this allows recipient servers to send a
    304 (Not Modified) response to indicate when one of those stored
    responses matches the selected representation.
@@ -5936,8 +5918,8 @@
    1.  If the field value is "*", the condition is false if the origin
        server has a current representation for the target resource.
 
-   2.  If the field value is a list of entity tags, the condition is
-       false if one of the listed tags matches the entity tag of the
+   2.  If the field value is a list of entity-tags, the condition is
+       false if one of the listed tags matches the entity-tag of the
        selected representation.
 
    3.  Otherwise, the condition is true.
@@ -5990,7 +5972,7 @@
 
    If-Modified-Since is typically used for two distinct purposes: 1) to
    allow efficient updates of a cached representation that does not have
-   an entity tag and 2) to limit the scope of a web traversal to
+   an entity-tag and 2) to limit the scope of a web traversal to
    resources that have recently changed.
 
    When used for cache updates, a cache will typically use the value of
@@ -6043,7 +6025,7 @@
    conditional on the selected representation's last modification date
    being earlier than or equal to the date provided in the field value.
    This field accomplishes the same purpose as If-Match for cases where
-   the user agent does not have an entity tag for the representation.
+   the user agent does not have an entity-tag for the representation.
 
      If-Unmodified-Since = HTTP-date
 
@@ -6070,7 +6052,7 @@
    If-Unmodified-Since is most often used with state-changing methods
    (e.g., POST, PUT, DELETE) to prevent accidental overwrites when
    multiple user agents might be acting in parallel on a resource that
-   does not supply entity tags with its representations (i.e., to
+   does not supply entity-tags with its representations (i.e., to
    prevent the "lost update" problem).  In general, it can be used with
    any method that involves the selection or modification of a
    representation to abort the request if the selected representation's
@@ -6158,9 +6140,9 @@
    support Range requests.
 
    A client MUST NOT generate an If-Range header field containing an
-   entity tag that is marked as weak.  A client MUST NOT generate an If-
+   entity-tag that is marked as weak.  A client MUST NOT generate an If-
    Range header field containing an HTTP-date unless the client has no
-   entity tag for the corresponding representation and the date is a
+   entity-tag for the corresponding representation and the date is a
    strong validator in the sense defined by Section 8.8.2.2.
 
    A server that receives an If-Range header field on a Range request
@@ -6775,8 +6757,8 @@
 
                             Macintosh file type code(s):  N/A
 
-   Person and email address to contact for further information:  See Aut
-      hors' Addresses section.
+   Person and email address to contact for further information:
+      See Authors' Addresses section
 
    Intended usage:  COMMON
 
@@ -6956,7 +6938,7 @@
 
    In 200 responses to GET or HEAD, an origin server SHOULD send any
    available validator fields (Section 8.8) for the selected
-   representation, with both a strong entity tag and a Last-Modified
+   representation, with both a strong entity-tag and a Last-Modified
    date being preferred.
 
    In 200 responses to state-changing methods, any validator fields
@@ -7022,7 +7004,7 @@
 
    For example, if a 204 status code is received in response to a PUT
    request and the response contains an ETag field, then the PUT was
-   successful and the ETag field value contains the entity tag for the
+   successful and the ETag field value contains the entity-tag for the
    new representation of that target resource.
 
    The 204 response allows a server to indicate that the action has been
@@ -8854,11 +8836,11 @@
    and the client will receive a response that is no more harmful than
    an HTTP exchange without conditional requests.
 
-   An entity tag can be abused in ways that create privacy risks.  For
+   An entity-tag can be abused in ways that create privacy risks.  For
    example, a site might deliberately construct a semantically invalid
-   entity tag that is unique to the user or user agent, send it in a
+   entity-tag that is unique to the user or user agent, send it in a
    cacheable response with a long freshness time, and then read that
-   entity tag in later conditional requests as a means of re-identifying
+   entity-tag in later conditional requests as a means of re-identifying
    that user or user agent.  Such an identifying tag would become a
    persistent identifier for as long as the user agent retained the
    original cache entry.  User agents that cache representations ought
@@ -9357,10 +9339,8 @@
 19.1.  Normative References
 
    [CACHING]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
-              Ed., "HTTP Caching", Work in Progress, Internet-Draft,
-              draft-ietf-httpbis-cache-latest, March 2022,
-              <https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-
-              cache-latest>.
+              Ed., "HTTP Caching", RFC 9111, DOI 10.17487/RFC9111,
+              February 2022, <https://www.rfc-editor.org/info/rfc9111>.
 
    [RFC1950]  Deutsch, P. and J-L. Gailly, "ZLIB Compressed Data Format
               Specification version 3.3", RFC 1950,
@@ -9521,10 +9501,8 @@
               <https://www.rfc-editor.org/info/rfc1945>.
 
    [HTTP/1.1] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
-              Ed., "HTTP/1.1", Work in Progress, Internet-Draft, draft-
-              ietf-httpbis-messaging-latest, March 2022,
-              <https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-
-              messaging-latest>.
+              Ed., "HTTP/1.1", RFC 9112, DOI 10.17487/RFC9112, February
+              2022, <https://www.rfc-editor.org/info/rfc9112>.
 
    [HTTP/2]   Belshe, M., Peon, R., and M. Thomson, Ed., "Hypertext
               Transfer Protocol Version 2 (HTTP/2)", RFC 7540,
@@ -9532,10 +9510,8 @@
               <https://www.rfc-editor.org/info/rfc7540>.
 
    [HTTP/3]   Bishop, M., Ed., "Hypertext Transfer Protocol Version 3
-              (HTTP/3)", Work in Progress, Internet-Draft, draft-ietf-
-              quic-http-34, 2 February 2021,
-              <https://datatracker.ietf.org/doc/html/draft-ietf-quic-
-              http-34>.
+              (HTTP/3)", RFC 9114, DOI 10.17487/RFC9114, February 2022,
+              <https://www.rfc-editor.org/info/rfc9114>.
 
    [ISO-8859-1]
               International Organization for Standardization,
@@ -10010,8 +9986,8 @@
    single header line's value, use "field line value".  (Section 6.3)
 
    Trailer field semantics now transcend the specifics of chunked
-   transfer coding.  The use of trailer fields has been further limited
-   to allow generation as a trailer field only when the sender knows the
+   encoding.  The use of trailer fields has been further limited to
+   allow generation as a trailer field only when the sender knows the
    field defines that usage and to allow merging into the header section
    only if the recipient knows the corresponding field definition
    permits and defines how to merge.  In all other cases,
@@ -10170,30 +10146,6 @@
    This specification includes the extension defined in [RFC7694] but
    leaves out examples and deployment considerations.
 
-Appendix C.  Change Log
-
-   This section is to be removed before publishing as an RFC.
-
-   See <https://www.ietf.org/archive/id/draft-ietf-httpbis-semantics-
-   19.html#appendix-C> for changes up to version 19 of this document.
-
-C.1.  Since draft-ietf-httpbis-semantics-19
-
-   This (unpublished) draft contains changes that were made after draft
-   19 was approved by the IESG.  Most changes are editorial only.
-   Furthermore:
-
-   *  In Section 16.3.1, add states 'obsoleted' and 'deprecated'; in
-      Section 18.4, change status 'standard' to 'permanent'
-      (<https://github.com/httpwg/http-core/issues/978>)
-
-   *  In Section 12.5.3, slightly relax requirements for handling
-      Accept-Encoding field values (<https://github.com/httpwg/http-
-      core/issues/980>)
-
-   *  In Section 18.4, update IANA instructions based on received
-      feedback (<https://github.com/httpwg/http-core/issues/982>)
-
 Acknowledgements
 
    Aside from the current editors, the following individuals deserve
@@ -10739,12 +10691,11 @@
 
          TE header field  Section 10.1.4
          TRACE method  Section 9.3.8
-         Trailer Fields
+         Trailer Fields  Section 6.5
             ETag  Section 8.8.3
          Trailer header field  Section 6.6.2
          target URI  Section 7.1
          target resource  Section 7.1
-         trailer fields  Section 6.5
          trailer section  Section 6.5
          trailers  Section 6.5
          transforming proxy  Section 7.7
